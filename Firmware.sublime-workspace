{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Att",
				"AttitudePositionEstimatorEKF"
			],
			[
				"hgtInn",
				"hgtInnovCam"
			],
			[
				"hgtHea",
				"hgtHealth2"
			],
			[
				"cu",
				"current_ekf_state"
			],
			[
				"hgtMe",
				"hgtMea2"
			],
			[
				"fuse",
				"fuseCamData"
			],
			[
				"states",
				"statesAtHgtTime"
			],
			[
				"hgt",
				"hgtMea"
			],
			[
				"obs",
				"obsIndex"
			],
			[
				"fusion",
				"fusionFlag"
			],
			[
				"alt",
				"altitude"
			],
			[
				"n_",
				"n_hgtMeas"
			],
			[
				"perf_c",
				"perf_counter_t"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_main.cpp",
			"settings":
			{
				"buffer_size": 51565,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "/****************************************************************************\n* Copyright (c) 2014, Paul Riseborough All rights reserved.\n* \n* Redistribution and use in source and binary forms, with or without \n* modification, are permitted provided that the following conditions are met:\n* \n* Redistributions of source code must retain the above copyright notice, this \n* list of conditions and the following disclaimer.\n* \n* Redistributions in binary form must reproduce the above copyright notice, \n* this list of conditions and the following disclaimer in the documentation \n* and/or other materials provided with the distribution.\n* \n* Neither the name of the {organization} nor the names of its contributors \n* may be used to endorse or promote products derived from this software without \n* specific prior written permission.\n* \n* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" \n* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE \n* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE \n* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE \n* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR \n* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF \n* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS \n* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN \n* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) \n* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE \n* POSSIBILITY OF SUCH DAMAGE.\n****************************************************************************/\n\n/**\n * @file estimator_22states.cpp\n *\n * Implementation of the attitude and position estimator.\n *\n * @author Paul Riseborough <p_riseborough@live.com.au>\n * @author Lorenz Meier <lorenz@px4.io>\n */\n\n#include \"estimator_22states.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <math.h>\n#include <algorithm>\n\n#ifndef M_PI_F\n#define M_PI_F static_cast<float>(M_PI)\n#endif\n\nconstexpr float EKF_COVARIANCE_DIVERGED = 1.0e8f;\n\nAttPosEKF::AttPosEKF() :\n    covTimeStepMax(0.0f),\n    covDelAngMax(0.0f),\n    rngFinderPitch(0.0f),\n    yawVarScale(0.0f),\n    windVelSigma(0.0f),\n    dAngBiasSigma(0.0f),\n    dVelBiasSigma(0.0f),\n    magEarthSigma(0.0f),\n    magBodySigma(0.0f),\n    gndHgtSigma(0.0f),\n    vneSigma(0.0f),\n    vdSigma(0.0f),\n    posNeSigma(0.0f),\n    posDSigma(0.0f),\n    camSigma(0.0f),\n    magMeasurementSigma(0.0f),\n    airspeedMeasurementSigma(0.0f),\n    gyroProcessNoise(0.0f),\n    accelProcessNoise(0.0f),\n    EAS2TAS(1.0f),\n    magstate{},\n    resetMagState{},\n    KH{},\n    KHP{},\n    P{},\n    Kfusion{},\n    states{},\n    resetStates{},\n    storedStates{},\n    statetimeStamp{},\n    lastVelPosFusion(millis()),\n    statesAtVelTime{},\n    statesAtPosTime{},\n    statesAtHgtTime{},\n    statesAtCamTime{},\n    statesAtMagMeasTime{},\n    statesAtVtasMeasTime{},\n    statesAtRngTime{},\n    statesAtFlowTime{},\n    correctedDelAng(),\n    correctedDelVel(),\n    summedDelAng(),\n    summedDelVel(),\n    accNavMag(),\n    earthRateNED(),\n    angRate(),\n    lastGyroOffset(),\n    delAngTotal(),\n    Tbn(),\n    Tnb(),\n    accel(),\n    dVelIMU(),\n    dAngIMU(),\n    dtIMU(0.005f),\n    dtIMUfilt(0.005f),\n    dtVelPos(0.01f),\n    dtVelPosFilt(0.01f),\n    dtHgtFilt(0.01f),\n    dtGpsFilt(0.1f),\n    fusionModeGPS(0),\n    innovVelPos{},\n    varInnovVelPos{},\n    velNED{},\n    posNE{},\n    hgtMea(0.0f),\n    hgtMea2(0.0f),\n    baroHgtOffset(0.0f),\n    rngMea(0.0f),\n    innovMag{},\n    varInnovMag{},\n    magData{},\n    innovVtas(0.0f),\n    innovRng(0.0f),\n    innovOptFlow{},\n    varInnovOptFlow{},\n    varInnovVtas(0.0f),\n    varInnovRng(0.0f),\n    VtasMeas(0.0f),\n    magDeclination(0.0f),\n    latRef(0.0f),\n    lonRef(-M_PI_F),\n    hgtRef(0.0f),\n    refSet(false),\n    magBias(),\n    covSkipCount(0),\n    lastFixTime_ms(0),\n    globalTimeStamp_ms(0),\n    gpsLat(0.0),\n    gpsLon(-M_PI),\n    gpsHgt(0.0f),\n    GPSstatus(0),\n    baroHgt(0.0f),\n    camHgt(0.0f),\n    n_hgtMeas(0), //added for a kind of a flag for how many measurements\n    fusionFlag(0),\n    fusionFlag2(0),\n    statesInitialised(false),\n    fuseVelData(false),\n    fusePosData(false),\n    fuseHgtData(false),\n    fuseCamData(false),\n    fuseMagData(false),\n    fuseVtasData(false),\n    fuseRngData(false),\n    fuseOptFlowData(false),\n\n    inhibitWindStates(true),\n    inhibitMagStates(true),\n    inhibitGndState(true),\n    inhibitScaleState(true),\n\n    staticMode(true),\n    useGPS(false),\n    useAirspeed(false), //changed from true\n    useCompass(true),\n    useRangeFinder(true),\n    useOpticalFlow(false),\n\n    ekfDiverged(false),\n    lastReset(0),\n    current_ekf_state{},\n    last_ekf_error{},\n    numericalProtection(true),\n    storeIndex(0),  \n    storedOmega{},\n    Popt{},\n    flowStates{},\n    prevPosN(0.0f),\n    prevPosE(0.0f),\n    auxFlowObsInnov{},\n    auxFlowObsInnovVar{},\n    fScaleFactorVar(0.0f),\n    Tnb_flow{},\n    R_LOS(0.0f),\n    auxFlowTestRatio{},\n    auxRngTestRatio(0.0f),\n    flowInnovGate(0.0f),\n    auxFlowInnovGate(0.0f),\n    rngInnovGate(0.0f),\n    minFlowRng(0.0f),\n    moCompR_LOS(0.0f),\n\n    _isFixedWing(false),\n    _onGround(true),\n    _accNavMagHorizontal(0.0f)\n{\n\n    memset(&last_ekf_error, 0, sizeof(last_ekf_error));\n    memset(&current_ekf_state, 0, sizeof(current_ekf_state));\n    ZeroVariables();\n    InitialiseParameters();\n}\n\nAttPosEKF::~AttPosEKF()\n{\n    //dtor\n}\n\nvoid AttPosEKF::InitialiseParameters()\n{\n    covTimeStepMax = 0.07f; // maximum time allowed between covariance predictions\n    covDelAngMax = 0.02f; // maximum delta angle between covariance predictions\n    rngFinderPitch = 0.0f; // pitch angle of laser range finder in radians. Zero is aligned with the Z body axis. Positive is RH rotation about Y body axis.\n    EAS2TAS = 1.0f;\n\n    yawVarScale = 1.0f;\n    windVelSigma = 0.1f;\n    dAngBiasSigma = 5.0e-7f;\n    dVelBiasSigma = 1e-4f;\n    magEarthSigma = 3.0e-4f;\n    magBodySigma  = 3.0e-4f;\n\n    vneSigma = 0.2f;\n    vdSigma = 0.3f;\n    posNeSigma = 2.0f;\n    posDSigma = 2.0f;\n\n    magMeasurementSigma = 0.05;\n    airspeedMeasurementSigma = 1.4f;\n    gyroProcessNoise = 1.4544411e-2f;\n    accelProcessNoise = 0.5f;\n\n    gndHgtSigma  = 0.1f; // terrain gradient 1-sigma\n    R_LOS = 0.3f; // optical flow measurement noise variance (rad/sec)^2\n    flowInnovGate = 3.0f; // number of standard deviations applied to the optical flow innovation consistency check\n    auxFlowInnovGate = 10.0f; // number of standard deviations applied to the optical flow innovation consistency check used by the auxiliary filter\n    rngInnovGate = 5.0f; // number of standard deviations applied to the range finder innovation consistency check\n    minFlowRng = 0.3f; //minimum range between ground and flow sensor\n    moCompR_LOS = 0.0; // scaler from sensor gyro rate to uncertainty in LOS rate\n}\n\n\nvoid AttPosEKF::UpdateStrapdownEquationsNED()\n{\n    Vector3f delVelNav;\n    float q00;\n    float q11;\n    float q22;\n    float q33;\n    float q01;\n    float q02;\n    float q03;\n    float q12;\n    float q13;\n    float q23;\n    float rotationMag;\n    float qUpdated[4];\n    float quatMag;\n    float deltaQuat[4];\n    const Vector3f gravityNED(0.0f, 0.0f, GRAVITY_MSS);\n\n    // Remove sensor bias errors\n    correctedDelAng.x = dAngIMU.x - states[10];\n    correctedDelAng.y = dAngIMU.y - states[11];\n    correctedDelAng.z = dAngIMU.z - states[12];\n\n    Vector3f dVelIMURel;\n\n    dVelIMURel.x = dVelIMU.x;\n    dVelIMURel.y = dVelIMU.y;\n    dVelIMURel.z = dVelIMU.z - states[13];\n\n    delAngTotal.x += correctedDelAng.x;\n    delAngTotal.y += correctedDelAng.y;\n    delAngTotal.z += correctedDelAng.z;\n\n    // Save current measurements\n    Vector3f  prevDelAng = correctedDelAng;\n\n    // Apply corrections for earths rotation rate and coning errors\n    // * and + operators have been overloaded\n    correctedDelAng   = correctedDelAng - Tnb*earthRateNED*dtIMU + 8.333333333333333e-2f*(prevDelAng % correctedDelAng);\n\n    // Convert the rotation vector to its equivalent quaternion\n    rotationMag = correctedDelAng.length();\n    if (rotationMag < 1e-12f)\n    {\n        deltaQuat[0] = 1.0;\n        deltaQuat[1] = 0.0;\n        deltaQuat[2] = 0.0;\n        deltaQuat[3] = 0.0;\n    }\n    else\n    {\n        // We are using double here as we are unsure how small\n        // the angle differences are and if we get into numeric\n        // issues with float. The runtime impact is not measurable\n        // for these quantities.\n        deltaQuat[0] = cos(0.5*(double)rotationMag);\n        float rotScaler = (sin(0.5*(double)rotationMag))/(double)rotationMag;\n        deltaQuat[1] = correctedDelAng.x*rotScaler;\n        deltaQuat[2] = correctedDelAng.y*rotScaler;\n        deltaQuat[3] = correctedDelAng.z*rotScaler;\n    }\n\n    // Update the quaternions by rotating from the previous attitude through\n    // the delta angle rotation quaternion\n    qUpdated[0] = states[0]*deltaQuat[0] - states[1]*deltaQuat[1] - states[2]*deltaQuat[2] - states[3]*deltaQuat[3];\n    qUpdated[1] = states[0]*deltaQuat[1] + states[1]*deltaQuat[0] + states[2]*deltaQuat[3] - states[3]*deltaQuat[2];\n    qUpdated[2] = states[0]*deltaQuat[2] + states[2]*deltaQuat[0] + states[3]*deltaQuat[1] - states[1]*deltaQuat[3];\n    qUpdated[3] = states[0]*deltaQuat[3] + states[3]*deltaQuat[0] + states[1]*deltaQuat[2] - states[2]*deltaQuat[1];\n\n    // Normalise the quaternions and update the quaternion states\n    quatMag = sqrtf(sq(qUpdated[0]) + sq(qUpdated[1]) + sq(qUpdated[2]) + sq(qUpdated[3]));\n    if (quatMag > 1e-16f)\n    {\n        float quatMagInv = 1.0f/quatMag;\n        states[0] = quatMagInv*qUpdated[0];\n        states[1] = quatMagInv*qUpdated[1];\n        states[2] = quatMagInv*qUpdated[2];\n        states[3] = quatMagInv*qUpdated[3];\n    }\n\n    // Calculate the body to nav cosine matrix\n    q00 = sq(states[0]);\n    q11 = sq(states[1]);\n    q22 = sq(states[2]);\n    q33 = sq(states[3]);\n    q01 =  states[0]*states[1];\n    q02 =  states[0]*states[2];\n    q03 =  states[0]*states[3];\n    q12 =  states[1]*states[2];\n    q13 =  states[1]*states[3];\n    q23 =  states[2]*states[3];\n\n    Tbn.x.x = q00 + q11 - q22 - q33;\n    Tbn.y.y = q00 - q11 + q22 - q33;\n    Tbn.z.z = q00 - q11 - q22 + q33;\n    Tbn.x.y = 2*(q12 - q03);\n    Tbn.x.z = 2*(q13 + q02);\n    Tbn.y.x = 2*(q12 + q03);\n    Tbn.y.z = 2*(q23 - q01);\n    Tbn.z.x = 2*(q13 - q02);\n    Tbn.z.y = 2*(q23 + q01);\n\n    Tnb = Tbn.transpose();\n\n    // transform body delta velocities to delta velocities in the nav frame\n    // * and + operators have been overloaded\n    //delVelNav = Tbn*dVelIMU + gravityNED*dtIMU;\n    delVelNav.x = Tbn.x.x*dVelIMURel.x + Tbn.x.y*dVelIMURel.y + Tbn.x.z*dVelIMURel.z + gravityNED.x*dtIMU;\n    delVelNav.y = Tbn.y.x*dVelIMURel.x + Tbn.y.y*dVelIMURel.y + Tbn.y.z*dVelIMURel.z + gravityNED.y*dtIMU;\n    delVelNav.z = Tbn.z.x*dVelIMURel.x + Tbn.z.y*dVelIMURel.y + Tbn.z.z*dVelIMURel.z + gravityNED.z*dtIMU;\n\n    // calculate the magnitude of the nav acceleration (required for GPS\n    // variance estimation)\n    accNavMag = delVelNav.length()/dtIMU;\n\n    //First order low-pass filtered magnitude of horizontal nav acceleration\n    Vector3f derivativeNav = (delVelNav / dtIMU);\n    float derivativeVelNavMagnitude = sqrtf(sq(derivativeNav.x) + sq(derivativeNav.y));\n    _accNavMagHorizontal = _accNavMagHorizontal * 0.95f + derivativeVelNavMagnitude * 0.05f;\n\n    // If calculating position save previous velocity\n    float lastVelocity[3];\n    lastVelocity[0] = states[4];\n    lastVelocity[1] = states[5];\n    lastVelocity[2] = states[6];\n\n    // Sum delta velocities to get velocity\n    states[4] = states[4] + delVelNav.x;\n    states[5] = states[5] + delVelNav.y;\n    states[6] = states[6] + delVelNav.z;\n\n    // If calculating postions, do a trapezoidal integration for position\n    states[7] = states[7] + 0.5f*(states[4] + lastVelocity[0])*dtIMU;\n    states[8] = states[8] + 0.5f*(states[5] + lastVelocity[1])*dtIMU;\n    states[9] = states[9] + 0.5f*(states[6] + lastVelocity[2])*dtIMU;\n\n    // Constrain states (to protect against filter divergence)\n    ConstrainStates();\n\n    // update filtered IMU time step length\n    dtIMUfilt = 0.99f * dtIMUfilt + 0.01f * dtIMU;\n}\n\nvoid AttPosEKF::CovariancePrediction(float dt)\n{\n    // scalars\n    float daxCov;\n    float dayCov;\n    float dazCov;\n    float dvxCov;\n    float dvyCov;\n    float dvzCov;\n    float dvx;\n    float dvy;\n    float dvz;\n    float dax;\n    float day;\n    float daz;\n    float q0;\n    float q1;\n    float q2;\n    float q3;\n    float dax_b;\n    float day_b;\n    float daz_b;\n    float dvz_b;\n\n    // arrays\n    float processNoise[EKF_STATE_ESTIMATES];\n    float SF[15];\n    float SG[8];\n    float SQ[11];\n    float SPP[8] = {0};\n    float nextP[EKF_STATE_ESTIMATES][EKF_STATE_ESTIMATES];\n\n    // calculate covariance prediction process noise\n    for (uint8_t i= 0; i<4;  i++) processNoise[i] = 1.0e-9f;\n    for (uint8_t i= 4; i<10;  i++) processNoise[i] = 1.0e-9f;\n    for (uint8_t i=10; i<=12; i++) processNoise[i] = dt * dAngBiasSigma;\n    // scale gyro bias noise when on ground to allow for faster bias estimation\n    for (uint8_t i=10; i<=12; i++) processNoise[i] = dt * dAngBiasSigma;\n    processNoise[13] = dVelBiasSigma;\n    if (!inhibitWindStates) {\n        for (uint8_t i=14; i<=15; i++) processNoise[i] = dt * windVelSigma;\n    } else {\n        for (uint8_t i=14; i<=15; i++) processNoise[i] = 0;\n    }\n    if (!inhibitMagStates) {\n        for (uint8_t i=16; i<=18; i++) processNoise[i] = dt * magEarthSigma;\n        for (uint8_t i=19; i < EKF_STATE_ESTIMATES; i++) processNoise[i] = dt * magBodySigma;\n    } else {\n        for (uint8_t i=16; i < EKF_STATE_ESTIMATES; i++) processNoise[i] = 0;\n    }\n\n    // square all sigmas\n    for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++) processNoise[i] = sq(processNoise[i]);\n\n    // set variables used to calculate covariance growth\n    dvx = summedDelVel.x;\n    dvy = summedDelVel.y;\n    dvz = summedDelVel.z;\n    dax = summedDelAng.x;\n    day = summedDelAng.y;\n    daz = summedDelAng.z;\n    q0 = states[0];\n    q1 = states[1];\n    q2 = states[2];\n    q3 = states[3];\n    dax_b = states[10];\n    day_b = states[11];\n    daz_b = states[12];\n    dvz_b =  states[13];\n    gyroProcessNoise = ConstrainFloat(gyroProcessNoise, 1e-3f, 5e-2f);\n    daxCov = sq(dt*gyroProcessNoise);\n    dayCov = sq(dt*gyroProcessNoise);\n    dazCov = sq(dt*gyroProcessNoise);\n    if (_onGround) dazCov = dazCov * sq(yawVarScale);\n    accelProcessNoise = ConstrainFloat(accelProcessNoise, 5e-2, 1.0f);\n    dvxCov = sq(dt*accelProcessNoise);\n    dvyCov = sq(dt*accelProcessNoise);\n    dvzCov = sq(dt*accelProcessNoise);\n\n    // Predicted covariance calculation\n    SF[0] = dvz - dvz_b;\n    SF[1] = 2*q3*SF[0] + 2*dvx*q1 + 2*dvy*q2;\n    SF[2] = 2*dvx*q3 - 2*q1*SF[0] + 2*dvy*q0;\n    SF[3] = 2*q2*SF[0] + 2*dvx*q0 - 2*dvy*q3;\n    SF[4] = day/2 - day_b/2;\n    SF[5] = daz/2 - daz_b/2;\n    SF[6] = dax/2 - dax_b/2;\n    SF[7] = dax_b/2 - dax/2;\n    SF[8] = daz_b/2 - daz/2;\n    SF[9] = day_b/2 - day/2;\n    SF[10] = 2*q0*SF[0];\n    SF[11] = q1/2;\n    SF[12] = q2/2;\n    SF[13] = q3/2;\n    SF[14] = 2*dvy*q1;\n\n    SG[0] = q0/2;\n    SG[1] = sq(q3);\n    SG[2] = sq(q2);\n    SG[3] = sq(q1);\n    SG[4] = sq(q0);\n    SG[5] = 2*q2*q3;\n    SG[6] = 2*q1*q3;\n    SG[7] = 2*q1*q2;\n\n    SQ[0] = dvzCov*(SG[5] - 2*q0*q1)*(SG[1] - SG[2] - SG[3] + SG[4]) - dvyCov*(SG[5] + 2*q0*q1)*(SG[1] - SG[2] + SG[3] - SG[4]) + dvxCov*(SG[6] - 2*q0*q2)*(SG[7] + 2*q0*q3);\n    SQ[1] = dvzCov*(SG[6] + 2*q0*q2)*(SG[1] - SG[2] - SG[3] + SG[4]) - dvxCov*(SG[6] - 2*q0*q2)*(SG[1] + SG[2] - SG[3] - SG[4]) + dvyCov*(SG[5] + 2*q0*q1)*(SG[7] - 2*q0*q3);\n    SQ[2] = dvzCov*(SG[5] - 2*q0*q1)*(SG[6] + 2*q0*q2) - dvyCov*(SG[7] - 2*q0*q3)*(SG[1] - SG[2] + SG[3] - SG[4]) - dvxCov*(SG[7] + 2*q0*q3)*(SG[1] + SG[2] - SG[3] - SG[4]);\n    SQ[3] = (dayCov*q1*SG[0])/2 - (dazCov*q1*SG[0])/2 - (daxCov*q2*q3)/4;\n    SQ[4] = (dazCov*q2*SG[0])/2 - (daxCov*q2*SG[0])/2 - (dayCov*q1*q3)/4;\n    SQ[5] = (daxCov*q3*SG[0])/2 - (dayCov*q3*SG[0])/2 - (dazCov*q1*q2)/4;\n    SQ[6] = (daxCov*q1*q2)/4 - (dazCov*q3*SG[0])/2 - (dayCov*q1*q2)/4;\n    SQ[7] = (dazCov*q1*q3)/4 - (daxCov*q1*q3)/4 - (dayCov*q2*SG[0])/2;\n    SQ[8] = (dayCov*q2*q3)/4 - (daxCov*q1*SG[0])/2 - (dazCov*q2*q3)/4;\n    SQ[9] = sq(SG[0]);\n    SQ[10] = sq(q1);\n\n    SPP[0] = SF[10] + SF[14] - 2*dvx*q2;\n    SPP[1] = 2*q2*SF[0] + 2*dvx*q0 - 2*dvy*q3;\n    SPP[2] = 2*dvx*q3 - 2*q1*SF[0] + 2*dvy*q0;\n    SPP[3] = 2*q0*q1 - 2*q2*q3;\n    SPP[4] = 2*q0*q2 + 2*q1*q3;\n    SPP[5] = sq(q0) - sq(q1) - sq(q2) + sq(q3);\n    SPP[6] = SF[13];\n    SPP[7] = SF[12];\n\n    nextP[0][0] = P[0][0] + P[1][0]*SF[7] + P[2][0]*SF[9] + P[3][0]*SF[8] + P[10][0]*SF[11] + P[11][0]*SPP[7] + P[12][0]*SPP[6] + (daxCov*SQ[10])/4 + SF[7]*(P[0][1] + P[1][1]*SF[7] + P[2][1]*SF[9] + P[3][1]*SF[8] + P[10][1]*SF[11] + P[11][1]*SPP[7] + P[12][1]*SPP[6]) + SF[9]*(P[0][2] + P[1][2]*SF[7] + P[2][2]*SF[9] + P[3][2]*SF[8] + P[10][2]*SF[11] + P[11][2]*SPP[7] + P[12][2]*SPP[6]) + SF[8]*(P[0][3] + P[1][3]*SF[7] + P[2][3]*SF[9] + P[3][3]*SF[8] + P[10][3]*SF[11] + P[11][3]*SPP[7] + P[12][3]*SPP[6]) + SF[11]*(P[0][10] + P[1][10]*SF[7] + P[2][10]*SF[9] + P[3][10]*SF[8] + P[10][10]*SF[11] + P[11][10]*SPP[7] + P[12][10]*SPP[6]) + SPP[7]*(P[0][11] + P[1][11]*SF[7] + P[2][11]*SF[9] + P[3][11]*SF[8] + P[10][11]*SF[11] + P[11][11]*SPP[7] + P[12][11]*SPP[6]) + SPP[6]*(P[0][12] + P[1][12]*SF[7] + P[2][12]*SF[9] + P[3][12]*SF[8] + P[10][12]*SF[11] + P[11][12]*SPP[7] + P[12][12]*SPP[6]) + (dayCov*sq(q2))/4 + (dazCov*sq(q3))/4;\n    nextP[0][1] = P[0][1] + SQ[8] + P[1][1]*SF[7] + P[2][1]*SF[9] + P[3][1]*SF[8] + P[10][1]*SF[11] + P[11][1]*SPP[7] + P[12][1]*SPP[6] + SF[6]*(P[0][0] + P[1][0]*SF[7] + P[2][0]*SF[9] + P[3][0]*SF[8] + P[10][0]*SF[11] + P[11][0]*SPP[7] + P[12][0]*SPP[6]) + SF[5]*(P[0][2] + P[1][2]*SF[7] + P[2][2]*SF[9] + P[3][2]*SF[8] + P[10][2]*SF[11] + P[11][2]*SPP[7] + P[12][2]*SPP[6]) + SF[9]*(P[0][3] + P[1][3]*SF[7] + P[2][3]*SF[9] + P[3][3]*SF[8] + P[10][3]*SF[11] + P[11][3]*SPP[7] + P[12][3]*SPP[6]) + SPP[6]*(P[0][11] + P[1][11]*SF[7] + P[2][11]*SF[9] + P[3][11]*SF[8] + P[10][11]*SF[11] + P[11][11]*SPP[7] + P[12][11]*SPP[6]) - SPP[7]*(P[0][12] + P[1][12]*SF[7] + P[2][12]*SF[9] + P[3][12]*SF[8] + P[10][12]*SF[11] + P[11][12]*SPP[7] + P[12][12]*SPP[6]) - (q0*(P[0][10] + P[1][10]*SF[7] + P[2][10]*SF[9] + P[3][10]*SF[8] + P[10][10]*SF[11] + P[11][10]*SPP[7] + P[12][10]*SPP[6]))/2;\n    nextP[0][2] = P[0][2] + SQ[7] + P[1][2]*SF[7] + P[2][2]*SF[9] + P[3][2]*SF[8] + P[10][2]*SF[11] + P[11][2]*SPP[7] + P[12][2]*SPP[6] + SF[4]*(P[0][0] + P[1][0]*SF[7] + P[2][0]*SF[9] + P[3][0]*SF[8] + P[10][0]*SF[11] + P[11][0]*SPP[7] + P[12][0]*SPP[6]) + SF[8]*(P[0][1] + P[1][1]*SF[7] + P[2][1]*SF[9] + P[3][1]*SF[8] + P[10][1]*SF[11] + P[11][1]*SPP[7] + P[12][1]*SPP[6]) + SF[6]*(P[0][3] + P[1][3]*SF[7] + P[2][3]*SF[9] + P[3][3]*SF[8] + P[10][3]*SF[11] + P[11][3]*SPP[7] + P[12][3]*SPP[6]) + SF[11]*(P[0][12] + P[1][12]*SF[7] + P[2][12]*SF[9] + P[3][12]*SF[8] + P[10][12]*SF[11] + P[11][12]*SPP[7] + P[12][12]*SPP[6]) - SPP[6]*(P[0][10] + P[1][10]*SF[7] + P[2][10]*SF[9] + P[3][10]*SF[8] + P[10][10]*SF[11] + P[11][10]*SPP[7] + P[12][10]*SPP[6]) - (q0*(P[0][11] + P[1][11]*SF[7] + P[2][11]*SF[9] + P[3][11]*SF[8] + P[10][11]*SF[11] + P[11][11]*SPP[7] + P[12][11]*SPP[6]))/2;\n    nextP[0][3] = P[0][3] + SQ[6] + P[1][3]*SF[7] + P[2][3]*SF[9] + P[3][3]*SF[8] + P[10][3]*SF[11] + P[11][3]*SPP[7] + P[12][3]*SPP[6] + SF[5]*(P[0][0] + P[1][0]*SF[7] + P[2][0]*SF[9] + P[3][0]*SF[8] + P[10][0]*SF[11] + P[11][0]*SPP[7] + P[12][0]*SPP[6]) + SF[4]*(P[0][1] + P[1][1]*SF[7] + P[2][1]*SF[9] + P[3][1]*SF[8] + P[10][1]*SF[11] + P[11][1]*SPP[7] + P[12][1]*SPP[6]) + SF[7]*(P[0][2] + P[1][2]*SF[7] + P[2][2]*SF[9] + P[3][2]*SF[8] + P[10][2]*SF[11] + P[11][2]*SPP[7] + P[12][2]*SPP[6]) - SF[11]*(P[0][11] + P[1][11]*SF[7] + P[2][11]*SF[9] + P[3][11]*SF[8] + P[10][11]*SF[11] + P[11][11]*SPP[7] + P[12][11]*SPP[6]) + SPP[7]*(P[0][10] + P[1][10]*SF[7] + P[2][10]*SF[9] + P[3][10]*SF[8] + P[10][10]*SF[11] + P[11][10]*SPP[7] + P[12][10]*SPP[6]) - (q0*(P[0][12] + P[1][12]*SF[7] + P[2][12]*SF[9] + P[3][12]*SF[8] + P[10][12]*SF[11] + P[11][12]*SPP[7] + P[12][12]*SPP[6]))/2;\n    nextP[0][4] = P[0][4] + P[1][4]*SF[7] + P[2][4]*SF[9] + P[3][4]*SF[8] + P[10][4]*SF[11] + P[11][4]*SPP[7] + P[12][4]*SPP[6] + SF[3]*(P[0][0] + P[1][0]*SF[7] + P[2][0]*SF[9] + P[3][0]*SF[8] + P[10][0]*SF[11] + P[11][0]*SPP[7] + P[12][0]*SPP[6]) + SF[1]*(P[0][1] + P[1][1]*SF[7] + P[2][1]*SF[9] + P[3][1]*SF[8] + P[10][1]*SF[11] + P[11][1]*SPP[7] + P[12][1]*SPP[6]) + SPP[0]*(P[0][2] + P[1][2]*SF[7] + P[2][2]*SF[9] + P[3][2]*SF[8] + P[10][2]*SF[11] + P[11][2]*SPP[7] + P[12][2]*SPP[6]) - SPP[2]*(P[0][3] + P[1][3]*SF[7] + P[2][3]*SF[9] + P[3][3]*SF[8] + P[10][3]*SF[11] + P[11][3]*SPP[7] + P[12][3]*SPP[6]) - SPP[4]*(P[0][13] + P[1][13]*SF[7] + P[2][13]*SF[9] + P[3][13]*SF[8] + P[10][13]*SF[11] + P[11][13]*SPP[7] + P[12][13]*SPP[6]);\n    nextP[0][5] = P[0][5] + P[1][5]*SF[7] + P[2][5]*SF[9] + P[3][5]*SF[8] + P[10][5]*SF[11] + P[11][5]*SPP[7] + P[12][5]*SPP[6] + SF[2]*(P[0][0] + P[1][0]*SF[7] + P[2][0]*SF[9] + P[3][0]*SF[8] + P[10][0]*SF[11] + P[11][0]*SPP[7] + P[12][0]*SPP[6]) + SF[1]*(P[0][2] + P[1][2]*SF[7] + P[2][2]*SF[9] + P[3][2]*SF[8] + P[10][2]*SF[11] + P[11][2]*SPP[7] + P[12][2]*SPP[6]) + SF[3]*(P[0][3] + P[1][3]*SF[7] + P[2][3]*SF[9] + P[3][3]*SF[8] + P[10][3]*SF[11] + P[11][3]*SPP[7] + P[12][3]*SPP[6]) - SPP[0]*(P[0][1] + P[1][1]*SF[7] + P[2][1]*SF[9] + P[3][1]*SF[8] + P[10][1]*SF[11] + P[11][1]*SPP[7] + P[12][1]*SPP[6]) + SPP[3]*(P[0][13] + P[1][13]*SF[7] + P[2][13]*SF[9] + P[3][13]*SF[8] + P[10][13]*SF[11] + P[11][13]*SPP[7] + P[12][13]*SPP[6]);\n    nextP[0][6] = P[0][6] + P[1][6]*SF[7] + P[2][6]*SF[9] + P[3][6]*SF[8] + P[10][6]*SF[11] + P[11][6]*SPP[7] + P[12][6]*SPP[6] + SF[2]*(P[0][1] + P[1][1]*SF[7] + P[2][1]*SF[9] + P[3][1]*SF[8] + P[10][1]*SF[11] + P[11][1]*SPP[7] + P[12][1]*SPP[6]) + SF[1]*(P[0][3] + P[1][3]*SF[7] + P[2][3]*SF[9] + P[3][3]*SF[8] + P[10][3]*SF[11] + P[11][3]*SPP[7] + P[12][3]*SPP[6]) + SPP[0]*(P[0][0] + P[1][0]*SF[7] + P[2][0]*SF[9] + P[3][0]*SF[8] + P[10][0]*SF[11] + P[11][0]*SPP[7] + P[12][0]*SPP[6]) - SPP[1]*(P[0][2] + P[1][2]*SF[7] + P[2][2]*SF[9] + P[3][2]*SF[8] + P[10][2]*SF[11] + P[11][2]*SPP[7] + P[12][2]*SPP[6]) - (sq(q0) - sq(q1) - sq(q2) + sq(q3))*(P[0][13] + P[1][13]*SF[7] + P[2][13]*SF[9] + P[3][13]*SF[8] + P[10][13]*SF[11] + P[11][13]*SPP[7] + P[12][13]*SPP[6]);\n    nextP[0][7] = P[0][7] + P[1][7]*SF[7] + P[2][7]*SF[9] + P[3][7]*SF[8] + P[10][7]*SF[11] + P[11][7]*SPP[7] + P[12][7]*SPP[6] + dt*(P[0][4] + P[1][4]*SF[7] + P[2][4]*SF[9] + P[3][4]*SF[8] + P[10][4]*SF[11] + P[11][4]*SPP[7] + P[12][4]*SPP[6]);\n    nextP[0][8] = P[0][8] + P[1][8]*SF[7] + P[2][8]*SF[9] + P[3][8]*SF[8] + P[10][8]*SF[11] + P[11][8]*SPP[7] + P[12][8]*SPP[6] + dt*(P[0][5] + P[1][5]*SF[7] + P[2][5]*SF[9] + P[3][5]*SF[8] + P[10][5]*SF[11] + P[11][5]*SPP[7] + P[12][5]*SPP[6]);\n    nextP[0][9] = P[0][9] + P[1][9]*SF[7] + P[2][9]*SF[9] + P[3][9]*SF[8] + P[10][9]*SF[11] + P[11][9]*SPP[7] + P[12][9]*SPP[6] + dt*(P[0][6] + P[1][6]*SF[7] + P[2][6]*SF[9] + P[3][6]*SF[8] + P[10][6]*SF[11] + P[11][6]*SPP[7] + P[12][6]*SPP[6]);\n    nextP[0][10] = P[0][10] + P[1][10]*SF[7] + P[2][10]*SF[9] + P[3][10]*SF[8] + P[10][10]*SF[11] + P[11][10]*SPP[7] + P[12][10]*SPP[6];\n    nextP[0][11] = P[0][11] + P[1][11]*SF[7] + P[2][11]*SF[9] + P[3][11]*SF[8] + P[10][11]*SF[11] + P[11][11]*SPP[7] + P[12][11]*SPP[6];\n    nextP[0][12] = P[0][12] + P[1][12]*SF[7] + P[2][12]*SF[9] + P[3][12]*SF[8] + P[10][12]*SF[11] + P[11][12]*SPP[7] + P[12][12]*SPP[6];\n    nextP[0][13] = P[0][13] + P[1][13]*SF[7] + P[2][13]*SF[9] + P[3][13]*SF[8] + P[10][13]*SF[11] + P[11][13]*SPP[7] + P[12][13]*SPP[6];\n    nextP[0][14] = P[0][14] + P[1][14]*SF[7] + P[2][14]*SF[9] + P[3][14]*SF[8] + P[10][14]*SF[11] + P[11][14]*SPP[7] + P[12][14]*SPP[6];\n    nextP[0][15] = P[0][15] + P[1][15]*SF[7] + P[2][15]*SF[9] + P[3][15]*SF[8] + P[10][15]*SF[11] + P[11][15]*SPP[7] + P[12][15]*SPP[6];\n    nextP[0][16] = P[0][16] + P[1][16]*SF[7] + P[2][16]*SF[9] + P[3][16]*SF[8] + P[10][16]*SF[11] + P[11][16]*SPP[7] + P[12][16]*SPP[6];\n    nextP[0][17] = P[0][17] + P[1][17]*SF[7] + P[2][17]*SF[9] + P[3][17]*SF[8] + P[10][17]*SF[11] + P[11][17]*SPP[7] + P[12][17]*SPP[6];\n    nextP[0][18] = P[0][18] + P[1][18]*SF[7] + P[2][18]*SF[9] + P[3][18]*SF[8] + P[10][18]*SF[11] + P[11][18]*SPP[7] + P[12][18]*SPP[6];\n    nextP[0][19] = P[0][19] + P[1][19]*SF[7] + P[2][19]*SF[9] + P[3][19]*SF[8] + P[10][19]*SF[11] + P[11][19]*SPP[7] + P[12][19]*SPP[6];\n    nextP[0][20] = P[0][20] + P[1][20]*SF[7] + P[2][20]*SF[9] + P[3][20]*SF[8] + P[10][20]*SF[11] + P[11][20]*SPP[7] + P[12][20]*SPP[6];\n    nextP[0][21] = P[0][21] + P[1][21]*SF[7] + P[2][21]*SF[9] + P[3][21]*SF[8] + P[10][21]*SF[11] + P[11][21]*SPP[7] + P[12][21]*SPP[6];\n    nextP[1][0] = P[1][0] + SQ[8] + P[0][0]*SF[6] + P[2][0]*SF[5] + P[3][0]*SF[9] + P[11][0]*SPP[6] - P[12][0]*SPP[7] - (P[10][0]*q0)/2 + SF[7]*(P[1][1] + P[0][1]*SF[6] + P[2][1]*SF[5] + P[3][1]*SF[9] + P[11][1]*SPP[6] - P[12][1]*SPP[7] - (P[10][1]*q0)/2) + SF[9]*(P[1][2] + P[0][2]*SF[6] + P[2][2]*SF[5] + P[3][2]*SF[9] + P[11][2]*SPP[6] - P[12][2]*SPP[7] - (P[10][2]*q0)/2) + SF[8]*(P[1][3] + P[0][3]*SF[6] + P[2][3]*SF[5] + P[3][3]*SF[9] + P[11][3]*SPP[6] - P[12][3]*SPP[7] - (P[10][3]*q0)/2) + SF[11]*(P[1][10] + P[0][10]*SF[6] + P[2][10]*SF[5] + P[3][10]*SF[9] + P[11][10]*SPP[6] - P[12][10]*SPP[7] - (P[10][10]*q0)/2) + SPP[7]*(P[1][11] + P[0][11]*SF[6] + P[2][11]*SF[5] + P[3][11]*SF[9] + P[11][11]*SPP[6] - P[12][11]*SPP[7] - (P[10][11]*q0)/2) + SPP[6]*(P[1][12] + P[0][12]*SF[6] + P[2][12]*SF[5] + P[3][12]*SF[9] + P[11][12]*SPP[6] - P[12][12]*SPP[7] - (P[10][12]*q0)/2);\n    nextP[1][1] = P[1][1] + P[0][1]*SF[6] + P[2][1]*SF[5] + P[3][1]*SF[9] + P[11][1]*SPP[6] - P[12][1]*SPP[7] + daxCov*SQ[9] - (P[10][1]*q0)/2 + SF[6]*(P[1][0] + P[0][0]*SF[6] + P[2][0]*SF[5] + P[3][0]*SF[9] + P[11][0]*SPP[6] - P[12][0]*SPP[7] - (P[10][0]*q0)/2) + SF[5]*(P[1][2] + P[0][2]*SF[6] + P[2][2]*SF[5] + P[3][2]*SF[9] + P[11][2]*SPP[6] - P[12][2]*SPP[7] - (P[10][2]*q0)/2) + SF[9]*(P[1][3] + P[0][3]*SF[6] + P[2][3]*SF[5] + P[3][3]*SF[9] + P[11][3]*SPP[6] - P[12][3]*SPP[7] - (P[10][3]*q0)/2) + SPP[6]*(P[1][11] + P[0][11]*SF[6] + P[2][11]*SF[5] + P[3][11]*SF[9] + P[11][11]*SPP[6] - P[12][11]*SPP[7] - (P[10][11]*q0)/2) - SPP[7]*(P[1][12] + P[0][12]*SF[6] + P[2][12]*SF[5] + P[3][12]*SF[9] + P[11][12]*SPP[6] - P[12][12]*SPP[7] - (P[10][12]*q0)/2) + (dayCov*sq(q3))/4 + (dazCov*sq(q2))/4 - (q0*(P[1][10] + P[0][10]*SF[6] + P[2][10]*SF[5] + P[3][10]*SF[9] + P[11][10]*SPP[6] - P[12][10]*SPP[7] - (P[10][10]*q0)/2))/2;\n    nextP[1][2] = P[1][2] + SQ[5] + P[0][2]*SF[6] + P[2][2]*SF[5] + P[3][2]*SF[9] + P[11][2]*SPP[6] - P[12][2]*SPP[7] - (P[10][2]*q0)/2 + SF[4]*(P[1][0] + P[0][0]*SF[6] + P[2][0]*SF[5] + P[3][0]*SF[9] + P[11][0]*SPP[6] - P[12][0]*SPP[7] - (P[10][0]*q0)/2) + SF[8]*(P[1][1] + P[0][1]*SF[6] + P[2][1]*SF[5] + P[3][1]*SF[9] + P[11][1]*SPP[6] - P[12][1]*SPP[7] - (P[10][1]*q0)/2) + SF[6]*(P[1][3] + P[0][3]*SF[6] + P[2][3]*SF[5] + P[3][3]*SF[9] + P[11][3]*SPP[6] - P[12][3]*SPP[7] - (P[10][3]*q0)/2) + SF[11]*(P[1][12] + P[0][12]*SF[6] + P[2][12]*SF[5] + P[3][12]*SF[9] + P[11][12]*SPP[6] - P[12][12]*SPP[7] - (P[10][12]*q0)/2) - SPP[6]*(P[1][10] + P[0][10]*SF[6] + P[2][10]*SF[5] + P[3][10]*SF[9] + P[11][10]*SPP[6] - P[12][10]*SPP[7] - (P[10][10]*q0)/2) - (q0*(P[1][11] + P[0][11]*SF[6] + P[2][11]*SF[5] + P[3][11]*SF[9] + P[11][11]*SPP[6] - P[12][11]*SPP[7] - (P[10][11]*q0)/2))/2;\n    nextP[1][3] = P[1][3] + SQ[4] + P[0][3]*SF[6] + P[2][3]*SF[5] + P[3][3]*SF[9] + P[11][3]*SPP[6] - P[12][3]*SPP[7] - (P[10][3]*q0)/2 + SF[5]*(P[1][0] + P[0][0]*SF[6] + P[2][0]*SF[5] + P[3][0]*SF[9] + P[11][0]*SPP[6] - P[12][0]*SPP[7] - (P[10][0]*q0)/2) + SF[4]*(P[1][1] + P[0][1]*SF[6] + P[2][1]*SF[5] + P[3][1]*SF[9] + P[11][1]*SPP[6] - P[12][1]*SPP[7] - (P[10][1]*q0)/2) + SF[7]*(P[1][2] + P[0][2]*SF[6] + P[2][2]*SF[5] + P[3][2]*SF[9] + P[11][2]*SPP[6] - P[12][2]*SPP[7] - (P[10][2]*q0)/2) - SF[11]*(P[1][11] + P[0][11]*SF[6] + P[2][11]*SF[5] + P[3][11]*SF[9] + P[11][11]*SPP[6] - P[12][11]*SPP[7] - (P[10][11]*q0)/2) + SPP[7]*(P[1][10] + P[0][10]*SF[6] + P[2][10]*SF[5] + P[3][10]*SF[9] + P[11][10]*SPP[6] - P[12][10]*SPP[7] - (P[10][10]*q0)/2) - (q0*(P[1][12] + P[0][12]*SF[6] + P[2][12]*SF[5] + P[3][12]*SF[9] + P[11][12]*SPP[6] - P[12][12]*SPP[7] - (P[10][12]*q0)/2))/2;\n    nextP[1][4] = P[1][4] + P[0][4]*SF[6] + P[2][4]*SF[5] + P[3][4]*SF[9] + P[11][4]*SPP[6] - P[12][4]*SPP[7] - (P[10][4]*q0)/2 + SF[3]*(P[1][0] + P[0][0]*SF[6] + P[2][0]*SF[5] + P[3][0]*SF[9] + P[11][0]*SPP[6] - P[12][0]*SPP[7] - (P[10][0]*q0)/2) + SF[1]*(P[1][1] + P[0][1]*SF[6] + P[2][1]*SF[5] + P[3][1]*SF[9] + P[11][1]*SPP[6] - P[12][1]*SPP[7] - (P[10][1]*q0)/2) + SPP[0]*(P[1][2] + P[0][2]*SF[6] + P[2][2]*SF[5] + P[3][2]*SF[9] + P[11][2]*SPP[6] - P[12][2]*SPP[7] - (P[10][2]*q0)/2) - SPP[2]*(P[1][3] + P[0][3]*SF[6] + P[2][3]*SF[5] + P[3][3]*SF[9] + P[11][3]*SPP[6] - P[12][3]*SPP[7] - (P[10][3]*q0)/2) - SPP[4]*(P[1][13] + P[0][13]*SF[6] + P[2][13]*SF[5] + P[3][13]*SF[9] + P[11][13]*SPP[6] - P[12][13]*SPP[7] - (P[10][13]*q0)/2);\n    nextP[1][5] = P[1][5] + P[0][5]*SF[6] + P[2][5]*SF[5] + P[3][5]*SF[9] + P[11][5]*SPP[6] - P[12][5]*SPP[7] - (P[10][5]*q0)/2 + SF[2]*(P[1][0] + P[0][0]*SF[6] + P[2][0]*SF[5] + P[3][0]*SF[9] + P[11][0]*SPP[6] - P[12][0]*SPP[7] - (P[10][0]*q0)/2) + SF[1]*(P[1][2] + P[0][2]*SF[6] + P[2][2]*SF[5] + P[3][2]*SF[9] + P[11][2]*SPP[6] - P[12][2]*SPP[7] - (P[10][2]*q0)/2) + SF[3]*(P[1][3] + P[0][3]*SF[6] + P[2][3]*SF[5] + P[3][3]*SF[9] + P[11][3]*SPP[6] - P[12][3]*SPP[7] - (P[10][3]*q0)/2) - SPP[0]*(P[1][1] + P[0][1]*SF[6] + P[2][1]*SF[5] + P[3][1]*SF[9] + P[11][1]*SPP[6] - P[12][1]*SPP[7] - (P[10][1]*q0)/2) + SPP[3]*(P[1][13] + P[0][13]*SF[6] + P[2][13]*SF[5] + P[3][13]*SF[9] + P[11][13]*SPP[6] - P[12][13]*SPP[7] - (P[10][13]*q0)/2);\n    nextP[1][6] = P[1][6] + P[0][6]*SF[6] + P[2][6]*SF[5] + P[3][6]*SF[9] + P[11][6]*SPP[6] - P[12][6]*SPP[7] - (P[10][6]*q0)/2 + SF[2]*(P[1][1] + P[0][1]*SF[6] + P[2][1]*SF[5] + P[3][1]*SF[9] + P[11][1]*SPP[6] - P[12][1]*SPP[7] - (P[10][1]*q0)/2) + SF[1]*(P[1][3] + P[0][3]*SF[6] + P[2][3]*SF[5] + P[3][3]*SF[9] + P[11][3]*SPP[6] - P[12][3]*SPP[7] - (P[10][3]*q0)/2) + SPP[0]*(P[1][0] + P[0][0]*SF[6] + P[2][0]*SF[5] + P[3][0]*SF[9] + P[11][0]*SPP[6] - P[12][0]*SPP[7] - (P[10][0]*q0)/2) - SPP[1]*(P[1][2] + P[0][2]*SF[6] + P[2][2]*SF[5] + P[3][2]*SF[9] + P[11][2]*SPP[6] - P[12][2]*SPP[7] - (P[10][2]*q0)/2) - (sq(q0) - sq(q1) - sq(q2) + sq(q3))*(P[1][13] + P[0][13]*SF[6] + P[2][13]*SF[5] + P[3][13]*SF[9] + P[11][13]*SPP[6] - P[12][13]*SPP[7] - (P[10][13]*q0)/2);\n    nextP[1][7] = P[1][7] + P[0][7]*SF[6] + P[2][7]*SF[5] + P[3][7]*SF[9] + P[11][7]*SPP[6] - P[12][7]*SPP[7] - (P[10][7]*q0)/2 + dt*(P[1][4] + P[0][4]*SF[6] + P[2][4]*SF[5] + P[3][4]*SF[9] + P[11][4]*SPP[6] - P[12][4]*SPP[7] - (P[10][4]*q0)/2);\n    nextP[1][8] = P[1][8] + P[0][8]*SF[6] + P[2][8]*SF[5] + P[3][8]*SF[9] + P[11][8]*SPP[6] - P[12][8]*SPP[7] - (P[10][8]*q0)/2 + dt*(P[1][5] + P[0][5]*SF[6] + P[2][5]*SF[5] + P[3][5]*SF[9] + P[11][5]*SPP[6] - P[12][5]*SPP[7] - (P[10][5]*q0)/2);\n    nextP[1][9] = P[1][9] + P[0][9]*SF[6] + P[2][9]*SF[5] + P[3][9]*SF[9] + P[11][9]*SPP[6] - P[12][9]*SPP[7] - (P[10][9]*q0)/2 + dt*(P[1][6] + P[0][6]*SF[6] + P[2][6]*SF[5] + P[3][6]*SF[9] + P[11][6]*SPP[6] - P[12][6]*SPP[7] - (P[10][6]*q0)/2);\n    nextP[1][10] = P[1][10] + P[0][10]*SF[6] + P[2][10]*SF[5] + P[3][10]*SF[9] + P[11][10]*SPP[6] - P[12][10]*SPP[7] - (P[10][10]*q0)/2;\n    nextP[1][11] = P[1][11] + P[0][11]*SF[6] + P[2][11]*SF[5] + P[3][11]*SF[9] + P[11][11]*SPP[6] - P[12][11]*SPP[7] - (P[10][11]*q0)/2;\n    nextP[1][12] = P[1][12] + P[0][12]*SF[6] + P[2][12]*SF[5] + P[3][12]*SF[9] + P[11][12]*SPP[6] - P[12][12]*SPP[7] - (P[10][12]*q0)/2;\n    nextP[1][13] = P[1][13] + P[0][13]*SF[6] + P[2][13]*SF[5] + P[3][13]*SF[9] + P[11][13]*SPP[6] - P[12][13]*SPP[7] - (P[10][13]*q0)/2;\n    nextP[1][14] = P[1][14] + P[0][14]*SF[6] + P[2][14]*SF[5] + P[3][14]*SF[9] + P[11][14]*SPP[6] - P[12][14]*SPP[7] - (P[10][14]*q0)/2;\n    nextP[1][15] = P[1][15] + P[0][15]*SF[6] + P[2][15]*SF[5] + P[3][15]*SF[9] + P[11][15]*SPP[6] - P[12][15]*SPP[7] - (P[10][15]*q0)/2;\n    nextP[1][16] = P[1][16] + P[0][16]*SF[6] + P[2][16]*SF[5] + P[3][16]*SF[9] + P[11][16]*SPP[6] - P[12][16]*SPP[7] - (P[10][16]*q0)/2;\n    nextP[1][17] = P[1][17] + P[0][17]*SF[6] + P[2][17]*SF[5] + P[3][17]*SF[9] + P[11][17]*SPP[6] - P[12][17]*SPP[7] - (P[10][17]*q0)/2;\n    nextP[1][18] = P[1][18] + P[0][18]*SF[6] + P[2][18]*SF[5] + P[3][18]*SF[9] + P[11][18]*SPP[6] - P[12][18]*SPP[7] - (P[10][18]*q0)/2;\n    nextP[1][19] = P[1][19] + P[0][19]*SF[6] + P[2][19]*SF[5] + P[3][19]*SF[9] + P[11][19]*SPP[6] - P[12][19]*SPP[7] - (P[10][19]*q0)/2;\n    nextP[1][20] = P[1][20] + P[0][20]*SF[6] + P[2][20]*SF[5] + P[3][20]*SF[9] + P[11][20]*SPP[6] - P[12][20]*SPP[7] - (P[10][20]*q0)/2;\n    nextP[1][21] = P[1][21] + P[0][21]*SF[6] + P[2][21]*SF[5] + P[3][21]*SF[9] + P[11][21]*SPP[6] - P[12][21]*SPP[7] - (P[10][21]*q0)/2;\n    nextP[2][0] = P[2][0] + SQ[7] + P[0][0]*SF[4] + P[1][0]*SF[8] + P[3][0]*SF[6] + P[12][0]*SF[11] - P[10][0]*SPP[6] - (P[11][0]*q0)/2 + SF[7]*(P[2][1] + P[0][1]*SF[4] + P[1][1]*SF[8] + P[3][1]*SF[6] + P[12][1]*SF[11] - P[10][1]*SPP[6] - (P[11][1]*q0)/2) + SF[9]*(P[2][2] + P[0][2]*SF[4] + P[1][2]*SF[8] + P[3][2]*SF[6] + P[12][2]*SF[11] - P[10][2]*SPP[6] - (P[11][2]*q0)/2) + SF[8]*(P[2][3] + P[0][3]*SF[4] + P[1][3]*SF[8] + P[3][3]*SF[6] + P[12][3]*SF[11] - P[10][3]*SPP[6] - (P[11][3]*q0)/2) + SF[11]*(P[2][10] + P[0][10]*SF[4] + P[1][10]*SF[8] + P[3][10]*SF[6] + P[12][10]*SF[11] - P[10][10]*SPP[6] - (P[11][10]*q0)/2) + SPP[7]*(P[2][11] + P[0][11]*SF[4] + P[1][11]*SF[8] + P[3][11]*SF[6] + P[12][11]*SF[11] - P[10][11]*SPP[6] - (P[11][11]*q0)/2) + SPP[6]*(P[2][12] + P[0][12]*SF[4] + P[1][12]*SF[8] + P[3][12]*SF[6] + P[12][12]*SF[11] - P[10][12]*SPP[6] - (P[11][12]*q0)/2);\n    nextP[2][1] = P[2][1] + SQ[5] + P[0][1]*SF[4] + P[1][1]*SF[8] + P[3][1]*SF[6] + P[12][1]*SF[11] - P[10][1]*SPP[6] - (P[11][1]*q0)/2 + SF[6]*(P[2][0] + P[0][0]*SF[4] + P[1][0]*SF[8] + P[3][0]*SF[6] + P[12][0]*SF[11] - P[10][0]*SPP[6] - (P[11][0]*q0)/2) + SF[5]*(P[2][2] + P[0][2]*SF[4] + P[1][2]*SF[8] + P[3][2]*SF[6] + P[12][2]*SF[11] - P[10][2]*SPP[6] - (P[11][2]*q0)/2) + SF[9]*(P[2][3] + P[0][3]*SF[4] + P[1][3]*SF[8] + P[3][3]*SF[6] + P[12][3]*SF[11] - P[10][3]*SPP[6] - (P[11][3]*q0)/2) + SPP[6]*(P[2][11] + P[0][11]*SF[4] + P[1][11]*SF[8] + P[3][11]*SF[6] + P[12][11]*SF[11] - P[10][11]*SPP[6] - (P[11][11]*q0)/2) - SPP[7]*(P[2][12] + P[0][12]*SF[4] + P[1][12]*SF[8] + P[3][12]*SF[6] + P[12][12]*SF[11] - P[10][12]*SPP[6] - (P[11][12]*q0)/2) - (q0*(P[2][10] + P[0][10]*SF[4] + P[1][10]*SF[8] + P[3][10]*SF[6] + P[12][10]*SF[11] - P[10][10]*SPP[6] - (P[11][10]*q0)/2))/2;\n    nextP[2][2] = P[2][2] + P[0][2]*SF[4] + P[1][2]*SF[8] + P[3][2]*SF[6] + P[12][2]*SF[11] - P[10][2]*SPP[6] + dayCov*SQ[9] + (dazCov*SQ[10])/4 - (P[11][2]*q0)/2 + SF[4]*(P[2][0] + P[0][0]*SF[4] + P[1][0]*SF[8] + P[3][0]*SF[6] + P[12][0]*SF[11] - P[10][0]*SPP[6] - (P[11][0]*q0)/2) + SF[8]*(P[2][1] + P[0][1]*SF[4] + P[1][1]*SF[8] + P[3][1]*SF[6] + P[12][1]*SF[11] - P[10][1]*SPP[6] - (P[11][1]*q0)/2) + SF[6]*(P[2][3] + P[0][3]*SF[4] + P[1][3]*SF[8] + P[3][3]*SF[6] + P[12][3]*SF[11] - P[10][3]*SPP[6] - (P[11][3]*q0)/2) + SF[11]*(P[2][12] + P[0][12]*SF[4] + P[1][12]*SF[8] + P[3][12]*SF[6] + P[12][12]*SF[11] - P[10][12]*SPP[6] - (P[11][12]*q0)/2) - SPP[6]*(P[2][10] + P[0][10]*SF[4] + P[1][10]*SF[8] + P[3][10]*SF[6] + P[12][10]*SF[11] - P[10][10]*SPP[6] - (P[11][10]*q0)/2) + (daxCov*sq(q3))/4 - (q0*(P[2][11] + P[0][11]*SF[4] + P[1][11]*SF[8] + P[3][11]*SF[6] + P[12][11]*SF[11] - P[10][11]*SPP[6] - (P[11][11]*q0)/2))/2;\n    nextP[2][3] = P[2][3] + SQ[3] + P[0][3]*SF[4] + P[1][3]*SF[8] + P[3][3]*SF[6] + P[12][3]*SF[11] - P[10][3]*SPP[6] - (P[11][3]*q0)/2 + SF[5]*(P[2][0] + P[0][0]*SF[4] + P[1][0]*SF[8] + P[3][0]*SF[6] + P[12][0]*SF[11] - P[10][0]*SPP[6] - (P[11][0]*q0)/2) + SF[4]*(P[2][1] + P[0][1]*SF[4] + P[1][1]*SF[8] + P[3][1]*SF[6] + P[12][1]*SF[11] - P[10][1]*SPP[6] - (P[11][1]*q0)/2) + SF[7]*(P[2][2] + P[0][2]*SF[4] + P[1][2]*SF[8] + P[3][2]*SF[6] + P[12][2]*SF[11] - P[10][2]*SPP[6] - (P[11][2]*q0)/2) - SF[11]*(P[2][11] + P[0][11]*SF[4] + P[1][11]*SF[8] + P[3][11]*SF[6] + P[12][11]*SF[11] - P[10][11]*SPP[6] - (P[11][11]*q0)/2) + SPP[7]*(P[2][10] + P[0][10]*SF[4] + P[1][10]*SF[8] + P[3][10]*SF[6] + P[12][10]*SF[11] - P[10][10]*SPP[6] - (P[11][10]*q0)/2) - (q0*(P[2][12] + P[0][12]*SF[4] + P[1][12]*SF[8] + P[3][12]*SF[6] + P[12][12]*SF[11] - P[10][12]*SPP[6] - (P[11][12]*q0)/2))/2;\n    nextP[2][4] = P[2][4] + P[0][4]*SF[4] + P[1][4]*SF[8] + P[3][4]*SF[6] + P[12][4]*SF[11] - P[10][4]*SPP[6] - (P[11][4]*q0)/2 + SF[3]*(P[2][0] + P[0][0]*SF[4] + P[1][0]*SF[8] + P[3][0]*SF[6] + P[12][0]*SF[11] - P[10][0]*SPP[6] - (P[11][0]*q0)/2) + SF[1]*(P[2][1] + P[0][1]*SF[4] + P[1][1]*SF[8] + P[3][1]*SF[6] + P[12][1]*SF[11] - P[10][1]*SPP[6] - (P[11][1]*q0)/2) + SPP[0]*(P[2][2] + P[0][2]*SF[4] + P[1][2]*SF[8] + P[3][2]*SF[6] + P[12][2]*SF[11] - P[10][2]*SPP[6] - (P[11][2]*q0)/2) - SPP[2]*(P[2][3] + P[0][3]*SF[4] + P[1][3]*SF[8] + P[3][3]*SF[6] + P[12][3]*SF[11] - P[10][3]*SPP[6] - (P[11][3]*q0)/2) - SPP[4]*(P[2][13] + P[0][13]*SF[4] + P[1][13]*SF[8] + P[3][13]*SF[6] + P[12][13]*SF[11] - P[10][13]*SPP[6] - (P[11][13]*q0)/2);\n    nextP[2][5] = P[2][5] + P[0][5]*SF[4] + P[1][5]*SF[8] + P[3][5]*SF[6] + P[12][5]*SF[11] - P[10][5]*SPP[6] - (P[11][5]*q0)/2 + SF[2]*(P[2][0] + P[0][0]*SF[4] + P[1][0]*SF[8] + P[3][0]*SF[6] + P[12][0]*SF[11] - P[10][0]*SPP[6] - (P[11][0]*q0)/2) + SF[1]*(P[2][2] + P[0][2]*SF[4] + P[1][2]*SF[8] + P[3][2]*SF[6] + P[12][2]*SF[11] - P[10][2]*SPP[6] - (P[11][2]*q0)/2) + SF[3]*(P[2][3] + P[0][3]*SF[4] + P[1][3]*SF[8] + P[3][3]*SF[6] + P[12][3]*SF[11] - P[10][3]*SPP[6] - (P[11][3]*q0)/2) - SPP[0]*(P[2][1] + P[0][1]*SF[4] + P[1][1]*SF[8] + P[3][1]*SF[6] + P[12][1]*SF[11] - P[10][1]*SPP[6] - (P[11][1]*q0)/2) + SPP[3]*(P[2][13] + P[0][13]*SF[4] + P[1][13]*SF[8] + P[3][13]*SF[6] + P[12][13]*SF[11] - P[10][13]*SPP[6] - (P[11][13]*q0)/2);\n    nextP[2][6] = P[2][6] + P[0][6]*SF[4] + P[1][6]*SF[8] + P[3][6]*SF[6] + P[12][6]*SF[11] - P[10][6]*SPP[6] - (P[11][6]*q0)/2 + SF[2]*(P[2][1] + P[0][1]*SF[4] + P[1][1]*SF[8] + P[3][1]*SF[6] + P[12][1]*SF[11] - P[10][1]*SPP[6] - (P[11][1]*q0)/2) + SF[1]*(P[2][3] + P[0][3]*SF[4] + P[1][3]*SF[8] + P[3][3]*SF[6] + P[12][3]*SF[11] - P[10][3]*SPP[6] - (P[11][3]*q0)/2) + SPP[0]*(P[2][0] + P[0][0]*SF[4] + P[1][0]*SF[8] + P[3][0]*SF[6] + P[12][0]*SF[11] - P[10][0]*SPP[6] - (P[11][0]*q0)/2) - SPP[1]*(P[2][2] + P[0][2]*SF[4] + P[1][2]*SF[8] + P[3][2]*SF[6] + P[12][2]*SF[11] - P[10][2]*SPP[6] - (P[11][2]*q0)/2) - (sq(q0) - sq(q1) - sq(q2) + sq(q3))*(P[2][13] + P[0][13]*SF[4] + P[1][13]*SF[8] + P[3][13]*SF[6] + P[12][13]*SF[11] - P[10][13]*SPP[6] - (P[11][13]*q0)/2);\n    nextP[2][7] = P[2][7] + P[0][7]*SF[4] + P[1][7]*SF[8] + P[3][7]*SF[6] + P[12][7]*SF[11] - P[10][7]*SPP[6] - (P[11][7]*q0)/2 + dt*(P[2][4] + P[0][4]*SF[4] + P[1][4]*SF[8] + P[3][4]*SF[6] + P[12][4]*SF[11] - P[10][4]*SPP[6] - (P[11][4]*q0)/2);\n    nextP[2][8] = P[2][8] + P[0][8]*SF[4] + P[1][8]*SF[8] + P[3][8]*SF[6] + P[12][8]*SF[11] - P[10][8]*SPP[6] - (P[11][8]*q0)/2 + dt*(P[2][5] + P[0][5]*SF[4] + P[1][5]*SF[8] + P[3][5]*SF[6] + P[12][5]*SF[11] - P[10][5]*SPP[6] - (P[11][5]*q0)/2);\n    nextP[2][9] = P[2][9] + P[0][9]*SF[4] + P[1][9]*SF[8] + P[3][9]*SF[6] + P[12][9]*SF[11] - P[10][9]*SPP[6] - (P[11][9]*q0)/2 + dt*(P[2][6] + P[0][6]*SF[4] + P[1][6]*SF[8] + P[3][6]*SF[6] + P[12][6]*SF[11] - P[10][6]*SPP[6] - (P[11][6]*q0)/2);\n    nextP[2][10] = P[2][10] + P[0][10]*SF[4] + P[1][10]*SF[8] + P[3][10]*SF[6] + P[12][10]*SF[11] - P[10][10]*SPP[6] - (P[11][10]*q0)/2;\n    nextP[2][11] = P[2][11] + P[0][11]*SF[4] + P[1][11]*SF[8] + P[3][11]*SF[6] + P[12][11]*SF[11] - P[10][11]*SPP[6] - (P[11][11]*q0)/2;\n    nextP[2][12] = P[2][12] + P[0][12]*SF[4] + P[1][12]*SF[8] + P[3][12]*SF[6] + P[12][12]*SF[11] - P[10][12]*SPP[6] - (P[11][12]*q0)/2;\n    nextP[2][13] = P[2][13] + P[0][13]*SF[4] + P[1][13]*SF[8] + P[3][13]*SF[6] + P[12][13]*SF[11] - P[10][13]*SPP[6] - (P[11][13]*q0)/2;\n    nextP[2][14] = P[2][14] + P[0][14]*SF[4] + P[1][14]*SF[8] + P[3][14]*SF[6] + P[12][14]*SF[11] - P[10][14]*SPP[6] - (P[11][14]*q0)/2;\n    nextP[2][15] = P[2][15] + P[0][15]*SF[4] + P[1][15]*SF[8] + P[3][15]*SF[6] + P[12][15]*SF[11] - P[10][15]*SPP[6] - (P[11][15]*q0)/2;\n    nextP[2][16] = P[2][16] + P[0][16]*SF[4] + P[1][16]*SF[8] + P[3][16]*SF[6] + P[12][16]*SF[11] - P[10][16]*SPP[6] - (P[11][16]*q0)/2;\n    nextP[2][17] = P[2][17] + P[0][17]*SF[4] + P[1][17]*SF[8] + P[3][17]*SF[6] + P[12][17]*SF[11] - P[10][17]*SPP[6] - (P[11][17]*q0)/2;\n    nextP[2][18] = P[2][18] + P[0][18]*SF[4] + P[1][18]*SF[8] + P[3][18]*SF[6] + P[12][18]*SF[11] - P[10][18]*SPP[6] - (P[11][18]*q0)/2;\n    nextP[2][19] = P[2][19] + P[0][19]*SF[4] + P[1][19]*SF[8] + P[3][19]*SF[6] + P[12][19]*SF[11] - P[10][19]*SPP[6] - (P[11][19]*q0)/2;\n    nextP[2][20] = P[2][20] + P[0][20]*SF[4] + P[1][20]*SF[8] + P[3][20]*SF[6] + P[12][20]*SF[11] - P[10][20]*SPP[6] - (P[11][20]*q0)/2;\n    nextP[2][21] = P[2][21] + P[0][21]*SF[4] + P[1][21]*SF[8] + P[3][21]*SF[6] + P[12][21]*SF[11] - P[10][21]*SPP[6] - (P[11][21]*q0)/2;\n    nextP[3][0] = P[3][0] + SQ[6] + P[0][0]*SF[5] + P[1][0]*SF[4] + P[2][0]*SF[7] - P[11][0]*SF[11] + P[10][0]*SPP[7] - (P[12][0]*q0)/2 + SF[7]*(P[3][1] + P[0][1]*SF[5] + P[1][1]*SF[4] + P[2][1]*SF[7] - P[11][1]*SF[11] + P[10][1]*SPP[7] - (P[12][1]*q0)/2) + SF[9]*(P[3][2] + P[0][2]*SF[5] + P[1][2]*SF[4] + P[2][2]*SF[7] - P[11][2]*SF[11] + P[10][2]*SPP[7] - (P[12][2]*q0)/2) + SF[8]*(P[3][3] + P[0][3]*SF[5] + P[1][3]*SF[4] + P[2][3]*SF[7] - P[11][3]*SF[11] + P[10][3]*SPP[7] - (P[12][3]*q0)/2) + SF[11]*(P[3][10] + P[0][10]*SF[5] + P[1][10]*SF[4] + P[2][10]*SF[7] - P[11][10]*SF[11] + P[10][10]*SPP[7] - (P[12][10]*q0)/2) + SPP[7]*(P[3][11] + P[0][11]*SF[5] + P[1][11]*SF[4] + P[2][11]*SF[7] - P[11][11]*SF[11] + P[10][11]*SPP[7] - (P[12][11]*q0)/2) + SPP[6]*(P[3][12] + P[0][12]*SF[5] + P[1][12]*SF[4] + P[2][12]*SF[7] - P[11][12]*SF[11] + P[10][12]*SPP[7] - (P[12][12]*q0)/2);\n    nextP[3][1] = P[3][1] + SQ[4] + P[0][1]*SF[5] + P[1][1]*SF[4] + P[2][1]*SF[7] - P[11][1]*SF[11] + P[10][1]*SPP[7] - (P[12][1]*q0)/2 + SF[6]*(P[3][0] + P[0][0]*SF[5] + P[1][0]*SF[4] + P[2][0]*SF[7] - P[11][0]*SF[11] + P[10][0]*SPP[7] - (P[12][0]*q0)/2) + SF[5]*(P[3][2] + P[0][2]*SF[5] + P[1][2]*SF[4] + P[2][2]*SF[7] - P[11][2]*SF[11] + P[10][2]*SPP[7] - (P[12][2]*q0)/2) + SF[9]*(P[3][3] + P[0][3]*SF[5] + P[1][3]*SF[4] + P[2][3]*SF[7] - P[11][3]*SF[11] + P[10][3]*SPP[7] - (P[12][3]*q0)/2) + SPP[6]*(P[3][11] + P[0][11]*SF[5] + P[1][11]*SF[4] + P[2][11]*SF[7] - P[11][11]*SF[11] + P[10][11]*SPP[7] - (P[12][11]*q0)/2) - SPP[7]*(P[3][12] + P[0][12]*SF[5] + P[1][12]*SF[4] + P[2][12]*SF[7] - P[11][12]*SF[11] + P[10][12]*SPP[7] - (P[12][12]*q0)/2) - (q0*(P[3][10] + P[0][10]*SF[5] + P[1][10]*SF[4] + P[2][10]*SF[7] - P[11][10]*SF[11] + P[10][10]*SPP[7] - (P[12][10]*q0)/2))/2;\n    nextP[3][2] = P[3][2] + SQ[3] + P[0][2]*SF[5] + P[1][2]*SF[4] + P[2][2]*SF[7] - P[11][2]*SF[11] + P[10][2]*SPP[7] - (P[12][2]*q0)/2 + SF[4]*(P[3][0] + P[0][0]*SF[5] + P[1][0]*SF[4] + P[2][0]*SF[7] - P[11][0]*SF[11] + P[10][0]*SPP[7] - (P[12][0]*q0)/2) + SF[8]*(P[3][1] + P[0][1]*SF[5] + P[1][1]*SF[4] + P[2][1]*SF[7] - P[11][1]*SF[11] + P[10][1]*SPP[7] - (P[12][1]*q0)/2) + SF[6]*(P[3][3] + P[0][3]*SF[5] + P[1][3]*SF[4] + P[2][3]*SF[7] - P[11][3]*SF[11] + P[10][3]*SPP[7] - (P[12][3]*q0)/2) + SF[11]*(P[3][12] + P[0][12]*SF[5] + P[1][12]*SF[4] + P[2][12]*SF[7] - P[11][12]*SF[11] + P[10][12]*SPP[7] - (P[12][12]*q0)/2) - SPP[6]*(P[3][10] + P[0][10]*SF[5] + P[1][10]*SF[4] + P[2][10]*SF[7] - P[11][10]*SF[11] + P[10][10]*SPP[7] - (P[12][10]*q0)/2) - (q0*(P[3][11] + P[0][11]*SF[5] + P[1][11]*SF[4] + P[2][11]*SF[7] - P[11][11]*SF[11] + P[10][11]*SPP[7] - (P[12][11]*q0)/2))/2;\n    nextP[3][3] = P[3][3] + P[0][3]*SF[5] + P[1][3]*SF[4] + P[2][3]*SF[7] - P[11][3]*SF[11] + P[10][3]*SPP[7] + (dayCov*SQ[10])/4 + dazCov*SQ[9] - (P[12][3]*q0)/2 + SF[5]*(P[3][0] + P[0][0]*SF[5] + P[1][0]*SF[4] + P[2][0]*SF[7] - P[11][0]*SF[11] + P[10][0]*SPP[7] - (P[12][0]*q0)/2) + SF[4]*(P[3][1] + P[0][1]*SF[5] + P[1][1]*SF[4] + P[2][1]*SF[7] - P[11][1]*SF[11] + P[10][1]*SPP[7] - (P[12][1]*q0)/2) + SF[7]*(P[3][2] + P[0][2]*SF[5] + P[1][2]*SF[4] + P[2][2]*SF[7] - P[11][2]*SF[11] + P[10][2]*SPP[7] - (P[12][2]*q0)/2) - SF[11]*(P[3][11] + P[0][11]*SF[5] + P[1][11]*SF[4] + P[2][11]*SF[7] - P[11][11]*SF[11] + P[10][11]*SPP[7] - (P[12][11]*q0)/2) + SPP[7]*(P[3][10] + P[0][10]*SF[5] + P[1][10]*SF[4] + P[2][10]*SF[7] - P[11][10]*SF[11] + P[10][10]*SPP[7] - (P[12][10]*q0)/2) + (daxCov*sq(q2))/4 - (q0*(P[3][12] + P[0][12]*SF[5] + P[1][12]*SF[4] + P[2][12]*SF[7] - P[11][12]*SF[11] + P[10][12]*SPP[7] - (P[12][12]*q0)/2))/2;\n    nextP[3][4] = P[3][4] + P[0][4]*SF[5] + P[1][4]*SF[4] + P[2][4]*SF[7] - P[11][4]*SF[11] + P[10][4]*SPP[7] - (P[12][4]*q0)/2 + SF[3]*(P[3][0] + P[0][0]*SF[5] + P[1][0]*SF[4] + P[2][0]*SF[7] - P[11][0]*SF[11] + P[10][0]*SPP[7] - (P[12][0]*q0)/2) + SF[1]*(P[3][1] + P[0][1]*SF[5] + P[1][1]*SF[4] + P[2][1]*SF[7] - P[11][1]*SF[11] + P[10][1]*SPP[7] - (P[12][1]*q0)/2) + SPP[0]*(P[3][2] + P[0][2]*SF[5] + P[1][2]*SF[4] + P[2][2]*SF[7] - P[11][2]*SF[11] + P[10][2]*SPP[7] - (P[12][2]*q0)/2) - SPP[2]*(P[3][3] + P[0][3]*SF[5] + P[1][3]*SF[4] + P[2][3]*SF[7] - P[11][3]*SF[11] + P[10][3]*SPP[7] - (P[12][3]*q0)/2) - SPP[4]*(P[3][13] + P[0][13]*SF[5] + P[1][13]*SF[4] + P[2][13]*SF[7] - P[11][13]*SF[11] + P[10][13]*SPP[7] - (P[12][13]*q0)/2);\n    nextP[3][5] = P[3][5] + P[0][5]*SF[5] + P[1][5]*SF[4] + P[2][5]*SF[7] - P[11][5]*SF[11] + P[10][5]*SPP[7] - (P[12][5]*q0)/2 + SF[2]*(P[3][0] + P[0][0]*SF[5] + P[1][0]*SF[4] + P[2][0]*SF[7] - P[11][0]*SF[11] + P[10][0]*SPP[7] - (P[12][0]*q0)/2) + SF[1]*(P[3][2] + P[0][2]*SF[5] + P[1][2]*SF[4] + P[2][2]*SF[7] - P[11][2]*SF[11] + P[10][2]*SPP[7] - (P[12][2]*q0)/2) + SF[3]*(P[3][3] + P[0][3]*SF[5] + P[1][3]*SF[4] + P[2][3]*SF[7] - P[11][3]*SF[11] + P[10][3]*SPP[7] - (P[12][3]*q0)/2) - SPP[0]*(P[3][1] + P[0][1]*SF[5] + P[1][1]*SF[4] + P[2][1]*SF[7] - P[11][1]*SF[11] + P[10][1]*SPP[7] - (P[12][1]*q0)/2) + SPP[3]*(P[3][13] + P[0][13]*SF[5] + P[1][13]*SF[4] + P[2][13]*SF[7] - P[11][13]*SF[11] + P[10][13]*SPP[7] - (P[12][13]*q0)/2);\n    nextP[3][6] = P[3][6] + P[0][6]*SF[5] + P[1][6]*SF[4] + P[2][6]*SF[7] - P[11][6]*SF[11] + P[10][6]*SPP[7] - (P[12][6]*q0)/2 + SF[2]*(P[3][1] + P[0][1]*SF[5] + P[1][1]*SF[4] + P[2][1]*SF[7] - P[11][1]*SF[11] + P[10][1]*SPP[7] - (P[12][1]*q0)/2) + SF[1]*(P[3][3] + P[0][3]*SF[5] + P[1][3]*SF[4] + P[2][3]*SF[7] - P[11][3]*SF[11] + P[10][3]*SPP[7] - (P[12][3]*q0)/2) + SPP[0]*(P[3][0] + P[0][0]*SF[5] + P[1][0]*SF[4] + P[2][0]*SF[7] - P[11][0]*SF[11] + P[10][0]*SPP[7] - (P[12][0]*q0)/2) - SPP[1]*(P[3][2] + P[0][2]*SF[5] + P[1][2]*SF[4] + P[2][2]*SF[7] - P[11][2]*SF[11] + P[10][2]*SPP[7] - (P[12][2]*q0)/2) - (sq(q0) - sq(q1) - sq(q2) + sq(q3))*(P[3][13] + P[0][13]*SF[5] + P[1][13]*SF[4] + P[2][13]*SF[7] - P[11][13]*SF[11] + P[10][13]*SPP[7] - (P[12][13]*q0)/2);\n    nextP[3][7] = P[3][7] + P[0][7]*SF[5] + P[1][7]*SF[4] + P[2][7]*SF[7] - P[11][7]*SF[11] + P[10][7]*SPP[7] - (P[12][7]*q0)/2 + dt*(P[3][4] + P[0][4]*SF[5] + P[1][4]*SF[4] + P[2][4]*SF[7] - P[11][4]*SF[11] + P[10][4]*SPP[7] - (P[12][4]*q0)/2);\n    nextP[3][8] = P[3][8] + P[0][8]*SF[5] + P[1][8]*SF[4] + P[2][8]*SF[7] - P[11][8]*SF[11] + P[10][8]*SPP[7] - (P[12][8]*q0)/2 + dt*(P[3][5] + P[0][5]*SF[5] + P[1][5]*SF[4] + P[2][5]*SF[7] - P[11][5]*SF[11] + P[10][5]*SPP[7] - (P[12][5]*q0)/2);\n    nextP[3][9] = P[3][9] + P[0][9]*SF[5] + P[1][9]*SF[4] + P[2][9]*SF[7] - P[11][9]*SF[11] + P[10][9]*SPP[7] - (P[12][9]*q0)/2 + dt*(P[3][6] + P[0][6]*SF[5] + P[1][6]*SF[4] + P[2][6]*SF[7] - P[11][6]*SF[11] + P[10][6]*SPP[7] - (P[12][6]*q0)/2);\n    nextP[3][10] = P[3][10] + P[0][10]*SF[5] + P[1][10]*SF[4] + P[2][10]*SF[7] - P[11][10]*SF[11] + P[10][10]*SPP[7] - (P[12][10]*q0)/2;\n    nextP[3][11] = P[3][11] + P[0][11]*SF[5] + P[1][11]*SF[4] + P[2][11]*SF[7] - P[11][11]*SF[11] + P[10][11]*SPP[7] - (P[12][11]*q0)/2;\n    nextP[3][12] = P[3][12] + P[0][12]*SF[5] + P[1][12]*SF[4] + P[2][12]*SF[7] - P[11][12]*SF[11] + P[10][12]*SPP[7] - (P[12][12]*q0)/2;\n    nextP[3][13] = P[3][13] + P[0][13]*SF[5] + P[1][13]*SF[4] + P[2][13]*SF[7] - P[11][13]*SF[11] + P[10][13]*SPP[7] - (P[12][13]*q0)/2;\n    nextP[3][14] = P[3][14] + P[0][14]*SF[5] + P[1][14]*SF[4] + P[2][14]*SF[7] - P[11][14]*SF[11] + P[10][14]*SPP[7] - (P[12][14]*q0)/2;\n    nextP[3][15] = P[3][15] + P[0][15]*SF[5] + P[1][15]*SF[4] + P[2][15]*SF[7] - P[11][15]*SF[11] + P[10][15]*SPP[7] - (P[12][15]*q0)/2;\n    nextP[3][16] = P[3][16] + P[0][16]*SF[5] + P[1][16]*SF[4] + P[2][16]*SF[7] - P[11][16]*SF[11] + P[10][16]*SPP[7] - (P[12][16]*q0)/2;\n    nextP[3][17] = P[3][17] + P[0][17]*SF[5] + P[1][17]*SF[4] + P[2][17]*SF[7] - P[11][17]*SF[11] + P[10][17]*SPP[7] - (P[12][17]*q0)/2;\n    nextP[3][18] = P[3][18] + P[0][18]*SF[5] + P[1][18]*SF[4] + P[2][18]*SF[7] - P[11][18]*SF[11] + P[10][18]*SPP[7] - (P[12][18]*q0)/2;\n    nextP[3][19] = P[3][19] + P[0][19]*SF[5] + P[1][19]*SF[4] + P[2][19]*SF[7] - P[11][19]*SF[11] + P[10][19]*SPP[7] - (P[12][19]*q0)/2;\n    nextP[3][20] = P[3][20] + P[0][20]*SF[5] + P[1][20]*SF[4] + P[2][20]*SF[7] - P[11][20]*SF[11] + P[10][20]*SPP[7] - (P[12][20]*q0)/2;\n    nextP[3][21] = P[3][21] + P[0][21]*SF[5] + P[1][21]*SF[4] + P[2][21]*SF[7] - P[11][21]*SF[11] + P[10][21]*SPP[7] - (P[12][21]*q0)/2;\n    nextP[4][0] = P[4][0] + P[0][0]*SF[3] + P[1][0]*SF[1] + P[2][0]*SPP[0] - P[3][0]*SPP[2] - P[13][0]*SPP[4] + SF[7]*(P[4][1] + P[0][1]*SF[3] + P[1][1]*SF[1] + P[2][1]*SPP[0] - P[3][1]*SPP[2] - P[13][1]*SPP[4]) + SF[9]*(P[4][2] + P[0][2]*SF[3] + P[1][2]*SF[1] + P[2][2]*SPP[0] - P[3][2]*SPP[2] - P[13][2]*SPP[4]) + SF[8]*(P[4][3] + P[0][3]*SF[3] + P[1][3]*SF[1] + P[2][3]*SPP[0] - P[3][3]*SPP[2] - P[13][3]*SPP[4]) + SF[11]*(P[4][10] + P[0][10]*SF[3] + P[1][10]*SF[1] + P[2][10]*SPP[0] - P[3][10]*SPP[2] - P[13][10]*SPP[4]) + SPP[7]*(P[4][11] + P[0][11]*SF[3] + P[1][11]*SF[1] + P[2][11]*SPP[0] - P[3][11]*SPP[2] - P[13][11]*SPP[4]) + SPP[6]*(P[4][12] + P[0][12]*SF[3] + P[1][12]*SF[1] + P[2][12]*SPP[0] - P[3][12]*SPP[2] - P[13][12]*SPP[4]);\n    nextP[4][1] = P[4][1] + P[0][1]*SF[3] + P[1][1]*SF[1] + P[2][1]*SPP[0] - P[3][1]*SPP[2] - P[13][1]*SPP[4] + SF[6]*(P[4][0] + P[0][0]*SF[3] + P[1][0]*SF[1] + P[2][0]*SPP[0] - P[3][0]*SPP[2] - P[13][0]*SPP[4]) + SF[5]*(P[4][2] + P[0][2]*SF[3] + P[1][2]*SF[1] + P[2][2]*SPP[0] - P[3][2]*SPP[2] - P[13][2]*SPP[4]) + SF[9]*(P[4][3] + P[0][3]*SF[3] + P[1][3]*SF[1] + P[2][3]*SPP[0] - P[3][3]*SPP[2] - P[13][3]*SPP[4]) + SPP[6]*(P[4][11] + P[0][11]*SF[3] + P[1][11]*SF[1] + P[2][11]*SPP[0] - P[3][11]*SPP[2] - P[13][11]*SPP[4]) - SPP[7]*(P[4][12] + P[0][12]*SF[3] + P[1][12]*SF[1] + P[2][12]*SPP[0] - P[3][12]*SPP[2] - P[13][12]*SPP[4]) - (q0*(P[4][10] + P[0][10]*SF[3] + P[1][10]*SF[1] + P[2][10]*SPP[0] - P[3][10]*SPP[2] - P[13][10]*SPP[4]))/2;\n    nextP[4][2] = P[4][2] + P[0][2]*SF[3] + P[1][2]*SF[1] + P[2][2]*SPP[0] - P[3][2]*SPP[2] - P[13][2]*SPP[4] + SF[4]*(P[4][0] + P[0][0]*SF[3] + P[1][0]*SF[1] + P[2][0]*SPP[0] - P[3][0]*SPP[2] - P[13][0]*SPP[4]) + SF[8]*(P[4][1] + P[0][1]*SF[3] + P[1][1]*SF[1] + P[2][1]*SPP[0] - P[3][1]*SPP[2] - P[13][1]*SPP[4]) + SF[6]*(P[4][3] + P[0][3]*SF[3] + P[1][3]*SF[1] + P[2][3]*SPP[0] - P[3][3]*SPP[2] - P[13][3]*SPP[4]) + SF[11]*(P[4][12] + P[0][12]*SF[3] + P[1][12]*SF[1] + P[2][12]*SPP[0] - P[3][12]*SPP[2] - P[13][12]*SPP[4]) - SPP[6]*(P[4][10] + P[0][10]*SF[3] + P[1][10]*SF[1] + P[2][10]*SPP[0] - P[3][10]*SPP[2] - P[13][10]*SPP[4]) - (q0*(P[4][11] + P[0][11]*SF[3] + P[1][11]*SF[1] + P[2][11]*SPP[0] - P[3][11]*SPP[2] - P[13][11]*SPP[4]))/2;\n    nextP[4][3] = P[4][3] + P[0][3]*SF[3] + P[1][3]*SF[1] + P[2][3]*SPP[0] - P[3][3]*SPP[2] - P[13][3]*SPP[4] + SF[5]*(P[4][0] + P[0][0]*SF[3] + P[1][0]*SF[1] + P[2][0]*SPP[0] - P[3][0]*SPP[2] - P[13][0]*SPP[4]) + SF[4]*(P[4][1] + P[0][1]*SF[3] + P[1][1]*SF[1] + P[2][1]*SPP[0] - P[3][1]*SPP[2] - P[13][1]*SPP[4]) + SF[7]*(P[4][2] + P[0][2]*SF[3] + P[1][2]*SF[1] + P[2][2]*SPP[0] - P[3][2]*SPP[2] - P[13][2]*SPP[4]) - SF[11]*(P[4][11] + P[0][11]*SF[3] + P[1][11]*SF[1] + P[2][11]*SPP[0] - P[3][11]*SPP[2] - P[13][11]*SPP[4]) + SPP[7]*(P[4][10] + P[0][10]*SF[3] + P[1][10]*SF[1] + P[2][10]*SPP[0] - P[3][10]*SPP[2] - P[13][10]*SPP[4]) - (q0*(P[4][12] + P[0][12]*SF[3] + P[1][12]*SF[1] + P[2][12]*SPP[0] - P[3][12]*SPP[2] - P[13][12]*SPP[4]))/2;\n    nextP[4][4] = P[4][4] + P[0][4]*SF[3] + P[1][4]*SF[1] + P[2][4]*SPP[0] - P[3][4]*SPP[2] - P[13][4]*SPP[4] + dvyCov*sq(SG[7] - 2*q0*q3) + dvzCov*sq(SG[6] + 2*q0*q2) + SF[3]*(P[4][0] + P[0][0]*SF[3] + P[1][0]*SF[1] + P[2][0]*SPP[0] - P[3][0]*SPP[2] - P[13][0]*SPP[4]) + SF[1]*(P[4][1] + P[0][1]*SF[3] + P[1][1]*SF[1] + P[2][1]*SPP[0] - P[3][1]*SPP[2] - P[13][1]*SPP[4]) + SPP[0]*(P[4][2] + P[0][2]*SF[3] + P[1][2]*SF[1] + P[2][2]*SPP[0] - P[3][2]*SPP[2] - P[13][2]*SPP[4]) - SPP[2]*(P[4][3] + P[0][3]*SF[3] + P[1][3]*SF[1] + P[2][3]*SPP[0] - P[3][3]*SPP[2] - P[13][3]*SPP[4]) - SPP[4]*(P[4][13] + P[0][13]*SF[3] + P[1][13]*SF[1] + P[2][13]*SPP[0] - P[3][13]*SPP[2] - P[13][13]*SPP[4]) + dvxCov*sq(SG[1] + SG[2] - SG[3] - SG[4]);\n    nextP[4][5] = P[4][5] + SQ[2] + P[0][5]*SF[3] + P[1][5]*SF[1] + P[2][5]*SPP[0] - P[3][5]*SPP[2] - P[13][5]*SPP[4] + SF[2]*(P[4][0] + P[0][0]*SF[3] + P[1][0]*SF[1] + P[2][0]*SPP[0] - P[3][0]*SPP[2] - P[13][0]*SPP[4]) + SF[1]*(P[4][2] + P[0][2]*SF[3] + P[1][2]*SF[1] + P[2][2]*SPP[0] - P[3][2]*SPP[2] - P[13][2]*SPP[4]) + SF[3]*(P[4][3] + P[0][3]*SF[3] + P[1][3]*SF[1] + P[2][3]*SPP[0] - P[3][3]*SPP[2] - P[13][3]*SPP[4]) - SPP[0]*(P[4][1] + P[0][1]*SF[3] + P[1][1]*SF[1] + P[2][1]*SPP[0] - P[3][1]*SPP[2] - P[13][1]*SPP[4]) + SPP[3]*(P[4][13] + P[0][13]*SF[3] + P[1][13]*SF[1] + P[2][13]*SPP[0] - P[3][13]*SPP[2] - P[13][13]*SPP[4]);\n    nextP[4][6] = P[4][6] + SQ[1] + P[0][6]*SF[3] + P[1][6]*SF[1] + P[2][6]*SPP[0] - P[3][6]*SPP[2] - P[13][6]*SPP[4] + SF[2]*(P[4][1] + P[0][1]*SF[3] + P[1][1]*SF[1] + P[2][1]*SPP[0] - P[3][1]*SPP[2] - P[13][1]*SPP[4]) + SF[1]*(P[4][3] + P[0][3]*SF[3] + P[1][3]*SF[1] + P[2][3]*SPP[0] - P[3][3]*SPP[2] - P[13][3]*SPP[4]) + SPP[0]*(P[4][0] + P[0][0]*SF[3] + P[1][0]*SF[1] + P[2][0]*SPP[0] - P[3][0]*SPP[2] - P[13][0]*SPP[4]) - SPP[1]*(P[4][2] + P[0][2]*SF[3] + P[1][2]*SF[1] + P[2][2]*SPP[0] - P[3][2]*SPP[2] - P[13][2]*SPP[4]) - (sq(q0) - sq(q1) - sq(q2) + sq(q3))*(P[4][13] + P[0][13]*SF[3] + P[1][13]*SF[1] + P[2][13]*SPP[0] - P[3][13]*SPP[2] - P[13][13]*SPP[4]);\n    nextP[4][7] = P[4][7] + P[0][7]*SF[3] + P[1][7]*SF[1] + P[2][7]*SPP[0] - P[3][7]*SPP[2] - P[13][7]*SPP[4] + dt*(P[4][4] + P[0][4]*SF[3] + P[1][4]*SF[1] + P[2][4]*SPP[0] - P[3][4]*SPP[2] - P[13][4]*SPP[4]);\n    nextP[4][8] = P[4][8] + P[0][8]*SF[3] + P[1][8]*SF[1] + P[2][8]*SPP[0] - P[3][8]*SPP[2] - P[13][8]*SPP[4] + dt*(P[4][5] + P[0][5]*SF[3] + P[1][5]*SF[1] + P[2][5]*SPP[0] - P[3][5]*SPP[2] - P[13][5]*SPP[4]);\n    nextP[4][9] = P[4][9] + P[0][9]*SF[3] + P[1][9]*SF[1] + P[2][9]*SPP[0] - P[3][9]*SPP[2] - P[13][9]*SPP[4] + dt*(P[4][6] + P[0][6]*SF[3] + P[1][6]*SF[1] + P[2][6]*SPP[0] - P[3][6]*SPP[2] - P[13][6]*SPP[4]);\n    nextP[4][10] = P[4][10] + P[0][10]*SF[3] + P[1][10]*SF[1] + P[2][10]*SPP[0] - P[3][10]*SPP[2] - P[13][10]*SPP[4];\n    nextP[4][11] = P[4][11] + P[0][11]*SF[3] + P[1][11]*SF[1] + P[2][11]*SPP[0] - P[3][11]*SPP[2] - P[13][11]*SPP[4];\n    nextP[4][12] = P[4][12] + P[0][12]*SF[3] + P[1][12]*SF[1] + P[2][12]*SPP[0] - P[3][12]*SPP[2] - P[13][12]*SPP[4];\n    nextP[4][13] = P[4][13] + P[0][13]*SF[3] + P[1][13]*SF[1] + P[2][13]*SPP[0] - P[3][13]*SPP[2] - P[13][13]*SPP[4];\n    nextP[4][14] = P[4][14] + P[0][14]*SF[3] + P[1][14]*SF[1] + P[2][14]*SPP[0] - P[3][14]*SPP[2] - P[13][14]*SPP[4];\n    nextP[4][15] = P[4][15] + P[0][15]*SF[3] + P[1][15]*SF[1] + P[2][15]*SPP[0] - P[3][15]*SPP[2] - P[13][15]*SPP[4];\n    nextP[4][16] = P[4][16] + P[0][16]*SF[3] + P[1][16]*SF[1] + P[2][16]*SPP[0] - P[3][16]*SPP[2] - P[13][16]*SPP[4];\n    nextP[4][17] = P[4][17] + P[0][17]*SF[3] + P[1][17]*SF[1] + P[2][17]*SPP[0] - P[3][17]*SPP[2] - P[13][17]*SPP[4];\n    nextP[4][18] = P[4][18] + P[0][18]*SF[3] + P[1][18]*SF[1] + P[2][18]*SPP[0] - P[3][18]*SPP[2] - P[13][18]*SPP[4];\n    nextP[4][19] = P[4][19] + P[0][19]*SF[3] + P[1][19]*SF[1] + P[2][19]*SPP[0] - P[3][19]*SPP[2] - P[13][19]*SPP[4];\n    nextP[4][20] = P[4][20] + P[0][20]*SF[3] + P[1][20]*SF[1] + P[2][20]*SPP[0] - P[3][20]*SPP[2] - P[13][20]*SPP[4];\n    nextP[4][21] = P[4][21] + P[0][21]*SF[3] + P[1][21]*SF[1] + P[2][21]*SPP[0] - P[3][21]*SPP[2] - P[13][21]*SPP[4];\n    nextP[5][0] = P[5][0] + P[0][0]*SF[2] + P[2][0]*SF[1] + P[3][0]*SF[3] - P[1][0]*SPP[0] + P[13][0]*SPP[3] + SF[7]*(P[5][1] + P[0][1]*SF[2] + P[2][1]*SF[1] + P[3][1]*SF[3] - P[1][1]*SPP[0] + P[13][1]*SPP[3]) + SF[9]*(P[5][2] + P[0][2]*SF[2] + P[2][2]*SF[1] + P[3][2]*SF[3] - P[1][2]*SPP[0] + P[13][2]*SPP[3]) + SF[8]*(P[5][3] + P[0][3]*SF[2] + P[2][3]*SF[1] + P[3][3]*SF[3] - P[1][3]*SPP[0] + P[13][3]*SPP[3]) + SF[11]*(P[5][10] + P[0][10]*SF[2] + P[2][10]*SF[1] + P[3][10]*SF[3] - P[1][10]*SPP[0] + P[13][10]*SPP[3]) + SPP[7]*(P[5][11] + P[0][11]*SF[2] + P[2][11]*SF[1] + P[3][11]*SF[3] - P[1][11]*SPP[0] + P[13][11]*SPP[3]) + SPP[6]*(P[5][12] + P[0][12]*SF[2] + P[2][12]*SF[1] + P[3][12]*SF[3] - P[1][12]*SPP[0] + P[13][12]*SPP[3]);\n    nextP[5][1] = P[5][1] + P[0][1]*SF[2] + P[2][1]*SF[1] + P[3][1]*SF[3] - P[1][1]*SPP[0] + P[13][1]*SPP[3] + SF[6]*(P[5][0] + P[0][0]*SF[2] + P[2][0]*SF[1] + P[3][0]*SF[3] - P[1][0]*SPP[0] + P[13][0]*SPP[3]) + SF[5]*(P[5][2] + P[0][2]*SF[2] + P[2][2]*SF[1] + P[3][2]*SF[3] - P[1][2]*SPP[0] + P[13][2]*SPP[3]) + SF[9]*(P[5][3] + P[0][3]*SF[2] + P[2][3]*SF[1] + P[3][3]*SF[3] - P[1][3]*SPP[0] + P[13][3]*SPP[3]) + SPP[6]*(P[5][11] + P[0][11]*SF[2] + P[2][11]*SF[1] + P[3][11]*SF[3] - P[1][11]*SPP[0] + P[13][11]*SPP[3]) - SPP[7]*(P[5][12] + P[0][12]*SF[2] + P[2][12]*SF[1] + P[3][12]*SF[3] - P[1][12]*SPP[0] + P[13][12]*SPP[3]) - (q0*(P[5][10] + P[0][10]*SF[2] + P[2][10]*SF[1] + P[3][10]*SF[3] - P[1][10]*SPP[0] + P[13][10]*SPP[3]))/2;\n    nextP[5][2] = P[5][2] + P[0][2]*SF[2] + P[2][2]*SF[1] + P[3][2]*SF[3] - P[1][2]*SPP[0] + P[13][2]*SPP[3] + SF[4]*(P[5][0] + P[0][0]*SF[2] + P[2][0]*SF[1] + P[3][0]*SF[3] - P[1][0]*SPP[0] + P[13][0]*SPP[3]) + SF[8]*(P[5][1] + P[0][1]*SF[2] + P[2][1]*SF[1] + P[3][1]*SF[3] - P[1][1]*SPP[0] + P[13][1]*SPP[3]) + SF[6]*(P[5][3] + P[0][3]*SF[2] + P[2][3]*SF[1] + P[3][3]*SF[3] - P[1][3]*SPP[0] + P[13][3]*SPP[3]) + SF[11]*(P[5][12] + P[0][12]*SF[2] + P[2][12]*SF[1] + P[3][12]*SF[3] - P[1][12]*SPP[0] + P[13][12]*SPP[3]) - SPP[6]*(P[5][10] + P[0][10]*SF[2] + P[2][10]*SF[1] + P[3][10]*SF[3] - P[1][10]*SPP[0] + P[13][10]*SPP[3]) - (q0*(P[5][11] + P[0][11]*SF[2] + P[2][11]*SF[1] + P[3][11]*SF[3] - P[1][11]*SPP[0] + P[13][11]*SPP[3]))/2;\n    nextP[5][3] = P[5][3] + P[0][3]*SF[2] + P[2][3]*SF[1] + P[3][3]*SF[3] - P[1][3]*SPP[0] + P[13][3]*SPP[3] + SF[5]*(P[5][0] + P[0][0]*SF[2] + P[2][0]*SF[1] + P[3][0]*SF[3] - P[1][0]*SPP[0] + P[13][0]*SPP[3]) + SF[4]*(P[5][1] + P[0][1]*SF[2] + P[2][1]*SF[1] + P[3][1]*SF[3] - P[1][1]*SPP[0] + P[13][1]*SPP[3]) + SF[7]*(P[5][2] + P[0][2]*SF[2] + P[2][2]*SF[1] + P[3][2]*SF[3] - P[1][2]*SPP[0] + P[13][2]*SPP[3]) - SF[11]*(P[5][11] + P[0][11]*SF[2] + P[2][11]*SF[1] + P[3][11]*SF[3] - P[1][11]*SPP[0] + P[13][11]*SPP[3]) + SPP[7]*(P[5][10] + P[0][10]*SF[2] + P[2][10]*SF[1] + P[3][10]*SF[3] - P[1][10]*SPP[0] + P[13][10]*SPP[3]) - (q0*(P[5][12] + P[0][12]*SF[2] + P[2][12]*SF[1] + P[3][12]*SF[3] - P[1][12]*SPP[0] + P[13][12]*SPP[3]))/2;\n    nextP[5][4] = P[5][4] + SQ[2] + P[0][4]*SF[2] + P[2][4]*SF[1] + P[3][4]*SF[3] - P[1][4]*SPP[0] + P[13][4]*SPP[3] + SF[3]*(P[5][0] + P[0][0]*SF[2] + P[2][0]*SF[1] + P[3][0]*SF[3] - P[1][0]*SPP[0] + P[13][0]*SPP[3]) + SF[1]*(P[5][1] + P[0][1]*SF[2] + P[2][1]*SF[1] + P[3][1]*SF[3] - P[1][1]*SPP[0] + P[13][1]*SPP[3]) + SPP[0]*(P[5][2] + P[0][2]*SF[2] + P[2][2]*SF[1] + P[3][2]*SF[3] - P[1][2]*SPP[0] + P[13][2]*SPP[3]) - SPP[2]*(P[5][3] + P[0][3]*SF[2] + P[2][3]*SF[1] + P[3][3]*SF[3] - P[1][3]*SPP[0] + P[13][3]*SPP[3]) - SPP[4]*(P[5][13] + P[0][13]*SF[2] + P[2][13]*SF[1] + P[3][13]*SF[3] - P[1][13]*SPP[0] + P[13][13]*SPP[3]);\n    nextP[5][5] = P[5][5] + P[0][5]*SF[2] + P[2][5]*SF[1] + P[3][5]*SF[3] - P[1][5]*SPP[0] + P[13][5]*SPP[3] + dvxCov*sq(SG[7] + 2*q0*q3) + dvzCov*sq(SG[5] - 2*q0*q1) + SF[2]*(P[5][0] + P[0][0]*SF[2] + P[2][0]*SF[1] + P[3][0]*SF[3] - P[1][0]*SPP[0] + P[13][0]*SPP[3]) + SF[1]*(P[5][2] + P[0][2]*SF[2] + P[2][2]*SF[1] + P[3][2]*SF[3] - P[1][2]*SPP[0] + P[13][2]*SPP[3]) + SF[3]*(P[5][3] + P[0][3]*SF[2] + P[2][3]*SF[1] + P[3][3]*SF[3] - P[1][3]*SPP[0] + P[13][3]*SPP[3]) - SPP[0]*(P[5][1] + P[0][1]*SF[2] + P[2][1]*SF[1] + P[3][1]*SF[3] - P[1][1]*SPP[0] + P[13][1]*SPP[3]) + SPP[3]*(P[5][13] + P[0][13]*SF[2] + P[2][13]*SF[1] + P[3][13]*SF[3] - P[1][13]*SPP[0] + P[13][13]*SPP[3]) + dvyCov*sq(SG[1] - SG[2] + SG[3] - SG[4]);\n    nextP[5][6] = P[5][6] + SQ[0] + P[0][6]*SF[2] + P[2][6]*SF[1] + P[3][6]*SF[3] - P[1][6]*SPP[0] + P[13][6]*SPP[3] + SF[2]*(P[5][1] + P[0][1]*SF[2] + P[2][1]*SF[1] + P[3][1]*SF[3] - P[1][1]*SPP[0] + P[13][1]*SPP[3]) + SF[1]*(P[5][3] + P[0][3]*SF[2] + P[2][3]*SF[1] + P[3][3]*SF[3] - P[1][3]*SPP[0] + P[13][3]*SPP[3]) + SPP[0]*(P[5][0] + P[0][0]*SF[2] + P[2][0]*SF[1] + P[3][0]*SF[3] - P[1][0]*SPP[0] + P[13][0]*SPP[3]) - SPP[1]*(P[5][2] + P[0][2]*SF[2] + P[2][2]*SF[1] + P[3][2]*SF[3] - P[1][2]*SPP[0] + P[13][2]*SPP[3]) - (sq(q0) - sq(q1) - sq(q2) + sq(q3))*(P[5][13] + P[0][13]*SF[2] + P[2][13]*SF[1] + P[3][13]*SF[3] - P[1][13]*SPP[0] + P[13][13]*SPP[3]);\n    nextP[5][7] = P[5][7] + P[0][7]*SF[2] + P[2][7]*SF[1] + P[3][7]*SF[3] - P[1][7]*SPP[0] + P[13][7]*SPP[3] + dt*(P[5][4] + P[0][4]*SF[2] + P[2][4]*SF[1] + P[3][4]*SF[3] - P[1][4]*SPP[0] + P[13][4]*SPP[3]);\n    nextP[5][8] = P[5][8] + P[0][8]*SF[2] + P[2][8]*SF[1] + P[3][8]*SF[3] - P[1][8]*SPP[0] + P[13][8]*SPP[3] + dt*(P[5][5] + P[0][5]*SF[2] + P[2][5]*SF[1] + P[3][5]*SF[3] - P[1][5]*SPP[0] + P[13][5]*SPP[3]);\n    nextP[5][9] = P[5][9] + P[0][9]*SF[2] + P[2][9]*SF[1] + P[3][9]*SF[3] - P[1][9]*SPP[0] + P[13][9]*SPP[3] + dt*(P[5][6] + P[0][6]*SF[2] + P[2][6]*SF[1] + P[3][6]*SF[3] - P[1][6]*SPP[0] + P[13][6]*SPP[3]);\n    nextP[5][10] = P[5][10] + P[0][10]*SF[2] + P[2][10]*SF[1] + P[3][10]*SF[3] - P[1][10]*SPP[0] + P[13][10]*SPP[3];\n    nextP[5][11] = P[5][11] + P[0][11]*SF[2] + P[2][11]*SF[1] + P[3][11]*SF[3] - P[1][11]*SPP[0] + P[13][11]*SPP[3];\n    nextP[5][12] = P[5][12] + P[0][12]*SF[2] + P[2][12]*SF[1] + P[3][12]*SF[3] - P[1][12]*SPP[0] + P[13][12]*SPP[3];\n    nextP[5][13] = P[5][13] + P[0][13]*SF[2] + P[2][13]*SF[1] + P[3][13]*SF[3] - P[1][13]*SPP[0] + P[13][13]*SPP[3];\n    nextP[5][14] = P[5][14] + P[0][14]*SF[2] + P[2][14]*SF[1] + P[3][14]*SF[3] - P[1][14]*SPP[0] + P[13][14]*SPP[3];\n    nextP[5][15] = P[5][15] + P[0][15]*SF[2] + P[2][15]*SF[1] + P[3][15]*SF[3] - P[1][15]*SPP[0] + P[13][15]*SPP[3];\n    nextP[5][16] = P[5][16] + P[0][16]*SF[2] + P[2][16]*SF[1] + P[3][16]*SF[3] - P[1][16]*SPP[0] + P[13][16]*SPP[3];\n    nextP[5][17] = P[5][17] + P[0][17]*SF[2] + P[2][17]*SF[1] + P[3][17]*SF[3] - P[1][17]*SPP[0] + P[13][17]*SPP[3];\n    nextP[5][18] = P[5][18] + P[0][18]*SF[2] + P[2][18]*SF[1] + P[3][18]*SF[3] - P[1][18]*SPP[0] + P[13][18]*SPP[3];\n    nextP[5][19] = P[5][19] + P[0][19]*SF[2] + P[2][19]*SF[1] + P[3][19]*SF[3] - P[1][19]*SPP[0] + P[13][19]*SPP[3];\n    nextP[5][20] = P[5][20] + P[0][20]*SF[2] + P[2][20]*SF[1] + P[3][20]*SF[3] - P[1][20]*SPP[0] + P[13][20]*SPP[3];\n    nextP[5][21] = P[5][21] + P[0][21]*SF[2] + P[2][21]*SF[1] + P[3][21]*SF[3] - P[1][21]*SPP[0] + P[13][21]*SPP[3];\n    nextP[6][0] = P[6][0] + P[1][0]*SF[2] + P[3][0]*SF[1] + P[0][0]*SPP[0] - P[2][0]*SPP[1] - P[13][0]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)) + SF[7]*(P[6][1] + P[1][1]*SF[2] + P[3][1]*SF[1] + P[0][1]*SPP[0] - P[2][1]*SPP[1] - P[13][1]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[9]*(P[6][2] + P[1][2]*SF[2] + P[3][2]*SF[1] + P[0][2]*SPP[0] - P[2][2]*SPP[1] - P[13][2]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[8]*(P[6][3] + P[1][3]*SF[2] + P[3][3]*SF[1] + P[0][3]*SPP[0] - P[2][3]*SPP[1] - P[13][3]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[11]*(P[6][10] + P[1][10]*SF[2] + P[3][10]*SF[1] + P[0][10]*SPP[0] - P[2][10]*SPP[1] - P[13][10]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SPP[7]*(P[6][11] + P[1][11]*SF[2] + P[3][11]*SF[1] + P[0][11]*SPP[0] - P[2][11]*SPP[1] - P[13][11]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SPP[6]*(P[6][12] + P[1][12]*SF[2] + P[3][12]*SF[1] + P[0][12]*SPP[0] - P[2][12]*SPP[1] - P[13][12]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)));\n    nextP[6][1] = P[6][1] + P[1][1]*SF[2] + P[3][1]*SF[1] + P[0][1]*SPP[0] - P[2][1]*SPP[1] - P[13][1]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)) + SF[6]*(P[6][0] + P[1][0]*SF[2] + P[3][0]*SF[1] + P[0][0]*SPP[0] - P[2][0]*SPP[1] - P[13][0]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[5]*(P[6][2] + P[1][2]*SF[2] + P[3][2]*SF[1] + P[0][2]*SPP[0] - P[2][2]*SPP[1] - P[13][2]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[9]*(P[6][3] + P[1][3]*SF[2] + P[3][3]*SF[1] + P[0][3]*SPP[0] - P[2][3]*SPP[1] - P[13][3]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SPP[6]*(P[6][11] + P[1][11]*SF[2] + P[3][11]*SF[1] + P[0][11]*SPP[0] - P[2][11]*SPP[1] - P[13][11]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - SPP[7]*(P[6][12] + P[1][12]*SF[2] + P[3][12]*SF[1] + P[0][12]*SPP[0] - P[2][12]*SPP[1] - P[13][12]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - (q0*(P[6][10] + P[1][10]*SF[2] + P[3][10]*SF[1] + P[0][10]*SPP[0] - P[2][10]*SPP[1] - P[13][10]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))))/2;\n    nextP[6][2] = P[6][2] + P[1][2]*SF[2] + P[3][2]*SF[1] + P[0][2]*SPP[0] - P[2][2]*SPP[1] - P[13][2]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)) + SF[4]*(P[6][0] + P[1][0]*SF[2] + P[3][0]*SF[1] + P[0][0]*SPP[0] - P[2][0]*SPP[1] - P[13][0]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[8]*(P[6][1] + P[1][1]*SF[2] + P[3][1]*SF[1] + P[0][1]*SPP[0] - P[2][1]*SPP[1] - P[13][1]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[6]*(P[6][3] + P[1][3]*SF[2] + P[3][3]*SF[1] + P[0][3]*SPP[0] - P[2][3]*SPP[1] - P[13][3]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[11]*(P[6][12] + P[1][12]*SF[2] + P[3][12]*SF[1] + P[0][12]*SPP[0] - P[2][12]*SPP[1] - P[13][12]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - SPP[6]*(P[6][10] + P[1][10]*SF[2] + P[3][10]*SF[1] + P[0][10]*SPP[0] - P[2][10]*SPP[1] - P[13][10]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - (q0*(P[6][11] + P[1][11]*SF[2] + P[3][11]*SF[1] + P[0][11]*SPP[0] - P[2][11]*SPP[1] - P[13][11]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))))/2;\n    nextP[6][3] = P[6][3] + P[1][3]*SF[2] + P[3][3]*SF[1] + P[0][3]*SPP[0] - P[2][3]*SPP[1] - P[13][3]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)) + SF[5]*(P[6][0] + P[1][0]*SF[2] + P[3][0]*SF[1] + P[0][0]*SPP[0] - P[2][0]*SPP[1] - P[13][0]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[4]*(P[6][1] + P[1][1]*SF[2] + P[3][1]*SF[1] + P[0][1]*SPP[0] - P[2][1]*SPP[1] - P[13][1]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[7]*(P[6][2] + P[1][2]*SF[2] + P[3][2]*SF[1] + P[0][2]*SPP[0] - P[2][2]*SPP[1] - P[13][2]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - SF[11]*(P[6][11] + P[1][11]*SF[2] + P[3][11]*SF[1] + P[0][11]*SPP[0] - P[2][11]*SPP[1] - P[13][11]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SPP[7]*(P[6][10] + P[1][10]*SF[2] + P[3][10]*SF[1] + P[0][10]*SPP[0] - P[2][10]*SPP[1] - P[13][10]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - (q0*(P[6][12] + P[1][12]*SF[2] + P[3][12]*SF[1] + P[0][12]*SPP[0] - P[2][12]*SPP[1] - P[13][12]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))))/2;\n    nextP[6][4] = P[6][4] + SQ[1] + P[1][4]*SF[2] + P[3][4]*SF[1] + P[0][4]*SPP[0] - P[2][4]*SPP[1] - P[13][4]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)) + SF[3]*(P[6][0] + P[1][0]*SF[2] + P[3][0]*SF[1] + P[0][0]*SPP[0] - P[2][0]*SPP[1] - P[13][0]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[1]*(P[6][1] + P[1][1]*SF[2] + P[3][1]*SF[1] + P[0][1]*SPP[0] - P[2][1]*SPP[1] - P[13][1]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SPP[0]*(P[6][2] + P[1][2]*SF[2] + P[3][2]*SF[1] + P[0][2]*SPP[0] - P[2][2]*SPP[1] - P[13][2]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - SPP[2]*(P[6][3] + P[1][3]*SF[2] + P[3][3]*SF[1] + P[0][3]*SPP[0] - P[2][3]*SPP[1] - P[13][3]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - SPP[4]*(P[6][13] + P[1][13]*SF[2] + P[3][13]*SF[1] + P[0][13]*SPP[0] - P[2][13]*SPP[1] - P[13][13]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)));\n    nextP[6][5] = P[6][5] + SQ[0] + P[1][5]*SF[2] + P[3][5]*SF[1] + P[0][5]*SPP[0] - P[2][5]*SPP[1] - P[13][5]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)) + SF[2]*(P[6][0] + P[1][0]*SF[2] + P[3][0]*SF[1] + P[0][0]*SPP[0] - P[2][0]*SPP[1] - P[13][0]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[1]*(P[6][2] + P[1][2]*SF[2] + P[3][2]*SF[1] + P[0][2]*SPP[0] - P[2][2]*SPP[1] - P[13][2]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[3]*(P[6][3] + P[1][3]*SF[2] + P[3][3]*SF[1] + P[0][3]*SPP[0] - P[2][3]*SPP[1] - P[13][3]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - SPP[0]*(P[6][1] + P[1][1]*SF[2] + P[3][1]*SF[1] + P[0][1]*SPP[0] - P[2][1]*SPP[1] - P[13][1]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SPP[3]*(P[6][13] + P[1][13]*SF[2] + P[3][13]*SF[1] + P[0][13]*SPP[0] - P[2][13]*SPP[1] - P[13][13]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)));\n    nextP[6][6] = P[6][6] + P[1][6]*SF[2] + P[3][6]*SF[1] + P[0][6]*SPP[0] - P[2][6]*SPP[1] - P[13][6]*(sq(q0) - sq(q1) - sq(q2) + sq(q3)) + dvxCov*sq(SG[6] - 2*q0*q2) + dvyCov*sq(SG[5] + 2*q0*q1) - SPP[5]*(P[6][13] + P[1][13]*SF[2] + P[3][13]*SF[1] + P[0][13]*SPP[0] - P[2][13]*SPP[1] - P[13][13]*SPP[5]) + SF[2]*(P[6][1] + P[1][1]*SF[2] + P[3][1]*SF[1] + P[0][1]*SPP[0] - P[2][1]*SPP[1] - P[13][1]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SF[1]*(P[6][3] + P[1][3]*SF[2] + P[3][3]*SF[1] + P[0][3]*SPP[0] - P[2][3]*SPP[1] - P[13][3]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + SPP[0]*(P[6][0] + P[1][0]*SF[2] + P[3][0]*SF[1] + P[0][0]*SPP[0] - P[2][0]*SPP[1] - P[13][0]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) - SPP[1]*(P[6][2] + P[1][2]*SF[2] + P[3][2]*SF[1] + P[0][2]*SPP[0] - P[2][2]*SPP[1] - P[13][2]*(sq(q0) - sq(q1) - sq(q2) + sq(q3))) + dvzCov*sq(SG[1] - SG[2] - SG[3] + SG[4]);\n    nextP[6][7] = P[6][7] + P[1][7]*SF[2] + P[3][7]*SF[1] + P[0][7]*SPP[0] - P[2][7]*SPP[1] - P[13][7]*SPP[5] + dt*(P[6][4] + P[1][4]*SF[2] + P[3][4]*SF[1] + P[0][4]*SPP[0] - P[2][4]*SPP[1] - P[13][4]*SPP[5]);\n    nextP[6][8] = P[6][8] + P[1][8]*SF[2] + P[3][8]*SF[1] + P[0][8]*SPP[0] - P[2][8]*SPP[1] - P[13][8]*SPP[5] + dt*(P[6][5] + P[1][5]*SF[2] + P[3][5]*SF[1] + P[0][5]*SPP[0] - P[2][5]*SPP[1] - P[13][5]*SPP[5]);\n    nextP[6][9] = P[6][9] + P[1][9]*SF[2] + P[3][9]*SF[1] + P[0][9]*SPP[0] - P[2][9]*SPP[1] - P[13][9]*SPP[5] + dt*(P[6][6] + P[1][6]*SF[2] + P[3][6]*SF[1] + P[0][6]*SPP[0] - P[2][6]*SPP[1] - P[13][6]*SPP[5]);\n    nextP[6][10] = P[6][10] + P[1][10]*SF[2] + P[3][10]*SF[1] + P[0][10]*SPP[0] - P[2][10]*SPP[1] - P[13][10]*SPP[5];\n    nextP[6][11] = P[6][11] + P[1][11]*SF[2] + P[3][11]*SF[1] + P[0][11]*SPP[0] - P[2][11]*SPP[1] - P[13][11]*SPP[5];\n    nextP[6][12] = P[6][12] + P[1][12]*SF[2] + P[3][12]*SF[1] + P[0][12]*SPP[0] - P[2][12]*SPP[1] - P[13][12]*SPP[5];\n    nextP[6][13] = P[6][13] + P[1][13]*SF[2] + P[3][13]*SF[1] + P[0][13]*SPP[0] - P[2][13]*SPP[1] - P[13][13]*SPP[5];\n    nextP[6][14] = P[6][14] + P[1][14]*SF[2] + P[3][14]*SF[1] + P[0][14]*SPP[0] - P[2][14]*SPP[1] - P[13][14]*SPP[5];\n    nextP[6][15] = P[6][15] + P[1][15]*SF[2] + P[3][15]*SF[1] + P[0][15]*SPP[0] - P[2][15]*SPP[1] - P[13][15]*SPP[5];\n    nextP[6][16] = P[6][16] + P[1][16]*SF[2] + P[3][16]*SF[1] + P[0][16]*SPP[0] - P[2][16]*SPP[1] - P[13][16]*SPP[5];\n    nextP[6][17] = P[6][17] + P[1][17]*SF[2] + P[3][17]*SF[1] + P[0][17]*SPP[0] - P[2][17]*SPP[1] - P[13][17]*SPP[5];\n    nextP[6][18] = P[6][18] + P[1][18]*SF[2] + P[3][18]*SF[1] + P[0][18]*SPP[0] - P[2][18]*SPP[1] - P[13][18]*SPP[5];\n    nextP[6][19] = P[6][19] + P[1][19]*SF[2] + P[3][19]*SF[1] + P[0][19]*SPP[0] - P[2][19]*SPP[1] - P[13][19]*SPP[5];\n    nextP[6][20] = P[6][20] + P[1][20]*SF[2] + P[3][20]*SF[1] + P[0][20]*SPP[0] - P[2][20]*SPP[1] - P[13][20]*SPP[5];\n    nextP[6][21] = P[6][21] + P[1][21]*SF[2] + P[3][21]*SF[1] + P[0][21]*SPP[0] - P[2][21]*SPP[1] - P[13][21]*SPP[5];\n    nextP[7][0] = P[7][0] + P[4][0]*dt + SF[7]*(P[7][1] + P[4][1]*dt) + SF[9]*(P[7][2] + P[4][2]*dt) + SF[8]*(P[7][3] + P[4][3]*dt) + SF[11]*(P[7][10] + P[4][10]*dt) + SPP[7]*(P[7][11] + P[4][11]*dt) + SPP[6]*(P[7][12] + P[4][12]*dt);\n    nextP[7][1] = P[7][1] + P[4][1]*dt + SF[6]*(P[7][0] + P[4][0]*dt) + SF[5]*(P[7][2] + P[4][2]*dt) + SF[9]*(P[7][3] + P[4][3]*dt) + SPP[6]*(P[7][11] + P[4][11]*dt) - SPP[7]*(P[7][12] + P[4][12]*dt) - (q0*(P[7][10] + P[4][10]*dt))/2;\n    nextP[7][2] = P[7][2] + P[4][2]*dt + SF[4]*(P[7][0] + P[4][0]*dt) + SF[8]*(P[7][1] + P[4][1]*dt) + SF[6]*(P[7][3] + P[4][3]*dt) + SF[11]*(P[7][12] + P[4][12]*dt) - SPP[6]*(P[7][10] + P[4][10]*dt) - (q0*(P[7][11] + P[4][11]*dt))/2;\n    nextP[7][3] = P[7][3] + P[4][3]*dt + SF[5]*(P[7][0] + P[4][0]*dt) + SF[4]*(P[7][1] + P[4][1]*dt) + SF[7]*(P[7][2] + P[4][2]*dt) - SF[11]*(P[7][11] + P[4][11]*dt) + SPP[7]*(P[7][10] + P[4][10]*dt) - (q0*(P[7][12] + P[4][12]*dt))/2;\n    nextP[7][4] = P[7][4] + P[4][4]*dt + SF[1]*(P[7][1] + P[4][1]*dt) + SF[3]*(P[7][0] + P[4][0]*dt) + SPP[0]*(P[7][2] + P[4][2]*dt) - SPP[2]*(P[7][3] + P[4][3]*dt) - SPP[4]*(P[7][13] + P[4][13]*dt);\n    nextP[7][5] = P[7][5] + P[4][5]*dt + SF[2]*(P[7][0] + P[4][0]*dt) + SF[1]*(P[7][2] + P[4][2]*dt) + SF[3]*(P[7][3] + P[4][3]*dt) - SPP[0]*(P[7][1] + P[4][1]*dt) + SPP[3]*(P[7][13] + P[4][13]*dt);\n    nextP[7][6] = P[7][6] + P[4][6]*dt + SF[2]*(P[7][1] + P[4][1]*dt) + SF[1]*(P[7][3] + P[4][3]*dt) + SPP[0]*(P[7][0] + P[4][0]*dt) - SPP[1]*(P[7][2] + P[4][2]*dt) - SPP[5]*(P[7][13] + P[4][13]*dt);\n    nextP[7][7] = P[7][7] + P[4][7]*dt + dt*(P[7][4] + P[4][4]*dt);\n    nextP[7][8] = P[7][8] + P[4][8]*dt + dt*(P[7][5] + P[4][5]*dt);\n    nextP[7][9] = P[7][9] + P[4][9]*dt + dt*(P[7][6] + P[4][6]*dt);\n    nextP[7][10] = P[7][10] + P[4][10]*dt;\n    nextP[7][11] = P[7][11] + P[4][11]*dt;\n    nextP[7][12] = P[7][12] + P[4][12]*dt;\n    nextP[7][13] = P[7][13] + P[4][13]*dt;\n    nextP[7][14] = P[7][14] + P[4][14]*dt;\n    nextP[7][15] = P[7][15] + P[4][15]*dt;\n    nextP[7][16] = P[7][16] + P[4][16]*dt;\n    nextP[7][17] = P[7][17] + P[4][17]*dt;\n    nextP[7][18] = P[7][18] + P[4][18]*dt;\n    nextP[7][19] = P[7][19] + P[4][19]*dt;\n    nextP[7][20] = P[7][20] + P[4][20]*dt;\n    nextP[7][21] = P[7][21] + P[4][21]*dt;\n    nextP[8][0] = P[8][0] + P[5][0]*dt + SF[7]*(P[8][1] + P[5][1]*dt) + SF[9]*(P[8][2] + P[5][2]*dt) + SF[8]*(P[8][3] + P[5][3]*dt) + SF[11]*(P[8][10] + P[5][10]*dt) + SPP[7]*(P[8][11] + P[5][11]*dt) + SPP[6]*(P[8][12] + P[5][12]*dt);\n    nextP[8][1] = P[8][1] + P[5][1]*dt + SF[6]*(P[8][0] + P[5][0]*dt) + SF[5]*(P[8][2] + P[5][2]*dt) + SF[9]*(P[8][3] + P[5][3]*dt) + SPP[6]*(P[8][11] + P[5][11]*dt) - SPP[7]*(P[8][12] + P[5][12]*dt) - (q0*(P[8][10] + P[5][10]*dt))/2;\n    nextP[8][2] = P[8][2] + P[5][2]*dt + SF[4]*(P[8][0] + P[5][0]*dt) + SF[8]*(P[8][1] + P[5][1]*dt) + SF[6]*(P[8][3] + P[5][3]*dt) + SF[11]*(P[8][12] + P[5][12]*dt) - SPP[6]*(P[8][10] + P[5][10]*dt) - (q0*(P[8][11] + P[5][11]*dt))/2;\n    nextP[8][3] = P[8][3] + P[5][3]*dt + SF[5]*(P[8][0] + P[5][0]*dt) + SF[4]*(P[8][1] + P[5][1]*dt) + SF[7]*(P[8][2] + P[5][2]*dt) - SF[11]*(P[8][11] + P[5][11]*dt) + SPP[7]*(P[8][10] + P[5][10]*dt) - (q0*(P[8][12] + P[5][12]*dt))/2;\n    nextP[8][4] = P[8][4] + P[5][4]*dt + SF[1]*(P[8][1] + P[5][1]*dt) + SF[3]*(P[8][0] + P[5][0]*dt) + SPP[0]*(P[8][2] + P[5][2]*dt) - SPP[2]*(P[8][3] + P[5][3]*dt) - SPP[4]*(P[8][13] + P[5][13]*dt);\n    nextP[8][5] = P[8][5] + P[5][5]*dt + SF[2]*(P[8][0] + P[5][0]*dt) + SF[1]*(P[8][2] + P[5][2]*dt) + SF[3]*(P[8][3] + P[5][3]*dt) - SPP[0]*(P[8][1] + P[5][1]*dt) + SPP[3]*(P[8][13] + P[5][13]*dt);\n    nextP[8][6] = P[8][6] + P[5][6]*dt + SF[2]*(P[8][1] + P[5][1]*dt) + SF[1]*(P[8][3] + P[5][3]*dt) + SPP[0]*(P[8][0] + P[5][0]*dt) - SPP[1]*(P[8][2] + P[5][2]*dt) - SPP[5]*(P[8][13] + P[5][13]*dt);\n    nextP[8][7] = P[8][7] + P[5][7]*dt + dt*(P[8][4] + P[5][4]*dt);\n    nextP[8][8] = P[8][8] + P[5][8]*dt + dt*(P[8][5] + P[5][5]*dt);\n    nextP[8][9] = P[8][9] + P[5][9]*dt + dt*(P[8][6] + P[5][6]*dt);\n    nextP[8][10] = P[8][10] + P[5][10]*dt;\n    nextP[8][11] = P[8][11] + P[5][11]*dt;\n    nextP[8][12] = P[8][12] + P[5][12]*dt;\n    nextP[8][13] = P[8][13] + P[5][13]*dt;\n    nextP[8][14] = P[8][14] + P[5][14]*dt;\n    nextP[8][15] = P[8][15] + P[5][15]*dt;\n    nextP[8][16] = P[8][16] + P[5][16]*dt;\n    nextP[8][17] = P[8][17] + P[5][17]*dt;\n    nextP[8][18] = P[8][18] + P[5][18]*dt;\n    nextP[8][19] = P[8][19] + P[5][19]*dt;\n    nextP[8][20] = P[8][20] + P[5][20]*dt;\n    nextP[8][21] = P[8][21] + P[5][21]*dt;\n    nextP[9][0] = P[9][0] + P[6][0]*dt + SF[7]*(P[9][1] + P[6][1]*dt) + SF[9]*(P[9][2] + P[6][2]*dt) + SF[8]*(P[9][3] + P[6][3]*dt) + SF[11]*(P[9][10] + P[6][10]*dt) + SPP[7]*(P[9][11] + P[6][11]*dt) + SPP[6]*(P[9][12] + P[6][12]*dt);\n    nextP[9][1] = P[9][1] + P[6][1]*dt + SF[6]*(P[9][0] + P[6][0]*dt) + SF[5]*(P[9][2] + P[6][2]*dt) + SF[9]*(P[9][3] + P[6][3]*dt) + SPP[6]*(P[9][11] + P[6][11]*dt) - SPP[7]*(P[9][12] + P[6][12]*dt) - (q0*(P[9][10] + P[6][10]*dt))/2;\n    nextP[9][2] = P[9][2] + P[6][2]*dt + SF[4]*(P[9][0] + P[6][0]*dt) + SF[8]*(P[9][1] + P[6][1]*dt) + SF[6]*(P[9][3] + P[6][3]*dt) + SF[11]*(P[9][12] + P[6][12]*dt) - SPP[6]*(P[9][10] + P[6][10]*dt) - (q0*(P[9][11] + P[6][11]*dt))/2;\n    nextP[9][3] = P[9][3] + P[6][3]*dt + SF[5]*(P[9][0] + P[6][0]*dt) + SF[4]*(P[9][1] + P[6][1]*dt) + SF[7]*(P[9][2] + P[6][2]*dt) - SF[11]*(P[9][11] + P[6][11]*dt) + SPP[7]*(P[9][10] + P[6][10]*dt) - (q0*(P[9][12] + P[6][12]*dt))/2;\n    nextP[9][4] = P[9][4] + P[6][4]*dt + SF[1]*(P[9][1] + P[6][1]*dt) + SF[3]*(P[9][0] + P[6][0]*dt) + SPP[0]*(P[9][2] + P[6][2]*dt) - SPP[2]*(P[9][3] + P[6][3]*dt) - SPP[4]*(P[9][13] + P[6][13]*dt);\n    nextP[9][5] = P[9][5] + P[6][5]*dt + SF[2]*(P[9][0] + P[6][0]*dt) + SF[1]*(P[9][2] + P[6][2]*dt) + SF[3]*(P[9][3] + P[6][3]*dt) - SPP[0]*(P[9][1] + P[6][1]*dt) + SPP[3]*(P[9][13] + P[6][13]*dt);\n    nextP[9][6] = P[9][6] + P[6][6]*dt + SF[2]*(P[9][1] + P[6][1]*dt) + SF[1]*(P[9][3] + P[6][3]*dt) + SPP[0]*(P[9][0] + P[6][0]*dt) - SPP[1]*(P[9][2] + P[6][2]*dt) - SPP[5]*(P[9][13] + P[6][13]*dt);\n    nextP[9][7] = P[9][7] + P[6][7]*dt + dt*(P[9][4] + P[6][4]*dt);\n    nextP[9][8] = P[9][8] + P[6][8]*dt + dt*(P[9][5] + P[6][5]*dt);\n    nextP[9][9] = P[9][9] + P[6][9]*dt + dt*(P[9][6] + P[6][6]*dt);\n    nextP[9][10] = P[9][10] + P[6][10]*dt;\n    nextP[9][11] = P[9][11] + P[6][11]*dt;\n    nextP[9][12] = P[9][12] + P[6][12]*dt;\n    nextP[9][13] = P[9][13] + P[6][13]*dt;\n    nextP[9][14] = P[9][14] + P[6][14]*dt;\n    nextP[9][15] = P[9][15] + P[6][15]*dt;\n    nextP[9][16] = P[9][16] + P[6][16]*dt;\n    nextP[9][17] = P[9][17] + P[6][17]*dt;\n    nextP[9][18] = P[9][18] + P[6][18]*dt;\n    nextP[9][19] = P[9][19] + P[6][19]*dt;\n    nextP[9][20] = P[9][20] + P[6][20]*dt;\n    nextP[9][21] = P[9][21] + P[6][21]*dt;\n    nextP[10][0] = P[10][0] + P[10][1]*SF[7] + P[10][2]*SF[9] + P[10][3]*SF[8] + P[10][10]*SF[11] + P[10][11]*SPP[7] + P[10][12]*SPP[6];\n    nextP[10][1] = P[10][1] + P[10][0]*SF[6] + P[10][2]*SF[5] + P[10][3]*SF[9] + P[10][11]*SPP[6] - P[10][12]*SPP[7] - (P[10][10]*q0)/2;\n    nextP[10][2] = P[10][2] + P[10][0]*SF[4] + P[10][1]*SF[8] + P[10][3]*SF[6] + P[10][12]*SF[11] - P[10][10]*SPP[6] - (P[10][11]*q0)/2;\n    nextP[10][3] = P[10][3] + P[10][0]*SF[5] + P[10][1]*SF[4] + P[10][2]*SF[7] - P[10][11]*SF[11] + P[10][10]*SPP[7] - (P[10][12]*q0)/2;\n    nextP[10][4] = P[10][4] + P[10][1]*SF[1] + P[10][0]*SF[3] + P[10][2]*SPP[0] - P[10][3]*SPP[2] - P[10][13]*SPP[4];\n    nextP[10][5] = P[10][5] + P[10][0]*SF[2] + P[10][2]*SF[1] + P[10][3]*SF[3] - P[10][1]*SPP[0] + P[10][13]*SPP[3];\n    nextP[10][6] = P[10][6] + P[10][1]*SF[2] + P[10][3]*SF[1] + P[10][0]*SPP[0] - P[10][2]*SPP[1] - P[10][13]*SPP[5];\n    nextP[10][7] = P[10][7] + P[10][4]*dt;\n    nextP[10][8] = P[10][8] + P[10][5]*dt;\n    nextP[10][9] = P[10][9] + P[10][6]*dt;\n    nextP[10][10] = P[10][10];\n    nextP[10][11] = P[10][11];\n    nextP[10][12] = P[10][12];\n    nextP[10][13] = P[10][13];\n    nextP[10][14] = P[10][14];\n    nextP[10][15] = P[10][15];\n    nextP[10][16] = P[10][16];\n    nextP[10][17] = P[10][17];\n    nextP[10][18] = P[10][18];\n    nextP[10][19] = P[10][19];\n    nextP[10][20] = P[10][20];\n    nextP[10][21] = P[10][21];\n    nextP[11][0] = P[11][0] + P[11][1]*SF[7] + P[11][2]*SF[9] + P[11][3]*SF[8] + P[11][10]*SF[11] + P[11][11]*SPP[7] + P[11][12]*SPP[6];\n    nextP[11][1] = P[11][1] + P[11][0]*SF[6] + P[11][2]*SF[5] + P[11][3]*SF[9] + P[11][11]*SPP[6] - P[11][12]*SPP[7] - (P[11][10]*q0)/2;\n    nextP[11][2] = P[11][2] + P[11][0]*SF[4] + P[11][1]*SF[8] + P[11][3]*SF[6] + P[11][12]*SF[11] - P[11][10]*SPP[6] - (P[11][11]*q0)/2;\n    nextP[11][3] = P[11][3] + P[11][0]*SF[5] + P[11][1]*SF[4] + P[11][2]*SF[7] - P[11][11]*SF[11] + P[11][10]*SPP[7] - (P[11][12]*q0)/2;\n    nextP[11][4] = P[11][4] + P[11][1]*SF[1] + P[11][0]*SF[3] + P[11][2]*SPP[0] - P[11][3]*SPP[2] - P[11][13]*SPP[4];\n    nextP[11][5] = P[11][5] + P[11][0]*SF[2] + P[11][2]*SF[1] + P[11][3]*SF[3] - P[11][1]*SPP[0] + P[11][13]*SPP[3];\n    nextP[11][6] = P[11][6] + P[11][1]*SF[2] + P[11][3]*SF[1] + P[11][0]*SPP[0] - P[11][2]*SPP[1] - P[11][13]*SPP[5];\n    nextP[11][7] = P[11][7] + P[11][4]*dt;\n    nextP[11][8] = P[11][8] + P[11][5]*dt;\n    nextP[11][9] = P[11][9] + P[11][6]*dt;\n    nextP[11][10] = P[11][10];\n    nextP[11][11] = P[11][11];\n    nextP[11][12] = P[11][12];\n    nextP[11][13] = P[11][13];\n    nextP[11][14] = P[11][14];\n    nextP[11][15] = P[11][15];\n    nextP[11][16] = P[11][16];\n    nextP[11][17] = P[11][17];\n    nextP[11][18] = P[11][18];\n    nextP[11][19] = P[11][19];\n    nextP[11][20] = P[11][20];\n    nextP[11][21] = P[11][21];\n    nextP[12][0] = P[12][0] + P[12][1]*SF[7] + P[12][2]*SF[9] + P[12][3]*SF[8] + P[12][10]*SF[11] + P[12][11]*SPP[7] + P[12][12]*SPP[6];\n    nextP[12][1] = P[12][1] + P[12][0]*SF[6] + P[12][2]*SF[5] + P[12][3]*SF[9] + P[12][11]*SPP[6] - P[12][12]*SPP[7] - (P[12][10]*q0)/2;\n    nextP[12][2] = P[12][2] + P[12][0]*SF[4] + P[12][1]*SF[8] + P[12][3]*SF[6] + P[12][12]*SF[11] - P[12][10]*SPP[6] - (P[12][11]*q0)/2;\n    nextP[12][3] = P[12][3] + P[12][0]*SF[5] + P[12][1]*SF[4] + P[12][2]*SF[7] - P[12][11]*SF[11] + P[12][10]*SPP[7] - (P[12][12]*q0)/2;\n    nextP[12][4] = P[12][4] + P[12][1]*SF[1] + P[12][0]*SF[3] + P[12][2]*SPP[0] - P[12][3]*SPP[2] - P[12][13]*SPP[4];\n    nextP[12][5] = P[12][5] + P[12][0]*SF[2] + P[12][2]*SF[1] + P[12][3]*SF[3] - P[12][1]*SPP[0] + P[12][13]*SPP[3];\n    nextP[12][6] = P[12][6] + P[12][1]*SF[2] + P[12][3]*SF[1] + P[12][0]*SPP[0] - P[12][2]*SPP[1] - P[12][13]*SPP[5];\n    nextP[12][7] = P[12][7] + P[12][4]*dt;\n    nextP[12][8] = P[12][8] + P[12][5]*dt;\n    nextP[12][9] = P[12][9] + P[12][6]*dt;\n    nextP[12][10] = P[12][10];\n    nextP[12][11] = P[12][11];\n    nextP[12][12] = P[12][12];\n    nextP[12][13] = P[12][13];\n    nextP[12][14] = P[12][14];\n    nextP[12][15] = P[12][15];\n    nextP[12][16] = P[12][16];\n    nextP[12][17] = P[12][17];\n    nextP[12][18] = P[12][18];\n    nextP[12][19] = P[12][19];\n    nextP[12][20] = P[12][20];\n    nextP[12][21] = P[12][21];\n    nextP[13][0] = P[13][0] + P[13][1]*SF[7] + P[13][2]*SF[9] + P[13][3]*SF[8] + P[13][10]*SF[11] + P[13][11]*SPP[7] + P[13][12]*SPP[6];\n    nextP[13][1] = P[13][1] + P[13][0]*SF[6] + P[13][2]*SF[5] + P[13][3]*SF[9] + P[13][11]*SPP[6] - P[13][12]*SPP[7] - (P[13][10]*q0)/2;\n    nextP[13][2] = P[13][2] + P[13][0]*SF[4] + P[13][1]*SF[8] + P[13][3]*SF[6] + P[13][12]*SF[11] - P[13][10]*SPP[6] - (P[13][11]*q0)/2;\n    nextP[13][3] = P[13][3] + P[13][0]*SF[5] + P[13][1]*SF[4] + P[13][2]*SF[7] - P[13][11]*SF[11] + P[13][10]*SPP[7] - (P[13][12]*q0)/2;\n    nextP[13][4] = P[13][4] + P[13][1]*SF[1] + P[13][0]*SF[3] + P[13][2]*SPP[0] - P[13][3]*SPP[2] - P[13][13]*SPP[4];\n    nextP[13][5] = P[13][5] + P[13][0]*SF[2] + P[13][2]*SF[1] + P[13][3]*SF[3] - P[13][1]*SPP[0] + P[13][13]*SPP[3];\n    nextP[13][6] = P[13][6] + P[13][1]*SF[2] + P[13][3]*SF[1] + P[13][0]*SPP[0] - P[13][2]*SPP[1] - P[13][13]*SPP[5];\n    nextP[13][7] = P[13][7] + P[13][4]*dt;\n    nextP[13][8] = P[13][8] + P[13][5]*dt;\n    nextP[13][9] = P[13][9] + P[13][6]*dt;\n    nextP[13][10] = P[13][10];\n    nextP[13][11] = P[13][11];\n    nextP[13][12] = P[13][12];\n    nextP[13][13] = P[13][13];\n    nextP[13][14] = P[13][14];\n    nextP[13][15] = P[13][15];\n    nextP[13][16] = P[13][16];\n    nextP[13][17] = P[13][17];\n    nextP[13][18] = P[13][18];\n    nextP[13][19] = P[13][19];\n    nextP[13][20] = P[13][20];\n    nextP[13][21] = P[13][21];\n    nextP[14][0] = P[14][0] + P[14][1]*SF[7] + P[14][2]*SF[9] + P[14][3]*SF[8] + P[14][10]*SF[11] + P[14][11]*SPP[7] + P[14][12]*SPP[6];\n    nextP[14][1] = P[14][1] + P[14][0]*SF[6] + P[14][2]*SF[5] + P[14][3]*SF[9] + P[14][11]*SPP[6] - P[14][12]*SPP[7] - (P[14][10]*q0)/2;\n    nextP[14][2] = P[14][2] + P[14][0]*SF[4] + P[14][1]*SF[8] + P[14][3]*SF[6] + P[14][12]*SF[11] - P[14][10]*SPP[6] - (P[14][11]*q0)/2;\n    nextP[14][3] = P[14][3] + P[14][0]*SF[5] + P[14][1]*SF[4] + P[14][2]*SF[7] - P[14][11]*SF[11] + P[14][10]*SPP[7] - (P[14][12]*q0)/2;\n    nextP[14][4] = P[14][4] + P[14][1]*SF[1] + P[14][0]*SF[3] + P[14][2]*SPP[0] - P[14][3]*SPP[2] - P[14][13]*SPP[4];\n    nextP[14][5] = P[14][5] + P[14][0]*SF[2] + P[14][2]*SF[1] + P[14][3]*SF[3] - P[14][1]*SPP[0] + P[14][13]*SPP[3];\n    nextP[14][6] = P[14][6] + P[14][1]*SF[2] + P[14][3]*SF[1] + P[14][0]*SPP[0] - P[14][2]*SPP[1] - P[14][13]*SPP[5];\n    nextP[14][7] = P[14][7] + P[14][4]*dt;\n    nextP[14][8] = P[14][8] + P[14][5]*dt;\n    nextP[14][9] = P[14][9] + P[14][6]*dt;\n    nextP[14][10] = P[14][10];\n    nextP[14][11] = P[14][11];\n    nextP[14][12] = P[14][12];\n    nextP[14][13] = P[14][13];\n    nextP[14][14] = P[14][14];\n    nextP[14][15] = P[14][15];\n    nextP[14][16] = P[14][16];\n    nextP[14][17] = P[14][17];\n    nextP[14][18] = P[14][18];\n    nextP[14][19] = P[14][19];\n    nextP[14][20] = P[14][20];\n    nextP[14][21] = P[14][21];\n    nextP[15][0] = P[15][0] + P[15][1]*SF[7] + P[15][2]*SF[9] + P[15][3]*SF[8] + P[15][10]*SF[11] + P[15][11]*SPP[7] + P[15][12]*SPP[6];\n    nextP[15][1] = P[15][1] + P[15][0]*SF[6] + P[15][2]*SF[5] + P[15][3]*SF[9] + P[15][11]*SPP[6] - P[15][12]*SPP[7] - (P[15][10]*q0)/2;\n    nextP[15][2] = P[15][2] + P[15][0]*SF[4] + P[15][1]*SF[8] + P[15][3]*SF[6] + P[15][12]*SF[11] - P[15][10]*SPP[6] - (P[15][11]*q0)/2;\n    nextP[15][3] = P[15][3] + P[15][0]*SF[5] + P[15][1]*SF[4] + P[15][2]*SF[7] - P[15][11]*SF[11] + P[15][10]*SPP[7] - (P[15][12]*q0)/2;\n    nextP[15][4] = P[15][4] + P[15][1]*SF[1] + P[15][0]*SF[3] + P[15][2]*SPP[0] - P[15][3]*SPP[2] - P[15][13]*SPP[4];\n    nextP[15][5] = P[15][5] + P[15][0]*SF[2] + P[15][2]*SF[1] + P[15][3]*SF[3] - P[15][1]*SPP[0] + P[15][13]*SPP[3];\n    nextP[15][6] = P[15][6] + P[15][1]*SF[2] + P[15][3]*SF[1] + P[15][0]*SPP[0] - P[15][2]*SPP[1] - P[15][13]*SPP[5];\n    nextP[15][7] = P[15][7] + P[15][4]*dt;\n    nextP[15][8] = P[15][8] + P[15][5]*dt;\n    nextP[15][9] = P[15][9] + P[15][6]*dt;\n    nextP[15][10] = P[15][10];\n    nextP[15][11] = P[15][11];\n    nextP[15][12] = P[15][12];\n    nextP[15][13] = P[15][13];\n    nextP[15][14] = P[15][14];\n    nextP[15][15] = P[15][15];\n    nextP[15][16] = P[15][16];\n    nextP[15][17] = P[15][17];\n    nextP[15][18] = P[15][18];\n    nextP[15][19] = P[15][19];\n    nextP[15][20] = P[15][20];\n    nextP[15][21] = P[15][21];\n    nextP[16][0] = P[16][0] + P[16][1]*SF[7] + P[16][2]*SF[9] + P[16][3]*SF[8] + P[16][10]*SF[11] + P[16][11]*SPP[7] + P[16][12]*SPP[6];\n    nextP[16][1] = P[16][1] + P[16][0]*SF[6] + P[16][2]*SF[5] + P[16][3]*SF[9] + P[16][11]*SPP[6] - P[16][12]*SPP[7] - (P[16][10]*q0)/2;\n    nextP[16][2] = P[16][2] + P[16][0]*SF[4] + P[16][1]*SF[8] + P[16][3]*SF[6] + P[16][12]*SF[11] - P[16][10]*SPP[6] - (P[16][11]*q0)/2;\n    nextP[16][3] = P[16][3] + P[16][0]*SF[5] + P[16][1]*SF[4] + P[16][2]*SF[7] - P[16][11]*SF[11] + P[16][10]*SPP[7] - (P[16][12]*q0)/2;\n    nextP[16][4] = P[16][4] + P[16][1]*SF[1] + P[16][0]*SF[3] + P[16][2]*SPP[0] - P[16][3]*SPP[2] - P[16][13]*SPP[4];\n    nextP[16][5] = P[16][5] + P[16][0]*SF[2] + P[16][2]*SF[1] + P[16][3]*SF[3] - P[16][1]*SPP[0] + P[16][13]*SPP[3];\n    nextP[16][6] = P[16][6] + P[16][1]*SF[2] + P[16][3]*SF[1] + P[16][0]*SPP[0] - P[16][2]*SPP[1] - P[16][13]*SPP[5];\n    nextP[16][7] = P[16][7] + P[16][4]*dt;\n    nextP[16][8] = P[16][8] + P[16][5]*dt;\n    nextP[16][9] = P[16][9] + P[16][6]*dt;\n    nextP[16][10] = P[16][10];\n    nextP[16][11] = P[16][11];\n    nextP[16][12] = P[16][12];\n    nextP[16][13] = P[16][13];\n    nextP[16][14] = P[16][14];\n    nextP[16][15] = P[16][15];\n    nextP[16][16] = P[16][16];\n    nextP[16][17] = P[16][17];\n    nextP[16][18] = P[16][18];\n    nextP[16][19] = P[16][19];\n    nextP[16][20] = P[16][20];\n    nextP[16][21] = P[16][21];\n    nextP[17][0] = P[17][0] + P[17][1]*SF[7] + P[17][2]*SF[9] + P[17][3]*SF[8] + P[17][10]*SF[11] + P[17][11]*SPP[7] + P[17][12]*SPP[6];\n    nextP[17][1] = P[17][1] + P[17][0]*SF[6] + P[17][2]*SF[5] + P[17][3]*SF[9] + P[17][11]*SPP[6] - P[17][12]*SPP[7] - (P[17][10]*q0)/2;\n    nextP[17][2] = P[17][2] + P[17][0]*SF[4] + P[17][1]*SF[8] + P[17][3]*SF[6] + P[17][12]*SF[11] - P[17][10]*SPP[6] - (P[17][11]*q0)/2;\n    nextP[17][3] = P[17][3] + P[17][0]*SF[5] + P[17][1]*SF[4] + P[17][2]*SF[7] - P[17][11]*SF[11] + P[17][10]*SPP[7] - (P[17][12]*q0)/2;\n    nextP[17][4] = P[17][4] + P[17][1]*SF[1] + P[17][0]*SF[3] + P[17][2]*SPP[0] - P[17][3]*SPP[2] - P[17][13]*SPP[4];\n    nextP[17][5] = P[17][5] + P[17][0]*SF[2] + P[17][2]*SF[1] + P[17][3]*SF[3] - P[17][1]*SPP[0] + P[17][13]*SPP[3];\n    nextP[17][6] = P[17][6] + P[17][1]*SF[2] + P[17][3]*SF[1] + P[17][0]*SPP[0] - P[17][2]*SPP[1] - P[17][13]*SPP[5];\n    nextP[17][7] = P[17][7] + P[17][4]*dt;\n    nextP[17][8] = P[17][8] + P[17][5]*dt;\n    nextP[17][9] = P[17][9] + P[17][6]*dt;\n    nextP[17][10] = P[17][10];\n    nextP[17][11] = P[17][11];\n    nextP[17][12] = P[17][12];\n    nextP[17][13] = P[17][13];\n    nextP[17][14] = P[17][14];\n    nextP[17][15] = P[17][15];\n    nextP[17][16] = P[17][16];\n    nextP[17][17] = P[17][17];\n    nextP[17][18] = P[17][18];\n    nextP[17][19] = P[17][19];\n    nextP[17][20] = P[17][20];\n    nextP[17][21] = P[17][21];\n    nextP[18][0] = P[18][0] + P[18][1]*SF[7] + P[18][2]*SF[9] + P[18][3]*SF[8] + P[18][10]*SF[11] + P[18][11]*SPP[7] + P[18][12]*SPP[6];\n    nextP[18][1] = P[18][1] + P[18][0]*SF[6] + P[18][2]*SF[5] + P[18][3]*SF[9] + P[18][11]*SPP[6] - P[18][12]*SPP[7] - (P[18][10]*q0)/2;\n    nextP[18][2] = P[18][2] + P[18][0]*SF[4] + P[18][1]*SF[8] + P[18][3]*SF[6] + P[18][12]*SF[11] - P[18][10]*SPP[6] - (P[18][11]*q0)/2;\n    nextP[18][3] = P[18][3] + P[18][0]*SF[5] + P[18][1]*SF[4] + P[18][2]*SF[7] - P[18][11]*SF[11] + P[18][10]*SPP[7] - (P[18][12]*q0)/2;\n    nextP[18][4] = P[18][4] + P[18][1]*SF[1] + P[18][0]*SF[3] + P[18][2]*SPP[0] - P[18][3]*SPP[2] - P[18][13]*SPP[4];\n    nextP[18][5] = P[18][5] + P[18][0]*SF[2] + P[18][2]*SF[1] + P[18][3]*SF[3] - P[18][1]*SPP[0] + P[18][13]*SPP[3];\n    nextP[18][6] = P[18][6] + P[18][1]*SF[2] + P[18][3]*SF[1] + P[18][0]*SPP[0] - P[18][2]*SPP[1] - P[18][13]*SPP[5];\n    nextP[18][7] = P[18][7] + P[18][4]*dt;\n    nextP[18][8] = P[18][8] + P[18][5]*dt;\n    nextP[18][9] = P[18][9] + P[18][6]*dt;\n    nextP[18][10] = P[18][10];\n    nextP[18][11] = P[18][11];\n    nextP[18][12] = P[18][12];\n    nextP[18][13] = P[18][13];\n    nextP[18][14] = P[18][14];\n    nextP[18][15] = P[18][15];\n    nextP[18][16] = P[18][16];\n    nextP[18][17] = P[18][17];\n    nextP[18][18] = P[18][18];\n    nextP[18][19] = P[18][19];\n    nextP[18][20] = P[18][20];\n    nextP[18][21] = P[18][21];\n    nextP[19][0] = P[19][0] + P[19][1]*SF[7] + P[19][2]*SF[9] + P[19][3]*SF[8] + P[19][10]*SF[11] + P[19][11]*SPP[7] + P[19][12]*SPP[6];\n    nextP[19][1] = P[19][1] + P[19][0]*SF[6] + P[19][2]*SF[5] + P[19][3]*SF[9] + P[19][11]*SPP[6] - P[19][12]*SPP[7] - (P[19][10]*q0)/2;\n    nextP[19][2] = P[19][2] + P[19][0]*SF[4] + P[19][1]*SF[8] + P[19][3]*SF[6] + P[19][12]*SF[11] - P[19][10]*SPP[6] - (P[19][11]*q0)/2;\n    nextP[19][3] = P[19][3] + P[19][0]*SF[5] + P[19][1]*SF[4] + P[19][2]*SF[7] - P[19][11]*SF[11] + P[19][10]*SPP[7] - (P[19][12]*q0)/2;\n    nextP[19][4] = P[19][4] + P[19][1]*SF[1] + P[19][0]*SF[3] + P[19][2]*SPP[0] - P[19][3]*SPP[2] - P[19][13]*SPP[4];\n    nextP[19][5] = P[19][5] + P[19][0]*SF[2] + P[19][2]*SF[1] + P[19][3]*SF[3] - P[19][1]*SPP[0] + P[19][13]*SPP[3];\n    nextP[19][6] = P[19][6] + P[19][1]*SF[2] + P[19][3]*SF[1] + P[19][0]*SPP[0] - P[19][2]*SPP[1] - P[19][13]*SPP[5];\n    nextP[19][7] = P[19][7] + P[19][4]*dt;\n    nextP[19][8] = P[19][8] + P[19][5]*dt;\n    nextP[19][9] = P[19][9] + P[19][6]*dt;\n    nextP[19][10] = P[19][10];\n    nextP[19][11] = P[19][11];\n    nextP[19][12] = P[19][12];\n    nextP[19][13] = P[19][13];\n    nextP[19][14] = P[19][14];\n    nextP[19][15] = P[19][15];\n    nextP[19][16] = P[19][16];\n    nextP[19][17] = P[19][17];\n    nextP[19][18] = P[19][18];\n    nextP[19][19] = P[19][19];\n    nextP[19][20] = P[19][20];\n    nextP[19][21] = P[19][21];\n    nextP[20][0] = P[20][0] + P[20][1]*SF[7] + P[20][2]*SF[9] + P[20][3]*SF[8] + P[20][10]*SF[11] + P[20][11]*SPP[7] + P[20][12]*SPP[6];\n    nextP[20][1] = P[20][1] + P[20][0]*SF[6] + P[20][2]*SF[5] + P[20][3]*SF[9] + P[20][11]*SPP[6] - P[20][12]*SPP[7] - (P[20][10]*q0)/2;\n    nextP[20][2] = P[20][2] + P[20][0]*SF[4] + P[20][1]*SF[8] + P[20][3]*SF[6] + P[20][12]*SF[11] - P[20][10]*SPP[6] - (P[20][11]*q0)/2;\n    nextP[20][3] = P[20][3] + P[20][0]*SF[5] + P[20][1]*SF[4] + P[20][2]*SF[7] - P[20][11]*SF[11] + P[20][10]*SPP[7] - (P[20][12]*q0)/2;\n    nextP[20][4] = P[20][4] + P[20][1]*SF[1] + P[20][0]*SF[3] + P[20][2]*SPP[0] - P[20][3]*SPP[2] - P[20][13]*SPP[4];\n    nextP[20][5] = P[20][5] + P[20][0]*SF[2] + P[20][2]*SF[1] + P[20][3]*SF[3] - P[20][1]*SPP[0] + P[20][13]*SPP[3];\n    nextP[20][6] = P[20][6] + P[20][1]*SF[2] + P[20][3]*SF[1] + P[20][0]*SPP[0] - P[20][2]*SPP[1] - P[20][13]*SPP[5];\n    nextP[20][7] = P[20][7] + P[20][4]*dt;\n    nextP[20][8] = P[20][8] + P[20][5]*dt;\n    nextP[20][9] = P[20][9] + P[20][6]*dt;\n    nextP[20][10] = P[20][10];\n    nextP[20][11] = P[20][11];\n    nextP[20][12] = P[20][12];\n    nextP[20][13] = P[20][13];\n    nextP[20][14] = P[20][14];\n    nextP[20][15] = P[20][15];\n    nextP[20][16] = P[20][16];\n    nextP[20][17] = P[20][17];\n    nextP[20][18] = P[20][18];\n    nextP[20][19] = P[20][19];\n    nextP[20][20] = P[20][20];\n    nextP[20][21] = P[20][21];\n    nextP[21][0] = P[21][0] + P[21][1]*SF[7] + P[21][2]*SF[9] + P[21][3]*SF[8] + P[21][10]*SF[11] + P[21][11]*SPP[7] + P[21][12]*SPP[6];\n    nextP[21][1] = P[21][1] + P[21][0]*SF[6] + P[21][2]*SF[5] + P[21][3]*SF[9] + P[21][11]*SPP[6] - P[21][12]*SPP[7] - (P[21][10]*q0)/2;\n    nextP[21][2] = P[21][2] + P[21][0]*SF[4] + P[21][1]*SF[8] + P[21][3]*SF[6] + P[21][12]*SF[11] - P[21][10]*SPP[6] - (P[21][11]*q0)/2;\n    nextP[21][3] = P[21][3] + P[21][0]*SF[5] + P[21][1]*SF[4] + P[21][2]*SF[7] - P[21][11]*SF[11] + P[21][10]*SPP[7] - (P[21][12]*q0)/2;\n    nextP[21][4] = P[21][4] + P[21][1]*SF[1] + P[21][0]*SF[3] + P[21][2]*SPP[0] - P[21][3]*SPP[2] - P[21][13]*SPP[4];\n    nextP[21][5] = P[21][5] + P[21][0]*SF[2] + P[21][2]*SF[1] + P[21][3]*SF[3] - P[21][1]*SPP[0] + P[21][13]*SPP[3];\n    nextP[21][6] = P[21][6] + P[21][1]*SF[2] + P[21][3]*SF[1] + P[21][0]*SPP[0] - P[21][2]*SPP[1] - P[21][13]*SPP[5];\n    nextP[21][7] = P[21][7] + P[21][4]*dt;\n    nextP[21][8] = P[21][8] + P[21][5]*dt;\n    nextP[21][9] = P[21][9] + P[21][6]*dt;\n    nextP[21][10] = P[21][10];\n    nextP[21][11] = P[21][11];\n    nextP[21][12] = P[21][12];\n    nextP[21][13] = P[21][13];\n    nextP[21][14] = P[21][14];\n    nextP[21][15] = P[21][15];\n    nextP[21][16] = P[21][16];\n    nextP[21][17] = P[21][17];\n    nextP[21][18] = P[21][18];\n    nextP[21][19] = P[21][19];\n    nextP[21][20] = P[21][20];\n    nextP[21][21] = P[21][21];\n\n    for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n    {\n        nextP[i][i] = nextP[i][i] + processNoise[i];\n    }\n\n    // If the total position variance exceds 1E6 (1000m), then stop covariance\n    // growth by setting the predicted to the previous values\n    // This prevent an ill conditioned matrix from occurring for long periods\n    // without GPS\n    if ((P[7][7] + P[8][8]) > 1E6f)\n    {\n        for (uint8_t i=7; i<=8; i++)\n        {\n            for (size_t j = 0; j < EKF_STATE_ESTIMATES; j++)\n            {\n                nextP[i][j] = P[i][j];\n                nextP[j][i] = P[j][i];\n            }\n        }\n    }\n\n    // Copy covariance\n    for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++) {\n        P[i][i] = nextP[i][i];\n    }\n\n    // force symmetry for observable states\n    for (size_t i = 1; i < EKF_STATE_ESTIMATES; i++)\n    {\n        for (uint8_t j = 0; j < i; j++)\n        {\n            P[i][j] = 0.5f * (nextP[i][j] + nextP[j][i]);\n            P[j][i] = P[i][j];\n        }\n    }\n\n        ConstrainVariances();\n}\n\nvoid AttPosEKF::updateDtGpsFilt(float dt)\n{\n    dtGpsFilt = ConstrainFloat(dt, 0.001f, 2.0f) * 0.05f + dtGpsFilt * 0.95f;\n}\n\nvoid AttPosEKF::updateDtHgtFilt(float dt)\n{\n    dtHgtFilt = ConstrainFloat(dt, 0.001f, 2.0f) * 0.05f + dtHgtFilt * 0.95f;\n}\n\nvoid AttPosEKF::updateDtVelPosFilt(float dt)\n{\n    dtVelPosFilt = ConstrainFloat(dt, 0.0005f, 2.0f) * 0.05f + dtVelPosFilt * 0.95f;\n}\n\nvoid AttPosEKF::FuseVelposNED() \n{\n\n    // declare variables used by fault isolation logic\n    //uint32_t gpsRetryTime = 3000; // time in msec before GPS fusion will be retried following innovation consistency failure\n    uint32_t gpsRetryTimeNoTAS = 500; // retry time if no TAS measurement available\n    uint32_t hgtRetryTime = 500; // height measurement retry time\n    uint32_t horizRetryTime;\n\n    // declare variables used to check measurement errors\n    float velInnov[3] = {0.0f,0.0f,0.0f};\n    float posInnov[2] = {0.0f,0.0f};\n    float hgtInnov = 0.0f;\n    float hgtInnovCam = 0.0f;\n    // declare variables used to control access to arrays\n    bool fuseData[7] = {false,false,false,false,false,false,false};\n    uint8_t stateIndex;\n    uint8_t obsIndex;\n    uint8_t indexLimit = 21;\n\n    // declare variables used by state and covariance update calculations\n    float velErr;\n    float posErr;\n    float R_OBS[6];\n\n    float observation[6];\n    float SK;\n    float quatMag;\n\n\n\n    \n    // Perform sequential fusion of GPS measurements. This assumes that the\n    // errors in the different velocity and position components are\n    // uncorrelated which is not true, however in the absence of covariance\n    // data from the GPS receiver it is the only assumption we can make\n    // so we might as well take advantage of the computational efficiencies\n    // associated with sequential fusion\n    if (fuseVelData || fusePosData || fuseHgtData || fuseCamData)\n    {\n        uint64_t tNow = getMicros();\n        updateDtVelPosFilt((tNow - lastVelPosFusion) / 1e6f);\n        lastVelPosFusion = tNow;\n\n        // scaler according to the number of repetitions of the\n        // same measurement in one fusion step\n        float gpsVarianceScaler = dtGpsFilt / dtVelPosFilt;\n\n        // scaler according to the number of repetitions of the\n        // same measurement in one fusion step\n        float hgtVarianceScaler = dtHgtFilt / dtVelPosFilt;\n\n        // set the GPS data timeout depending on whether airspeed data is present\n        uint32_t gpsRetryTime = 3000; // time in msec before GPS fusion will be retried following innovation consistency failure\n\n        if (useAirspeed) horizRetryTime = gpsRetryTime;\n        else horizRetryTime = gpsRetryTimeNoTAS;\n        horizRetryTime = gpsRetryTimeNoTAS;\n        // Form the observation vector\n        for (uint8_t i=0; i <=2; i++) observation[i] = velNED[i];\n        for (uint8_t i=3; i <=4; i++) observation[i] = posNE[i-3];\n      \n\n        observation[5] = -(hgtMea);\n        observation[6] = -(hgtMea2); \n\n        \n\n        // Estimate the GPS Velocity, GPS horiz position and height measurement variances.\n        velErr = 0.2f*accNavMag; // additional error in GPS velocities caused by manoeuvring\n        posErr = 0.2f*accNavMag; // additional error in GPS position caused by manoeuvring\n        R_OBS[0] = gpsVarianceScaler * sq(vneSigma) + sq(velErr);\n        R_OBS[1] = R_OBS[0];\n        R_OBS[2] = gpsVarianceScaler * sq(vdSigma) + sq(velErr);\n        R_OBS[3] = gpsVarianceScaler * sq(posNeSigma) + sq(posErr);\n        R_OBS[4] = R_OBS[3];\n        R_OBS[5] = hgtVarianceScaler * sq(posDSigma) + sq(posErr);\n        //expand the observation matrix with new data\n        R_OBS[6] = camSigma;\n\n        \n\n\n        // calculate innovations and check GPS data validity using an innovation consistency check\n        if (fuseVelData)\n        {\n            // test velocity measurements\n            uint8_t imax = 2;\n            if (fusionModeGPS == 1) imax = 1;\n            for (uint8_t i = 0; i<=imax; i++)\n            {\n                velInnov[i] = statesAtVelTime[i+4] - velNED[i];\n                stateIndex = 4 + i;\n                varInnovVelPos[i] = P[stateIndex][stateIndex] + R_OBS[i];\n            }\n            // apply a 5-sigma threshold\n            current_ekf_state.velHealth = (sq(velInnov[0]) + sq(velInnov[1]) + sq(velInnov[2])) < 25.0f * (varInnovVelPos[0] + varInnovVelPos[1] + varInnovVelPos[2]);\n            current_ekf_state.velTimeout = (millis() - current_ekf_state.velFailTime) > horizRetryTime;\n            if (current_ekf_state.velHealth || staticMode) {\n                current_ekf_state.velHealth = true;\n                current_ekf_state.velFailTime = millis();\n            } else if (current_ekf_state.velTimeout || !current_ekf_state.posHealth) {\n                current_ekf_state.velHealth = true;\n                ResetVelocity();\n\n                // do not fuse bad data\n                fuseVelData = false;\n            }\n            else\n            {\n                current_ekf_state.velHealth = false;\n            }\n        }\n\n        if (fusePosData)\n        {\n            // test horizontal position measurements\n            posInnov[0] = statesAtPosTime[7] - posNE[0];\n            posInnov[1] = statesAtPosTime[8] - posNE[1];\n            varInnovVelPos[3] = P[7][7] + R_OBS[3];\n            varInnovVelPos[4] = P[8][8] + R_OBS[4];\n            // apply a 10-sigma threshold\n            current_ekf_state.posHealth = (sq(posInnov[0]) + sq(posInnov[1])) < 100.0f*(varInnovVelPos[3] + varInnovVelPos[4]);\n            current_ekf_state.posTimeout = (millis() - current_ekf_state.posFailTime) > horizRetryTime;\n            if (current_ekf_state.posHealth || current_ekf_state.posTimeout)\n            {\n                current_ekf_state.posHealth = true;\n                current_ekf_state.posFailTime = millis();\n\n                if (current_ekf_state.posTimeout) {\n                    ResetPosition();\n                    \n                    // do not fuse position data on this time\n                    // step\n                    fusePosData = false;\n                }\n            }\n            else\n            {\n                current_ekf_state.posHealth = false;\n            }\n        }\n        if (fuseHgtData || fuseCamData)\n        {\n\n            // test height measurements\n            if(fuseHgtData && !fuseCamData){\n                //only baro\n                hgtInnov = statesAtHgtTime[9] + hgtMea;\n                varInnovVelPos[5] = P[9][9] + R_OBS[5];\n                current_ekf_state.hgtHealth = sq(hgtInnov) < 100.0f*varInnovVelPos[5];\n\n\n            }\n            else if(!fuseHgtData && fuseCamData){\n                //only cam\n                hgtInnov = statesAtHgtTime[9] + hgtMea2;\n                varInnovVelPos[5] = P[9][9] + R_OBS[5];\n                current_ekf_state.hgtHealth = sq(hgtInnov) < 100.0f*varInnovVelPos[5];\n\n            }\n\n\n            else if(fuseHgtData && fuseCamData){\n                //both\n                hgtInnov = statesAtHgtTime[9] + hgtMea;\n                hgtInnovCam = statesAtHgtTime[9] + hgtMea2;\n                varInnovVelPos[5] = P[9][9] + R_OBS[5];\n                varInnovVelPos[6] = P[9][9] + R_OBS[6];\n                //check height health\n                current_ekf_state.hgtHealth = sq(hgtInnov) < 100.0f*varInnovVelPos[5];\n                current_ekf_state.hgtHealth2 = sq(hgtInnovCam) < 100.0f*varInnovVelPos[6];\n\n\n                current_ekf_state.hgtTimeout = (millis() - current_ekf_state.hgtFailTime) > hgtRetryTime;\n                if ((current_ekf_state.hgtHealth2 && current_ekf_state.hgtHealth) || current_ekf_state.hgtTimeout || staticMode)\n                {\n                    current_ekf_state.hgtHealth = true;\n                    current_ekf_state.hgtHealth2 = true;\n\n                    current_ekf_state.hgtFailTime = millis();\n\n                    // if we just reset from a timeout, do not fuse\n                    // the height data, but reset height and stored states\n                    if (current_ekf_state.hgtTimeout) {\n                        ResetHeight();\n                        fuseHgtData = false;\n                    }\n                }\n                else\n                {\n                    current_ekf_state.hgtHealth = false;\n                    current_ekf_state.hgtHealth2 = false;\n\n                }\n\n\n            }\n            // apply a 10-sigma threshold\n            //current_ekf_state.hgtHealth = sq(hgtInnov) < 100.0f*varInnovVelPos[5];\n            /*current_ekf_state.hgtTimeout = (millis() - current_ekf_state.hgtFailTime) > hgtRetryTime;\n            if (current_ekf_state.hgtHealth || current_ekf_state.hgtTimeout || staticMode)\n            {\n                current_ekf_state.hgtHealth = true;\n                current_ekf_state.hgtFailTime = millis();\n\n                // if we just reset from a timeout, do not fuse\n                // the height data, but reset height and stored states\n                if (current_ekf_state.hgtTimeout) {\n                    ResetHeight();\n                    fuseHgtData = false;\n                }\n            }\n            else\n            {\n                current_ekf_state.hgtHealth = false;\n            }*/\n        }\n        // Set range for sequential fusion of velocity and position measurements depending\n        // on which data is available and its health\n        if (fuseVelData && fusionModeGPS == 0 && current_ekf_state.velHealth)\n        {\n            fuseData[0] = true;\n            fuseData[1] = true;\n            fuseData[2] = true;\n        }\n        if (fuseVelData && fusionModeGPS == 1 && current_ekf_state.velHealth)\n        {\n            fuseData[0] = true;\n            fuseData[1] = true;\n        }\n        if (fusePosData && fusionModeGPS <= 2 && current_ekf_state.posHealth)\n        {\n            fuseData[3] = true;\n            fuseData[4] = true;\n        }\n\n\n\n        if (fuseHgtData && current_ekf_state.hgtHealth && !fuseCamData)\n        {\n            fuseData[5] = true;\n        }\n        if (!fuseHgtData && current_ekf_state.hgtHealth && fuseCamData)\n        {\n            fuseData[5] = true;\n        }\n\n        if (fuseHgtData && current_ekf_state.hgtHealth && current_ekf_state.hgtHealth2 && fuseCamData)\n        {\n            fuseData[5] = true;\n            fuseData[6] = true;\n        }\n        if (fuseHgtData && current_ekf_state.hgtHealth && !current_ekf_state.hgtHealth2 && fuseCamData)\n        {\n            fuseData[5] = true;\n            fuseData[6] = false;\n        }\n        if (fuseHgtData && current_ekf_state.hgtHealth2 && !current_ekf_state.hgtHealth && fuseCamData)\n        {\n            fuseData[5] = false;\n            fuseData[6] = true;\n        }\n\n\n        // Fuse measurements sequentially\n       // obsIndex=0;\n       // while(obsIndex<=n_hgtMeas)\n        for (obsIndex=0; obsIndex<=n_hgtMeas; obsIndex++)\n        {\n            if (fuseData[obsIndex])\n            {\n                stateIndex = 4 + obsIndex;\n                if(obsIndex == 6) {//check for fusing same state with cam measurement\n                    stateIndex = 9;\n                }\n\n                // Calculate the measurement innovation, using states from a\n                // different time coordinate if fusing height data\n                if (obsIndex <= 2)\n                {   \n\n                    innovVelPos[obsIndex] = statesAtVelTime[stateIndex] - observation[obsIndex];\n                }\n                else if (obsIndex == 3 || obsIndex == 4)\n                {\n                    innovVelPos[obsIndex] = statesAtPosTime[stateIndex] - observation[obsIndex];\n                }\n\n                else if (obsIndex == 5)\n                {\n                    innovVelPos[obsIndex] = statesAtHgtTime[stateIndex] - observation[obsIndex];\n                    fusionFlag2=1;\n                }\n                else if (obsIndex == 6)\n                {\n                    innovVelPos[obsIndex] = statesAtHgtTime[stateIndex] - observation[obsIndex];\n                    fusionFlag = 1;\n                }\n                // Calculate the Kalman Gain\n                // Calculate innovation variances - also used for data logging\n                varInnovVelPos[obsIndex] = P[stateIndex][stateIndex] + R_OBS[obsIndex];\n                SK = 1.0/(double)varInnovVelPos[obsIndex];\n                for (uint8_t i= 0; i<=indexLimit; i++)\n                {\n                    Kfusion[i] = P[i][stateIndex]*SK;\n                }\n\n                // Don't update Z accel bias state unless using a height observation (GPS velocities can be biased)\n                if (obsIndex != 5) {\n                    Kfusion[13] = 0;\n                }\n                // Don't update wind states if inhibited\n                if (inhibitWindStates) {\n                    Kfusion[14] = 0;\n                    Kfusion[15] = 0;\n                }\n                // Don't update magnetic field states if inhibited\n                if (inhibitMagStates) {\n                    for (uint8_t i = 16; i < EKF_STATE_ESTIMATES; i++)\n                    {\n                        Kfusion[i] = 0;\n                    }\n                }\n\n                // Calculate state corrections and re-normalise the quaternions\n                for (uint8_t i = 0; i<=indexLimit; i++)\n                {\n                    states[i] = states[i] - Kfusion[i] * innovVelPos[obsIndex];\n                }\n                quatMag = sqrtf(states[0]*states[0] + states[1]*states[1] + states[2]*states[2] + states[3]*states[3]);\n                if (quatMag > 1e-12f) // divide by  0 protection\n                {\n                    for (uint8_t i = 0; i<=3; i++)\n                    {\n                        states[i] = states[i] / quatMag;\n                    }\n                }\n                // Update the covariance - take advantage of direct observation of a\n                // single state at index = stateIndex to reduce computations\n                // Optimised implementation of standard equation P = (I - K*H)*P;\n                for (uint8_t i= 0; i<=indexLimit; i++)\n                {\n                    for (uint8_t j= 0; j<=indexLimit; j++)\n                    {\n                        KHP[i][j] = Kfusion[i] * P[stateIndex][j];\n                    }\n                }\n                for (uint8_t i= 0; i<=indexLimit; i++)\n                {\n                    for (uint8_t j= 0; j<=indexLimit; j++)\n                    {\n                        P[i][j] = P[i][j] - KHP[i][j];\n                    }\n                }\n            } \n        }\n    }\n\n    ForceSymmetry();\n    ConstrainVariances();\n\n}\n\nvoid AttPosEKF::FuseMagnetometer()\n{\n\n    float &q0 = magstate.q0;\n    float &q1 = magstate.q1;\n    float &q2 = magstate.q2;\n    float &q3 = magstate.q3;\n    float &magN = magstate.magN;\n    float &magE = magstate.magE;\n    float &magD = magstate.magD;\n    float &magXbias = magstate.magXbias;\n    float &magYbias = magstate.magYbias;\n    float &magZbias = magstate.magZbias;\n    unsigned &obsIndex = magstate.obsIndex;\n    Mat3f &DCM = magstate.DCM;\n    float *MagPred = &magstate.MagPred[0];\n    float &R_MAG = magstate.R_MAG;\n    float *SH_MAG = &magstate.SH_MAG[0];\n\n    float SK_MX[6];\n    float SK_MY[5];\n    float SK_MZ[6];\n    float H_MAG[EKF_STATE_ESTIMATES];\n    for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++) {\n        H_MAG[i] = 0.0f;\n    }\n\n    // Perform sequential fusion of Magnetometer measurements.\n    // This assumes that the errors in the different components are\n    // uncorrelated which is not true, however in the absence of covariance\n    // data fit is the only assumption we can make\n    // so we might as well take advantage of the computational efficiencies\n    // associated with sequential fusion\n    if (useCompass && fuseMagData && (obsIndex < 3))\n    {\n        // Calculate observation jacobians and Kalman gains\n        if (obsIndex == 0)\n        {\n            // Copy required states to local variable names\n            q0       = statesAtMagMeasTime[0];\n            q1       = statesAtMagMeasTime[1];\n            q2       = statesAtMagMeasTime[2];\n            q3       = statesAtMagMeasTime[3];\n            magN     = statesAtMagMeasTime[16];\n            magE     = statesAtMagMeasTime[17];\n            magD     = statesAtMagMeasTime[18];\n            magXbias = statesAtMagMeasTime[19];\n            magYbias = statesAtMagMeasTime[20];\n            magZbias = statesAtMagMeasTime[21];\n\n            // rotate predicted earth components into body axes and calculate\n            // predicted measurments\n            DCM.x.x = q0*q0 + q1*q1 - q2*q2 - q3*q3;\n            DCM.x.y = 2*(q1*q2 + q0*q3);\n            DCM.x.z = 2*(q1*q3-q0*q2);\n            DCM.y.x = 2*(q1*q2 - q0*q3);\n            DCM.y.y = q0*q0 - q1*q1 + q2*q2 - q3*q3;\n            DCM.y.z = 2*(q2*q3 + q0*q1);\n            DCM.z.x = 2*(q1*q3 + q0*q2);\n            DCM.z.y = 2*(q2*q3 - q0*q1);\n            DCM.z.z = q0*q0 - q1*q1 - q2*q2 + q3*q3;\n            MagPred[0] = DCM.x.x*magN + DCM.x.y*magE  + DCM.x.z*magD + magXbias;\n            MagPred[1] = DCM.y.x*magN + DCM.y.y*magE  + DCM.y.z*magD + magYbias;\n            MagPred[2] = DCM.z.x*magN + DCM.z.y*magE  + DCM.z.z*magD + magZbias;\n\n            // scale magnetometer observation error with total angular rate\n            R_MAG = sq(magMeasurementSigma) + sq(0.05f*dAngIMU.length()/dtIMU);\n\n            // Calculate observation jacobians\n            SH_MAG[0] = 2*magD*q3 + 2*magE*q2 + 2*magN*q1;\n            SH_MAG[1] = 2*magD*q0 - 2*magE*q1 + 2*magN*q2;\n            SH_MAG[2] = 2*magD*q1 + 2*magE*q0 - 2*magN*q3;\n            SH_MAG[3] = sq(q3);\n            SH_MAG[4] = sq(q2);\n            SH_MAG[5] = sq(q1);\n            SH_MAG[6] = sq(q0);\n            SH_MAG[7] = 2*magN*q0;\n            SH_MAG[8] = 2*magE*q3;\n\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++) H_MAG[i] = 0;\n            H_MAG[0] = SH_MAG[7] + SH_MAG[8] - 2*magD*q2;\n            H_MAG[1] = SH_MAG[0];\n            H_MAG[2] = 2*magE*q1 - 2*magD*q0 - 2*magN*q2;\n            H_MAG[3] = SH_MAG[2];\n            H_MAG[16] = SH_MAG[5] - SH_MAG[4] - SH_MAG[3] + SH_MAG[6];\n            H_MAG[17] = 2*q0*q3 + 2*q1*q2;\n            H_MAG[18] = 2*q1*q3 - 2*q0*q2;\n            H_MAG[19] = 1.0f;\n\n            // Calculate Kalman gain\n            float temp = (P[19][19] + R_MAG + P[1][19]*SH_MAG[0] + P[3][19]*SH_MAG[2] - P[16][19]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) - (2*magD*q0 - 2*magE*q1 + 2*magN*q2)*(P[19][2] + P[1][2]*SH_MAG[0] + P[3][2]*SH_MAG[2] - P[16][2]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][2]*(2*q0*q3 + 2*q1*q2) - P[18][2]*(2*q0*q2 - 2*q1*q3) - P[2][2]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + P[0][2]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + (SH_MAG[7] + SH_MAG[8] - 2*magD*q2)*(P[19][0] + P[1][0]*SH_MAG[0] + P[3][0]*SH_MAG[2] - P[16][0]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][0]*(2*q0*q3 + 2*q1*q2) - P[18][0]*(2*q0*q2 - 2*q1*q3) - P[2][0]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + P[0][0]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + SH_MAG[0]*(P[19][1] + P[1][1]*SH_MAG[0] + P[3][1]*SH_MAG[2] - P[16][1]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][1]*(2*q0*q3 + 2*q1*q2) - P[18][1]*(2*q0*q2 - 2*q1*q3) - P[2][1]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + P[0][1]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + SH_MAG[2]*(P[19][3] + P[1][3]*SH_MAG[0] + P[3][3]*SH_MAG[2] - P[16][3]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][3]*(2*q0*q3 + 2*q1*q2) - P[18][3]*(2*q0*q2 - 2*q1*q3) - P[2][3]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + P[0][3]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) - (SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6])*(P[19][16] + P[1][16]*SH_MAG[0] + P[3][16]*SH_MAG[2] - P[16][16]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][16]*(2*q0*q3 + 2*q1*q2) - P[18][16]*(2*q0*q2 - 2*q1*q3) - P[2][16]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + P[0][16]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + P[17][19]*(2*q0*q3 + 2*q1*q2) - P[18][19]*(2*q0*q2 - 2*q1*q3) - P[2][19]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + (2*q0*q3 + 2*q1*q2)*(P[19][17] + P[1][17]*SH_MAG[0] + P[3][17]*SH_MAG[2] - P[16][17]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][17]*(2*q0*q3 + 2*q1*q2) - P[18][17]*(2*q0*q2 - 2*q1*q3) - P[2][17]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + P[0][17]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) - (2*q0*q2 - 2*q1*q3)*(P[19][18] + P[1][18]*SH_MAG[0] + P[3][18]*SH_MAG[2] - P[16][18]*(SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6]) + P[17][18]*(2*q0*q3 + 2*q1*q2) - P[18][18]*(2*q0*q2 - 2*q1*q3) - P[2][18]*(2*magD*q0 - 2*magE*q1 + 2*magN*q2) + P[0][18]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + P[0][19]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2));\n            if (temp >= R_MAG) {\n                SK_MX[0] = 1.0f / temp;\n            } else {\n                // the calculation is badly conditioned, so we cannot perform fusion on this step\n                // we increase the state variances and try again next time\n                P[19][19] += 0.1f*R_MAG;\n                obsIndex = 1;\n                return;\n            }\n            SK_MX[1] = SH_MAG[3] + SH_MAG[4] - SH_MAG[5] - SH_MAG[6];\n            SK_MX[2] = 2*magD*q0 - 2*magE*q1 + 2*magN*q2;\n            SK_MX[3] = SH_MAG[7] + SH_MAG[8] - 2*magD*q2;\n            SK_MX[4] = 2*q0*q2 - 2*q1*q3;\n            SK_MX[5] = 2*q0*q3 + 2*q1*q2;\n            Kfusion[0] = SK_MX[0]*(P[0][19] + P[0][1]*SH_MAG[0] + P[0][3]*SH_MAG[2] + P[0][0]*SK_MX[3] - P[0][2]*SK_MX[2] - P[0][16]*SK_MX[1] + P[0][17]*SK_MX[5] - P[0][18]*SK_MX[4]);\n            Kfusion[1] = SK_MX[0]*(P[1][19] + P[1][1]*SH_MAG[0] + P[1][3]*SH_MAG[2] + P[1][0]*SK_MX[3] - P[1][2]*SK_MX[2] - P[1][16]*SK_MX[1] + P[1][17]*SK_MX[5] - P[1][18]*SK_MX[4]);\n            Kfusion[2] = SK_MX[0]*(P[2][19] + P[2][1]*SH_MAG[0] + P[2][3]*SH_MAG[2] + P[2][0]*SK_MX[3] - P[2][2]*SK_MX[2] - P[2][16]*SK_MX[1] + P[2][17]*SK_MX[5] - P[2][18]*SK_MX[4]);\n            Kfusion[3] = SK_MX[0]*(P[3][19] + P[3][1]*SH_MAG[0] + P[3][3]*SH_MAG[2] + P[3][0]*SK_MX[3] - P[3][2]*SK_MX[2] - P[3][16]*SK_MX[1] + P[3][17]*SK_MX[5] - P[3][18]*SK_MX[4]);\n            Kfusion[4] = SK_MX[0]*(P[4][19] + P[4][1]*SH_MAG[0] + P[4][3]*SH_MAG[2] + P[4][0]*SK_MX[3] - P[4][2]*SK_MX[2] - P[4][16]*SK_MX[1] + P[4][17]*SK_MX[5] - P[4][18]*SK_MX[4]);\n            Kfusion[5] = SK_MX[0]*(P[5][19] + P[5][1]*SH_MAG[0] + P[5][3]*SH_MAG[2] + P[5][0]*SK_MX[3] - P[5][2]*SK_MX[2] - P[5][16]*SK_MX[1] + P[5][17]*SK_MX[5] - P[5][18]*SK_MX[4]);\n            Kfusion[6] = SK_MX[0]*(P[6][19] + P[6][1]*SH_MAG[0] + P[6][3]*SH_MAG[2] + P[6][0]*SK_MX[3] - P[6][2]*SK_MX[2] - P[6][16]*SK_MX[1] + P[6][17]*SK_MX[5] - P[6][18]*SK_MX[4]);\n            Kfusion[7] = SK_MX[0]*(P[7][19] + P[7][1]*SH_MAG[0] + P[7][3]*SH_MAG[2] + P[7][0]*SK_MX[3] - P[7][2]*SK_MX[2] - P[7][16]*SK_MX[1] + P[7][17]*SK_MX[5] - P[7][18]*SK_MX[4]);\n            Kfusion[8] = SK_MX[0]*(P[8][19] + P[8][1]*SH_MAG[0] + P[8][3]*SH_MAG[2] + P[8][0]*SK_MX[3] - P[8][2]*SK_MX[2] - P[8][16]*SK_MX[1] + P[8][17]*SK_MX[5] - P[8][18]*SK_MX[4]);\n            Kfusion[9] = SK_MX[0]*(P[9][19] + P[9][1]*SH_MAG[0] + P[9][3]*SH_MAG[2] + P[9][0]*SK_MX[3] - P[9][2]*SK_MX[2] - P[9][16]*SK_MX[1] + P[9][17]*SK_MX[5] - P[9][18]*SK_MX[4]);\n            Kfusion[10] = SK_MX[0]*(P[10][19] + P[10][1]*SH_MAG[0] + P[10][3]*SH_MAG[2] + P[10][0]*SK_MX[3] - P[10][2]*SK_MX[2] - P[10][16]*SK_MX[1] + P[10][17]*SK_MX[5] - P[10][18]*SK_MX[4]);\n            Kfusion[11] = SK_MX[0]*(P[11][19] + P[11][1]*SH_MAG[0] + P[11][3]*SH_MAG[2] + P[11][0]*SK_MX[3] - P[11][2]*SK_MX[2] - P[11][16]*SK_MX[1] + P[11][17]*SK_MX[5] - P[11][18]*SK_MX[4]);\n            Kfusion[12] = SK_MX[0]*(P[12][19] + P[12][1]*SH_MAG[0] + P[12][3]*SH_MAG[2] + P[12][0]*SK_MX[3] - P[12][2]*SK_MX[2] - P[12][16]*SK_MX[1] + P[12][17]*SK_MX[5] - P[12][18]*SK_MX[4]);\n            // Only height measurements are allowed to modify the Z delta velocity bias state. This improves the stability of the estimate\n            Kfusion[13] = 0.0f;//SK_MX[0]*(P[13][19] + P[13][1]*SH_MAG[0] + P[13][3]*SH_MAG[2] + P[13][0]*SK_MX[3] - P[13][2]*SK_MX[2] - P[13][16]*SK_MX[1] + P[13][17]*SK_MX[5] - P[13][18]*SK_MX[4]);\n            // Estimation of selected states is inhibited by setting their Kalman gains to zero\n            if (!inhibitWindStates) {\n                Kfusion[14] = SK_MX[0]*(P[14][19] + P[14][1]*SH_MAG[0] + P[14][3]*SH_MAG[2] + P[14][0]*SK_MX[3] - P[14][2]*SK_MX[2] - P[14][16]*SK_MX[1] + P[14][17]*SK_MX[5] - P[14][18]*SK_MX[4]);\n                Kfusion[15] = SK_MX[0]*(P[15][19] + P[15][1]*SH_MAG[0] + P[15][3]*SH_MAG[2] + P[15][0]*SK_MX[3] - P[15][2]*SK_MX[2] - P[15][16]*SK_MX[1] + P[15][17]*SK_MX[5] - P[15][18]*SK_MX[4]);\n            } else {\n                Kfusion[14] = 0;\n                Kfusion[15] = 0;\n            }\n            if (!inhibitMagStates) {\n                Kfusion[16] = SK_MX[0]*(P[16][19] + P[16][1]*SH_MAG[0] + P[16][3]*SH_MAG[2] + P[16][0]*SK_MX[3] - P[16][2]*SK_MX[2] - P[16][16]*SK_MX[1] + P[16][17]*SK_MX[5] - P[16][18]*SK_MX[4]);\n                Kfusion[17] = SK_MX[0]*(P[17][19] + P[17][1]*SH_MAG[0] + P[17][3]*SH_MAG[2] + P[17][0]*SK_MX[3] - P[17][2]*SK_MX[2] - P[17][16]*SK_MX[1] + P[17][17]*SK_MX[5] - P[17][18]*SK_MX[4]);\n                Kfusion[18] = SK_MX[0]*(P[18][19] + P[18][1]*SH_MAG[0] + P[18][3]*SH_MAG[2] + P[18][0]*SK_MX[3] - P[18][2]*SK_MX[2] - P[18][16]*SK_MX[1] + P[18][17]*SK_MX[5] - P[18][18]*SK_MX[4]);\n                Kfusion[19] = SK_MX[0]*(P[19][19] + P[19][1]*SH_MAG[0] + P[19][3]*SH_MAG[2] + P[19][0]*SK_MX[3] - P[19][2]*SK_MX[2] - P[19][16]*SK_MX[1] + P[19][17]*SK_MX[5] - P[19][18]*SK_MX[4]);\n                Kfusion[20] = SK_MX[0]*(P[20][19] + P[20][1]*SH_MAG[0] + P[20][3]*SH_MAG[2] + P[20][0]*SK_MX[3] - P[20][2]*SK_MX[2] - P[20][16]*SK_MX[1] + P[20][17]*SK_MX[5] - P[20][18]*SK_MX[4]);\n                Kfusion[21] = SK_MX[0]*(P[21][19] + P[21][1]*SH_MAG[0] + P[21][3]*SH_MAG[2] + P[21][0]*SK_MX[3] - P[21][2]*SK_MX[2] - P[21][16]*SK_MX[1] + P[21][17]*SK_MX[5] - P[21][18]*SK_MX[4]);\n            } else {\n                for (uint8_t i=16; i < EKF_STATE_ESTIMATES; i++) {\n                    Kfusion[i] = 0;\n                }\n            }\n            varInnovMag[0] = 1.0f/SK_MX[0];\n            innovMag[0] = MagPred[0] - magData.x;\n        }\n        else if (obsIndex == 1) // we are now fusing the Y measurement\n        {\n            // Calculate observation jacobians\n            for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++) H_MAG[i] = 0;\n            H_MAG[0] = SH_MAG[2];\n            H_MAG[1] = SH_MAG[1];\n            H_MAG[2] = SH_MAG[0];\n            H_MAG[3] = 2*magD*q2 - SH_MAG[8] - SH_MAG[7];\n            H_MAG[16] = 2*q1*q2 - 2*q0*q3;\n            H_MAG[17] = SH_MAG[4] - SH_MAG[3] - SH_MAG[5] + SH_MAG[6];\n            H_MAG[18] = 2*q0*q1 + 2*q2*q3;\n            H_MAG[20] = 1;\n\n            // Calculate Kalman gain\n            float temp = (P[20][20] + R_MAG + P[0][20]*SH_MAG[2] + P[1][20]*SH_MAG[1] + P[2][20]*SH_MAG[0] - P[17][20]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - (2*q0*q3 - 2*q1*q2)*(P[20][16] + P[0][16]*SH_MAG[2] + P[1][16]*SH_MAG[1] + P[2][16]*SH_MAG[0] - P[17][16]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][16]*(2*q0*q3 - 2*q1*q2) + P[18][16]*(2*q0*q1 + 2*q2*q3) - P[3][16]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + (2*q0*q1 + 2*q2*q3)*(P[20][18] + P[0][18]*SH_MAG[2] + P[1][18]*SH_MAG[1] + P[2][18]*SH_MAG[0] - P[17][18]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][18]*(2*q0*q3 - 2*q1*q2) + P[18][18]*(2*q0*q1 + 2*q2*q3) - P[3][18]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) - (SH_MAG[7] + SH_MAG[8] - 2*magD*q2)*(P[20][3] + P[0][3]*SH_MAG[2] + P[1][3]*SH_MAG[1] + P[2][3]*SH_MAG[0] - P[17][3]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][3]*(2*q0*q3 - 2*q1*q2) + P[18][3]*(2*q0*q1 + 2*q2*q3) - P[3][3]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) - P[16][20]*(2*q0*q3 - 2*q1*q2) + P[18][20]*(2*q0*q1 + 2*q2*q3) + SH_MAG[2]*(P[20][0] + P[0][0]*SH_MAG[2] + P[1][0]*SH_MAG[1] + P[2][0]*SH_MAG[0] - P[17][0]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][0]*(2*q0*q3 - 2*q1*q2) + P[18][0]*(2*q0*q1 + 2*q2*q3) - P[3][0]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + SH_MAG[1]*(P[20][1] + P[0][1]*SH_MAG[2] + P[1][1]*SH_MAG[1] + P[2][1]*SH_MAG[0] - P[17][1]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][1]*(2*q0*q3 - 2*q1*q2) + P[18][1]*(2*q0*q1 + 2*q2*q3) - P[3][1]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + SH_MAG[0]*(P[20][2] + P[0][2]*SH_MAG[2] + P[1][2]*SH_MAG[1] + P[2][2]*SH_MAG[0] - P[17][2]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][2]*(2*q0*q3 - 2*q1*q2) + P[18][2]*(2*q0*q1 + 2*q2*q3) - P[3][2]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) - (SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6])*(P[20][17] + P[0][17]*SH_MAG[2] + P[1][17]*SH_MAG[1] + P[2][17]*SH_MAG[0] - P[17][17]*(SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6]) - P[16][17]*(2*q0*q3 - 2*q1*q2) + P[18][17]*(2*q0*q1 + 2*q2*q3) - P[3][17]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) - P[3][20]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2));\n            if (temp >= R_MAG) {\n                SK_MY[0] = 1.0f / temp;\n            } else {\n                // the calculation is badly conditioned, so we cannot perform fusion on this step\n                // we increase the state variances and try again next time\n                P[20][20] += 0.1f*R_MAG;\n                obsIndex = 2;\n                return;\n            }\n            SK_MY[1] = SH_MAG[3] - SH_MAG[4] + SH_MAG[5] - SH_MAG[6];\n            SK_MY[2] = SH_MAG[7] + SH_MAG[8] - 2*magD*q2;\n            SK_MY[3] = 2*q0*q3 - 2*q1*q2;\n            SK_MY[4] = 2*q0*q1 + 2*q2*q3;\n            Kfusion[0] = SK_MY[0]*(P[0][20] + P[0][0]*SH_MAG[2] + P[0][1]*SH_MAG[1] + P[0][2]*SH_MAG[0] - P[0][3]*SK_MY[2] - P[0][17]*SK_MY[1] - P[0][16]*SK_MY[3] + P[0][18]*SK_MY[4]);\n            Kfusion[1] = SK_MY[0]*(P[1][20] + P[1][0]*SH_MAG[2] + P[1][1]*SH_MAG[1] + P[1][2]*SH_MAG[0] - P[1][3]*SK_MY[2] - P[1][17]*SK_MY[1] - P[1][16]*SK_MY[3] + P[1][18]*SK_MY[4]);\n            Kfusion[2] = SK_MY[0]*(P[2][20] + P[2][0]*SH_MAG[2] + P[2][1]*SH_MAG[1] + P[2][2]*SH_MAG[0] - P[2][3]*SK_MY[2] - P[2][17]*SK_MY[1] - P[2][16]*SK_MY[3] + P[2][18]*SK_MY[4]);\n            Kfusion[3] = SK_MY[0]*(P[3][20] + P[3][0]*SH_MAG[2] + P[3][1]*SH_MAG[1] + P[3][2]*SH_MAG[0] - P[3][3]*SK_MY[2] - P[3][17]*SK_MY[1] - P[3][16]*SK_MY[3] + P[3][18]*SK_MY[4]);\n            Kfusion[4] = SK_MY[0]*(P[4][20] + P[4][0]*SH_MAG[2] + P[4][1]*SH_MAG[1] + P[4][2]*SH_MAG[0] - P[4][3]*SK_MY[2] - P[4][17]*SK_MY[1] - P[4][16]*SK_MY[3] + P[4][18]*SK_MY[4]);\n            Kfusion[5] = SK_MY[0]*(P[5][20] + P[5][0]*SH_MAG[2] + P[5][1]*SH_MAG[1] + P[5][2]*SH_MAG[0] - P[5][3]*SK_MY[2] - P[5][17]*SK_MY[1] - P[5][16]*SK_MY[3] + P[5][18]*SK_MY[4]);\n            Kfusion[6] = SK_MY[0]*(P[6][20] + P[6][0]*SH_MAG[2] + P[6][1]*SH_MAG[1] + P[6][2]*SH_MAG[0] - P[6][3]*SK_MY[2] - P[6][17]*SK_MY[1] - P[6][16]*SK_MY[3] + P[6][18]*SK_MY[4]);\n            Kfusion[7] = SK_MY[0]*(P[7][20] + P[7][0]*SH_MAG[2] + P[7][1]*SH_MAG[1] + P[7][2]*SH_MAG[0] - P[7][3]*SK_MY[2] - P[7][17]*SK_MY[1] - P[7][16]*SK_MY[3] + P[7][18]*SK_MY[4]);\n            Kfusion[8] = SK_MY[0]*(P[8][20] + P[8][0]*SH_MAG[2] + P[8][1]*SH_MAG[1] + P[8][2]*SH_MAG[0] - P[8][3]*SK_MY[2] - P[8][17]*SK_MY[1] - P[8][16]*SK_MY[3] + P[8][18]*SK_MY[4]);\n            Kfusion[9] = SK_MY[0]*(P[9][20] + P[9][0]*SH_MAG[2] + P[9][1]*SH_MAG[1] + P[9][2]*SH_MAG[0] - P[9][3]*SK_MY[2] - P[9][17]*SK_MY[1] - P[9][16]*SK_MY[3] + P[9][18]*SK_MY[4]);\n            Kfusion[10] = SK_MY[0]*(P[10][20] + P[10][0]*SH_MAG[2] + P[10][1]*SH_MAG[1] + P[10][2]*SH_MAG[0] - P[10][3]*SK_MY[2] - P[10][17]*SK_MY[1] - P[10][16]*SK_MY[3] + P[10][18]*SK_MY[4]);\n            Kfusion[11] = SK_MY[0]*(P[11][20] + P[11][0]*SH_MAG[2] + P[11][1]*SH_MAG[1] + P[11][2]*SH_MAG[0] - P[11][3]*SK_MY[2] - P[11][17]*SK_MY[1] - P[11][16]*SK_MY[3] + P[11][18]*SK_MY[4]);\n            Kfusion[12] = SK_MY[0]*(P[12][20] + P[12][0]*SH_MAG[2] + P[12][1]*SH_MAG[1] + P[12][2]*SH_MAG[0] - P[12][3]*SK_MY[2] - P[12][17]*SK_MY[1] - P[12][16]*SK_MY[3] + P[12][18]*SK_MY[4]);\n            // Only height measurements are allowed to modify the Z delta velocity bias state. This improves the stability of the estimate\n            Kfusion[13] = 0.0f;//SK_MY[0]*(P[13][20] + P[13][0]*SH_MAG[2] + P[13][1]*SH_MAG[1] + P[13][2]*SH_MAG[0] - P[13][3]*SK_MY[2] - P[13][17]*SK_MY[1] - P[13][16]*SK_MY[3] + P[13][18]*SK_MY[4]);\n            // Estimation of selected states is inhibited by setting their Kalman gains to zero\n            if (!inhibitWindStates) {\n                Kfusion[14] = SK_MY[0]*(P[14][20] + P[14][0]*SH_MAG[2] + P[14][1]*SH_MAG[1] + P[14][2]*SH_MAG[0] - P[14][3]*SK_MY[2] - P[14][17]*SK_MY[1] - P[14][16]*SK_MY[3] + P[14][18]*SK_MY[4]);\n                Kfusion[15] = SK_MY[0]*(P[15][20] + P[15][0]*SH_MAG[2] + P[15][1]*SH_MAG[1] + P[15][2]*SH_MAG[0] - P[15][3]*SK_MY[2] - P[15][17]*SK_MY[1] - P[15][16]*SK_MY[3] + P[15][18]*SK_MY[4]);\n            } else {\n                Kfusion[14] = 0;\n                Kfusion[15] = 0;\n            }\n            if (!inhibitMagStates) {\n                Kfusion[16] = SK_MY[0]*(P[16][20] + P[16][0]*SH_MAG[2] + P[16][1]*SH_MAG[1] + P[16][2]*SH_MAG[0] - P[16][3]*SK_MY[2] - P[16][17]*SK_MY[1] - P[16][16]*SK_MY[3] + P[16][18]*SK_MY[4]);\n                Kfusion[17] = SK_MY[0]*(P[17][20] + P[17][0]*SH_MAG[2] + P[17][1]*SH_MAG[1] + P[17][2]*SH_MAG[0] - P[17][3]*SK_MY[2] - P[17][17]*SK_MY[1] - P[17][16]*SK_MY[3] + P[17][18]*SK_MY[4]);\n                Kfusion[18] = SK_MY[0]*(P[18][20] + P[18][0]*SH_MAG[2] + P[18][1]*SH_MAG[1] + P[18][2]*SH_MAG[0] - P[18][3]*SK_MY[2] - P[18][17]*SK_MY[1] - P[18][16]*SK_MY[3] + P[18][18]*SK_MY[4]);\n                Kfusion[19] = SK_MY[0]*(P[19][20] + P[19][0]*SH_MAG[2] + P[19][1]*SH_MAG[1] + P[19][2]*SH_MAG[0] - P[19][3]*SK_MY[2] - P[19][17]*SK_MY[1] - P[19][16]*SK_MY[3] + P[19][18]*SK_MY[4]);\n                Kfusion[20] = SK_MY[0]*(P[20][20] + P[20][0]*SH_MAG[2] + P[20][1]*SH_MAG[1] + P[20][2]*SH_MAG[0] - P[20][3]*SK_MY[2] - P[20][17]*SK_MY[1] - P[20][16]*SK_MY[3] + P[20][18]*SK_MY[4]);\n                Kfusion[21] = SK_MY[0]*(P[21][20] + P[21][0]*SH_MAG[2] + P[21][1]*SH_MAG[1] + P[21][2]*SH_MAG[0] - P[21][3]*SK_MY[2] - P[21][17]*SK_MY[1] - P[21][16]*SK_MY[3] + P[21][18]*SK_MY[4]);\n            } else {\n                Kfusion[16] = 0;\n                Kfusion[17] = 0;\n                Kfusion[18] = 0;\n                Kfusion[19] = 0;\n                Kfusion[20] = 0;\n                Kfusion[21] = 0;\n            }\n            varInnovMag[1] = 1.0f/SK_MY[0];\n            innovMag[1] = MagPred[1] - magData.y;\n        }\n        else if (obsIndex == 2) // we are now fusing the Z measurement\n        {\n            // Calculate observation jacobians\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++) H_MAG[i] = 0;\n            H_MAG[0] = SH_MAG[1];\n            H_MAG[1] = 2*magN*q3 - 2*magE*q0 - 2*magD*q1;\n            H_MAG[2] = SH_MAG[7] + SH_MAG[8] - 2*magD*q2;\n            H_MAG[3] = SH_MAG[0];\n            H_MAG[16] = 2*q0*q2 + 2*q1*q3;\n            H_MAG[17] = 2*q2*q3 - 2*q0*q1;\n            H_MAG[18] = SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6];\n            H_MAG[21] = 1;\n\n            // Calculate Kalman gain\n            float temp = (P[21][21] + R_MAG + P[0][21]*SH_MAG[1] + P[3][21]*SH_MAG[0] + P[18][21]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) - (2*magD*q1 + 2*magE*q0 - 2*magN*q3)*(P[21][1] + P[0][1]*SH_MAG[1] + P[3][1]*SH_MAG[0] + P[18][1]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][1]*(2*q0*q2 + 2*q1*q3) - P[17][1]*(2*q0*q1 - 2*q2*q3) - P[1][1]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + P[2][1]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + (SH_MAG[7] + SH_MAG[8] - 2*magD*q2)*(P[21][2] + P[0][2]*SH_MAG[1] + P[3][2]*SH_MAG[0] + P[18][2]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][2]*(2*q0*q2 + 2*q1*q3) - P[17][2]*(2*q0*q1 - 2*q2*q3) - P[1][2]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + P[2][2]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + SH_MAG[1]*(P[21][0] + P[0][0]*SH_MAG[1] + P[3][0]*SH_MAG[0] + P[18][0]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][0]*(2*q0*q2 + 2*q1*q3) - P[17][0]*(2*q0*q1 - 2*q2*q3) - P[1][0]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + P[2][0]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + SH_MAG[0]*(P[21][3] + P[0][3]*SH_MAG[1] + P[3][3]*SH_MAG[0] + P[18][3]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][3]*(2*q0*q2 + 2*q1*q3) - P[17][3]*(2*q0*q1 - 2*q2*q3) - P[1][3]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + P[2][3]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + (SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6])*(P[21][18] + P[0][18]*SH_MAG[1] + P[3][18]*SH_MAG[0] + P[18][18]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][18]*(2*q0*q2 + 2*q1*q3) - P[17][18]*(2*q0*q1 - 2*q2*q3) - P[1][18]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + P[2][18]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + P[16][21]*(2*q0*q2 + 2*q1*q3) - P[17][21]*(2*q0*q1 - 2*q2*q3) - P[1][21]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + (2*q0*q2 + 2*q1*q3)*(P[21][16] + P[0][16]*SH_MAG[1] + P[3][16]*SH_MAG[0] + P[18][16]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][16]*(2*q0*q2 + 2*q1*q3) - P[17][16]*(2*q0*q1 - 2*q2*q3) - P[1][16]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + P[2][16]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) - (2*q0*q1 - 2*q2*q3)*(P[21][17] + P[0][17]*SH_MAG[1] + P[3][17]*SH_MAG[0] + P[18][17]*(SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6]) + P[16][17]*(2*q0*q2 + 2*q1*q3) - P[17][17]*(2*q0*q1 - 2*q2*q3) - P[1][17]*(2*magD*q1 + 2*magE*q0 - 2*magN*q3) + P[2][17]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2)) + P[2][21]*(SH_MAG[7] + SH_MAG[8] - 2*magD*q2));\n            if (temp >= R_MAG) {\n                SK_MZ[0] = 1.0f / temp;\n            } else {\n                // the calculation is badly conditioned, so we cannot perform fusion on this step\n                // we increase the state variances and try again next time\n                P[21][21] += 0.1f*R_MAG;\n                obsIndex = 3;\n                return;\n            }\n            SK_MZ[1] = SH_MAG[3] - SH_MAG[4] - SH_MAG[5] + SH_MAG[6];\n            SK_MZ[2] = 2*magD*q1 + 2*magE*q0 - 2*magN*q3;\n            SK_MZ[3] = SH_MAG[7] + SH_MAG[8] - 2*magD*q2;\n            SK_MZ[4] = 2*q0*q1 - 2*q2*q3;\n            SK_MZ[5] = 2*q0*q2 + 2*q1*q3;\n            Kfusion[0] = SK_MZ[0]*(P[0][21] + P[0][0]*SH_MAG[1] + P[0][3]*SH_MAG[0] - P[0][1]*SK_MZ[2] + P[0][2]*SK_MZ[3] + P[0][18]*SK_MZ[1] + P[0][16]*SK_MZ[5] - P[0][17]*SK_MZ[4]);\n            Kfusion[1] = SK_MZ[0]*(P[1][21] + P[1][0]*SH_MAG[1] + P[1][3]*SH_MAG[0] - P[1][1]*SK_MZ[2] + P[1][2]*SK_MZ[3] + P[1][18]*SK_MZ[1] + P[1][16]*SK_MZ[5] - P[1][17]*SK_MZ[4]);\n            Kfusion[2] = SK_MZ[0]*(P[2][21] + P[2][0]*SH_MAG[1] + P[2][3]*SH_MAG[0] - P[2][1]*SK_MZ[2] + P[2][2]*SK_MZ[3] + P[2][18]*SK_MZ[1] + P[2][16]*SK_MZ[5] - P[2][17]*SK_MZ[4]);\n            Kfusion[3] = SK_MZ[0]*(P[3][21] + P[3][0]*SH_MAG[1] + P[3][3]*SH_MAG[0] - P[3][1]*SK_MZ[2] + P[3][2]*SK_MZ[3] + P[3][18]*SK_MZ[1] + P[3][16]*SK_MZ[5] - P[3][17]*SK_MZ[4]);\n            Kfusion[4] = SK_MZ[0]*(P[4][21] + P[4][0]*SH_MAG[1] + P[4][3]*SH_MAG[0] - P[4][1]*SK_MZ[2] + P[4][2]*SK_MZ[3] + P[4][18]*SK_MZ[1] + P[4][16]*SK_MZ[5] - P[4][17]*SK_MZ[4]);\n            Kfusion[5] = SK_MZ[0]*(P[5][21] + P[5][0]*SH_MAG[1] + P[5][3]*SH_MAG[0] - P[5][1]*SK_MZ[2] + P[5][2]*SK_MZ[3] + P[5][18]*SK_MZ[1] + P[5][16]*SK_MZ[5] - P[5][17]*SK_MZ[4]);\n            Kfusion[6] = SK_MZ[0]*(P[6][21] + P[6][0]*SH_MAG[1] + P[6][3]*SH_MAG[0] - P[6][1]*SK_MZ[2] + P[6][2]*SK_MZ[3] + P[6][18]*SK_MZ[1] + P[6][16]*SK_MZ[5] - P[6][17]*SK_MZ[4]);\n            Kfusion[7] = SK_MZ[0]*(P[7][21] + P[7][0]*SH_MAG[1] + P[7][3]*SH_MAG[0] - P[7][1]*SK_MZ[2] + P[7][2]*SK_MZ[3] + P[7][18]*SK_MZ[1] + P[7][16]*SK_MZ[5] - P[7][17]*SK_MZ[4]);\n            Kfusion[8] = SK_MZ[0]*(P[8][21] + P[8][0]*SH_MAG[1] + P[8][3]*SH_MAG[0] - P[8][1]*SK_MZ[2] + P[8][2]*SK_MZ[3] + P[8][18]*SK_MZ[1] + P[8][16]*SK_MZ[5] - P[8][17]*SK_MZ[4]);\n            Kfusion[9] = SK_MZ[0]*(P[9][21] + P[9][0]*SH_MAG[1] + P[9][3]*SH_MAG[0] - P[9][1]*SK_MZ[2] + P[9][2]*SK_MZ[3] + P[9][18]*SK_MZ[1] + P[9][16]*SK_MZ[5] - P[9][17]*SK_MZ[4]);\n            Kfusion[10] = SK_MZ[0]*(P[10][21] + P[10][0]*SH_MAG[1] + P[10][3]*SH_MAG[0] - P[10][1]*SK_MZ[2] + P[10][2]*SK_MZ[3] + P[10][18]*SK_MZ[1] + P[10][16]*SK_MZ[5] - P[10][17]*SK_MZ[4]);\n            Kfusion[11] = SK_MZ[0]*(P[11][21] + P[11][0]*SH_MAG[1] + P[11][3]*SH_MAG[0] - P[11][1]*SK_MZ[2] + P[11][2]*SK_MZ[3] + P[11][18]*SK_MZ[1] + P[11][16]*SK_MZ[5] - P[11][17]*SK_MZ[4]);\n            Kfusion[12] = SK_MZ[0]*(P[12][21] + P[12][0]*SH_MAG[1] + P[12][3]*SH_MAG[0] - P[12][1]*SK_MZ[2] + P[12][2]*SK_MZ[3] + P[12][18]*SK_MZ[1] + P[12][16]*SK_MZ[5] - P[12][17]*SK_MZ[4]);\n            // Only height measurements are allowed to modify the Z delta velocity bias state. This improves the stability of the estimate\n            Kfusion[13] = 0.0f;//SK_MZ[0]*(P[13][21] + P[13][0]*SH_MAG[1] + P[13][3]*SH_MAG[0] - P[13][1]*SK_MZ[2] + P[13][2]*SK_MZ[3] + P[13][18]*SK_MZ[1] + P[13][16]*SK_MZ[5] - P[13][17]*SK_MZ[4]);\n            // Estimation of selected states is inhibited by setting their Kalman gains to zero\n            if (!inhibitWindStates) {\n                Kfusion[14] = SK_MZ[0]*(P[14][21] + P[14][0]*SH_MAG[1] + P[14][3]*SH_MAG[0] - P[14][1]*SK_MZ[2] + P[14][2]*SK_MZ[3] + P[14][18]*SK_MZ[1] + P[14][16]*SK_MZ[5] - P[14][17]*SK_MZ[4]);\n                Kfusion[15] = SK_MZ[0]*(P[15][21] + P[15][0]*SH_MAG[1] + P[15][3]*SH_MAG[0] - P[15][1]*SK_MZ[2] + P[15][2]*SK_MZ[3] + P[15][18]*SK_MZ[1] + P[15][16]*SK_MZ[5] - P[15][17]*SK_MZ[4]);\n            } else {\n                Kfusion[14] = 0;\n                Kfusion[15] = 0;\n            }\n            if (!inhibitMagStates) {\n                Kfusion[16] = SK_MZ[0]*(P[16][21] + P[16][0]*SH_MAG[1] + P[16][3]*SH_MAG[0] - P[16][1]*SK_MZ[2] + P[16][2]*SK_MZ[3] + P[16][18]*SK_MZ[1] + P[16][16]*SK_MZ[5] - P[16][17]*SK_MZ[4]);\n                Kfusion[17] = SK_MZ[0]*(P[17][21] + P[17][0]*SH_MAG[1] + P[17][3]*SH_MAG[0] - P[17][1]*SK_MZ[2] + P[17][2]*SK_MZ[3] + P[17][18]*SK_MZ[1] + P[17][16]*SK_MZ[5] - P[17][17]*SK_MZ[4]);\n                Kfusion[18] = SK_MZ[0]*(P[18][21] + P[18][0]*SH_MAG[1] + P[18][3]*SH_MAG[0] - P[18][1]*SK_MZ[2] + P[18][2]*SK_MZ[3] + P[18][18]*SK_MZ[1] + P[18][16]*SK_MZ[5] - P[18][17]*SK_MZ[4]);\n                Kfusion[19] = SK_MZ[0]*(P[19][21] + P[19][0]*SH_MAG[1] + P[19][3]*SH_MAG[0] - P[19][1]*SK_MZ[2] + P[19][2]*SK_MZ[3] + P[19][18]*SK_MZ[1] + P[19][16]*SK_MZ[5] - P[19][17]*SK_MZ[4]);\n                Kfusion[20] = SK_MZ[0]*(P[20][21] + P[20][0]*SH_MAG[1] + P[20][3]*SH_MAG[0] - P[20][1]*SK_MZ[2] + P[20][2]*SK_MZ[3] + P[20][18]*SK_MZ[1] + P[20][16]*SK_MZ[5] - P[20][17]*SK_MZ[4]);\n                Kfusion[21] = SK_MZ[0]*(P[21][21] + P[21][0]*SH_MAG[1] + P[21][3]*SH_MAG[0] - P[21][1]*SK_MZ[2] + P[21][2]*SK_MZ[3] + P[21][18]*SK_MZ[1] + P[21][16]*SK_MZ[5] - P[21][17]*SK_MZ[4]);\n            } else {\n                Kfusion[16] = 0;\n                Kfusion[17] = 0;\n                Kfusion[18] = 0;\n                Kfusion[19] = 0;\n                Kfusion[20] = 0;\n                Kfusion[21] = 0;\n            }\n            varInnovMag[2] = 1.0f/SK_MZ[0];\n            innovMag[2] = MagPred[2] - magData.z;\n\n        }\n\n        // Check the innovation for consistency and don't fuse if > 5Sigma\n        if ((innovMag[obsIndex]*innovMag[obsIndex]/varInnovMag[obsIndex]) < 25.0f)\n        {\n            // correct the state vector\n            for (uint8_t j= 0; j < EKF_STATE_ESTIMATES; j++)\n            {\n                states[j] = states[j] - Kfusion[j] * innovMag[obsIndex];\n            }\n            // normalise the quaternion states\n            float quatMag = sqrtf(states[0]*states[0] + states[1]*states[1] + states[2]*states[2] + states[3]*states[3]);\n            if (quatMag > 1e-12f)\n            {\n                for (uint8_t j= 0; j<=3; j++)\n                {\n                    float quatMagInv = 1.0f/quatMag;\n                    states[j] = states[j] * quatMagInv;\n                }\n            }\n            // correct the covariance P = (I - K*H)*P\n            // take advantage of the empty columns in KH to reduce the\n            // number of operations\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n            {\n                for (uint8_t j = 0; j <= 3; j++)\n                {\n                    KH[i][j] = Kfusion[i] * H_MAG[j];\n                }\n                for (uint8_t j = 4; j <= 15; j++) KH[i][j] = 0.0f;\n                if (!_onGround)\n                {\n                    for (uint8_t j = 16; j < EKF_STATE_ESTIMATES; j++)\n                    {\n                        KH[i][j] = Kfusion[i] * H_MAG[j];\n                    }\n                }\n                else\n                {\n                    for (uint8_t j = 16; j < EKF_STATE_ESTIMATES; j++)\n                    {\n                        KH[i][j] = 0.0f;\n                    }\n                }\n            }\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n            {\n                for (uint8_t j = 0; j < EKF_STATE_ESTIMATES; j++)\n                {\n                    KHP[i][j] = 0.0f;\n                    for (uint8_t k = 0; k <= 3; k++)\n                    {\n                        KHP[i][j] = KHP[i][j] + KH[i][k] * P[k][j];\n                    }\n                    if (!_onGround)\n                    {\n                        for (uint8_t k = 16; k < EKF_STATE_ESTIMATES; k++)\n                        {\n                            KHP[i][j] = KHP[i][j] + KH[i][k] * P[k][j];\n                        }\n                    }\n                }\n            }\n        }\n        for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n        {\n            for (uint8_t j = 0; j < EKF_STATE_ESTIMATES; j++)\n            {\n                P[i][j] = P[i][j] - KHP[i][j];\n            }\n        }\n    }\n    obsIndex = obsIndex + 1;\n\n    ForceSymmetry();\n    ConstrainVariances();\n}\n\nvoid AttPosEKF::FuseAirspeed()\n{\n    float vn;\n    float ve;\n    float vd;\n    float vwn;\n    float vwe;\n    float R_TAS = sq(airspeedMeasurementSigma);\n    float SH_TAS[3];\n    float SK_TAS;\n    float VtasPred;\n\n    // Copy required states to local variable names\n    vn = statesAtVtasMeasTime[4];\n    ve = statesAtVtasMeasTime[5];\n    vd = statesAtVtasMeasTime[6];\n    vwn = statesAtVtasMeasTime[14];\n    vwe = statesAtVtasMeasTime[15];\n\n    // Need to check that it is flying before fusing airspeed data\n    // Calculate the predicted airspeed\n    VtasPred = sqrtf((ve - vwe)*(ve - vwe) + (vn - vwn)*(vn - vwn) + vd*vd);\n    // Perform fusion of True Airspeed measurement\n    if (useAirspeed && fuseVtasData && (VtasPred > 1.0f) && (VtasMeas > 8.0f))\n    {\n        // Calculate observation jacobians\n        SH_TAS[0] = 1/(sqrtf(sq(ve - vwe) + sq(vn - vwn) + sq(vd)));\n        SH_TAS[1] = (SH_TAS[0]*(2.0f*ve - 2*vwe))/2.0f;\n        SH_TAS[2] = (SH_TAS[0]*(2.0f*vn - 2*vwn))/2.0f;\n\n        float H_TAS[EKF_STATE_ESTIMATES];\n        for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++) H_TAS[i] = 0.0f;\n        H_TAS[4] = SH_TAS[2];\n        H_TAS[5] = SH_TAS[1];\n        H_TAS[6] = vd*SH_TAS[0];\n        H_TAS[14] = -SH_TAS[2];\n        H_TAS[15] = -SH_TAS[1];\n\n        // Calculate Kalman gains\n        float temp = (R_TAS + SH_TAS[2]*(P[4][4]*SH_TAS[2] + P[5][4]*SH_TAS[1] - P[14][4]*SH_TAS[2] - P[15][4]*SH_TAS[1] + P[6][4]*vd*SH_TAS[0]) + SH_TAS[1]*(P[4][5]*SH_TAS[2] + P[5][5]*SH_TAS[1] - P[14][5]*SH_TAS[2] - P[15][5]*SH_TAS[1] + P[6][5]*vd*SH_TAS[0]) - SH_TAS[2]*(P[4][14]*SH_TAS[2] + P[5][14]*SH_TAS[1] - P[14][14]*SH_TAS[2] - P[15][14]*SH_TAS[1] + P[6][14]*vd*SH_TAS[0]) - SH_TAS[1]*(P[4][15]*SH_TAS[2] + P[5][15]*SH_TAS[1] - P[14][15]*SH_TAS[2] - P[15][15]*SH_TAS[1] + P[6][15]*vd*SH_TAS[0]) + vd*SH_TAS[0]*(P[4][6]*SH_TAS[2] + P[5][6]*SH_TAS[1] - P[14][6]*SH_TAS[2] - P[15][6]*SH_TAS[1] + P[6][6]*vd*SH_TAS[0]));\n        if (temp >= R_TAS) {\n            SK_TAS = 1.0f / temp;\n        } else {\n            // the calculation is badly conditioned, so we cannot perform fusion on this step\n            // we increase the wind state variances and try again next time\n            P[14][14] += 0.05f*R_TAS;\n            P[15][15] += 0.05f*R_TAS;\n            return;\n        }\n        Kfusion[0] = SK_TAS*(P[0][4]*SH_TAS[2] - P[0][14]*SH_TAS[2] + P[0][5]*SH_TAS[1] - P[0][15]*SH_TAS[1] + P[0][6]*vd*SH_TAS[0]);\n        Kfusion[1] = SK_TAS*(P[1][4]*SH_TAS[2] - P[1][14]*SH_TAS[2] + P[1][5]*SH_TAS[1] - P[1][15]*SH_TAS[1] + P[1][6]*vd*SH_TAS[0]);\n        Kfusion[2] = SK_TAS*(P[2][4]*SH_TAS[2] - P[2][14]*SH_TAS[2] + P[2][5]*SH_TAS[1] - P[2][15]*SH_TAS[1] + P[2][6]*vd*SH_TAS[0]);\n        Kfusion[3] = SK_TAS*(P[3][4]*SH_TAS[2] - P[3][14]*SH_TAS[2] + P[3][5]*SH_TAS[1] - P[3][15]*SH_TAS[1] + P[3][6]*vd*SH_TAS[0]);\n        Kfusion[4] = SK_TAS*(P[4][4]*SH_TAS[2] - P[4][14]*SH_TAS[2] + P[4][5]*SH_TAS[1] - P[4][15]*SH_TAS[1] + P[4][6]*vd*SH_TAS[0]);\n        Kfusion[5] = SK_TAS*(P[5][4]*SH_TAS[2] - P[5][14]*SH_TAS[2] + P[5][5]*SH_TAS[1] - P[5][15]*SH_TAS[1] + P[5][6]*vd*SH_TAS[0]);\n        Kfusion[6] = SK_TAS*(P[6][4]*SH_TAS[2] - P[6][14]*SH_TAS[2] + P[6][5]*SH_TAS[1] - P[6][15]*SH_TAS[1] + P[6][6]*vd*SH_TAS[0]);\n        Kfusion[7] = SK_TAS*(P[7][4]*SH_TAS[2] - P[7][14]*SH_TAS[2] + P[7][5]*SH_TAS[1] - P[7][15]*SH_TAS[1] + P[7][6]*vd*SH_TAS[0]);\n        Kfusion[8] = SK_TAS*(P[8][4]*SH_TAS[2] - P[8][14]*SH_TAS[2] + P[8][5]*SH_TAS[1] - P[8][15]*SH_TAS[1] + P[8][6]*vd*SH_TAS[0]);\n        Kfusion[9] = SK_TAS*(P[9][4]*SH_TAS[2] - P[9][14]*SH_TAS[2] + P[9][5]*SH_TAS[1] - P[9][15]*SH_TAS[1] + P[9][6]*vd*SH_TAS[0]);\n        Kfusion[10] = SK_TAS*(P[10][4]*SH_TAS[2] - P[10][14]*SH_TAS[2] + P[10][5]*SH_TAS[1] - P[10][15]*SH_TAS[1] + P[10][6]*vd*SH_TAS[0]);\n        Kfusion[11] = SK_TAS*(P[11][4]*SH_TAS[2] - P[11][14]*SH_TAS[2] + P[11][5]*SH_TAS[1] - P[11][15]*SH_TAS[1] + P[11][6]*vd*SH_TAS[0]);\n        Kfusion[12] = SK_TAS*(P[12][4]*SH_TAS[2] - P[12][14]*SH_TAS[2] + P[12][5]*SH_TAS[1] - P[12][15]*SH_TAS[1] + P[12][6]*vd*SH_TAS[0]);\n        // Only height measurements are allowed to modify the Z delta velocity bias state. This improves the stability of the estimate\n        Kfusion[13] = 0.0f;//SK_TAS*(P[13][4]*SH_TAS[2] - P[13][14]*SH_TAS[2] + P[13][5]*SH_TAS[1] - P[13][15]*SH_TAS[1] + P[13][6]*vd*SH_TAS[0]);\n        // Estimation of selected states is inhibited by setting their Kalman gains to zero\n        if (!inhibitWindStates) {\n            Kfusion[14] = SK_TAS*(P[14][4]*SH_TAS[2] - P[14][14]*SH_TAS[2] + P[14][5]*SH_TAS[1] - P[14][15]*SH_TAS[1] + P[14][6]*vd*SH_TAS[0]);\n            Kfusion[15] = SK_TAS*(P[15][4]*SH_TAS[2] - P[15][14]*SH_TAS[2] + P[15][5]*SH_TAS[1] - P[15][15]*SH_TAS[1] + P[15][6]*vd*SH_TAS[0]);\n        } else {\n            Kfusion[14] = 0;\n            Kfusion[15] = 0;\n        }\n        if (!inhibitMagStates) {\n            Kfusion[16] = SK_TAS*(P[16][4]*SH_TAS[2] - P[16][14]*SH_TAS[2] + P[16][5]*SH_TAS[1] - P[16][15]*SH_TAS[1] + P[16][6]*vd*SH_TAS[0]);\n            Kfusion[17] = SK_TAS*(P[17][4]*SH_TAS[2] - P[17][14]*SH_TAS[2] + P[17][5]*SH_TAS[1] - P[17][15]*SH_TAS[1] + P[17][6]*vd*SH_TAS[0]);\n            Kfusion[18] = SK_TAS*(P[18][4]*SH_TAS[2] - P[18][14]*SH_TAS[2] + P[18][5]*SH_TAS[1] - P[18][15]*SH_TAS[1] + P[18][6]*vd*SH_TAS[0]);\n            Kfusion[19] = SK_TAS*(P[19][4]*SH_TAS[2] - P[19][14]*SH_TAS[2] + P[19][5]*SH_TAS[1] - P[19][15]*SH_TAS[1] + P[19][6]*vd*SH_TAS[0]);\n            Kfusion[20] = SK_TAS*(P[20][4]*SH_TAS[2] - P[20][14]*SH_TAS[2] + P[20][5]*SH_TAS[1] - P[20][15]*SH_TAS[1] + P[20][6]*vd*SH_TAS[0]);\n            Kfusion[21] = SK_TAS*(P[21][4]*SH_TAS[2] - P[21][14]*SH_TAS[2] + P[21][5]*SH_TAS[1] - P[21][15]*SH_TAS[1] + P[21][6]*vd*SH_TAS[0]);\n        } else {\n            for (uint8_t i=16; i < EKF_STATE_ESTIMATES; i++) {\n                Kfusion[i] = 0;\n            }\n        }\n        varInnovVtas = 1.0f/SK_TAS;\n\n        // Calculate the measurement innovation\n        innovVtas = VtasPred - VtasMeas;\n        // Check the innovation for consistency and don't fuse if > 5Sigma\n        if ((innovVtas*innovVtas*SK_TAS) < 25.0f)\n        {\n            // correct the state vector\n            for (uint8_t j=0; j < EKF_STATE_ESTIMATES; j++)\n            {\n                states[j] = states[j] - Kfusion[j] * innovVtas;\n            }\n            // normalise the quaternion states\n            float quatMag = sqrtf(states[0]*states[0] + states[1]*states[1] + states[2]*states[2] + states[3]*states[3]);\n            if (quatMag > 1e-12f)\n            {\n                for (uint8_t j= 0; j <= 3; j++)\n                {\n                    float quatMagInv = 1.0f/quatMag;\n                    states[j] = states[j] * quatMagInv;\n                }\n            }\n            // correct the covariance P = (I - K*H)*P\n            // take advantage of the empty columns in H to reduce the\n            // number of operations\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n            {\n                for (uint8_t j = 0; j <= 3; j++) KH[i][j] = 0.0;\n                for (uint8_t j = 4; j <= 6; j++)\n                {\n                    KH[i][j] = Kfusion[i] * H_TAS[j];\n                }\n                for (uint8_t j = 7; j <= 13; j++) KH[i][j] = 0.0;\n                for (uint8_t j = 14; j <= 15; j++)\n                {\n                    KH[i][j] = Kfusion[i] * H_TAS[j];\n                }\n                for (uint8_t j = 16; j < EKF_STATE_ESTIMATES; j++) KH[i][j] = 0.0;\n            }\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n            {\n                for (uint8_t j = 0; j < EKF_STATE_ESTIMATES; j++)\n                {\n                    KHP[i][j] = 0.0;\n                    for (uint8_t k = 4; k <= 6; k++)\n                    {\n                        KHP[i][j] = KHP[i][j] + KH[i][k] * P[k][j];\n                    }\n                    for (uint8_t k = 14; k <= 15; k++)\n                    {\n                        KHP[i][j] = KHP[i][j] + KH[i][k] * P[k][j];\n                    }\n                }\n            }\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n            {\n                for (uint8_t j = 0; j < EKF_STATE_ESTIMATES; j++)\n                {\n                    P[i][j] = P[i][j] - KHP[i][j];\n                }\n            }\n        }\n    }\n\n    ForceSymmetry();\n    ConstrainVariances();\n}\n\nvoid AttPosEKF::zeroRows(float (&covMat)[EKF_STATE_ESTIMATES][EKF_STATE_ESTIMATES], uint8_t first, uint8_t last)\n{\n    uint8_t row;\n    uint8_t col;\n    for (row=first; row<=last; row++)\n    {\n        for (col=0; col<EKF_STATE_ESTIMATES; col++)\n        {\n            covMat[row][col] = 0.0;\n        }\n    }\n}\n\nvoid AttPosEKF::FuseOptFlow()\n{\n    static float SH_LOS[13];\n    static float SK_LOS[9];\n    static float q0 = 0.0f;\n    static float q1 = 0.0f;\n    static float q2 = 0.0f;\n    static float q3 = 1.0f;\n    static float vn = 0.0f;\n    static float ve = 0.0f;\n    static float vd = 0.0f;\n    static float pd = 0.0f;\n    static float ptd = 0.0f;\n    static float losPred[2];\n\n    // Transformation matrix from nav to body axes\n    float H_LOS[2][EKF_STATE_ESTIMATES];\n    float K_LOS[2][EKF_STATE_ESTIMATES];\n    Vector3f velNED_local;\n    Vector3f relVelSensor;\n\n    // Perform sequential fusion of optical flow measurements only with valid tilt and height\n    flowStates[1] = std::max(flowStates[1], statesAtFlowTime[9] + minFlowRng);\n    float heightAboveGndEst = flowStates[1] - statesAtFlowTime[9];\n    bool validTilt = Tnb.z.z > 0.71f;\n    if (validTilt)\n    {\n        // Sequential fusion of XY components.\n\n        // Calculate observation jacobians and Kalman gains\n        if (fuseOptFlowData)\n        {\n            // Copy required states to local variable names\n            q0       = statesAtFlowTime[0];\n            q1       = statesAtFlowTime[1];\n            q2       = statesAtFlowTime[2];\n            q3       = statesAtFlowTime[3];\n            vn       = statesAtFlowTime[4];\n            ve       = statesAtFlowTime[5];\n            vd       = statesAtFlowTime[6];\n            pd       = statesAtFlowTime[9];\n            ptd      = flowStates[1];\n            velNED_local.x = vn;\n            velNED_local.y = ve;\n            velNED_local.z = vd;\n\n            // calculate range from ground plain to centre of sensor fov assuming flat earth\n            float range = heightAboveGndEst/Tnb_flow.z.z;\n\n            // calculate relative velocity in sensor frame\n            relVelSensor = Tnb_flow*velNED_local;\n\n            // divide velocity by range  and include angular rate effects to get predicted angular LOS rates relative to X and Y axes\n            losPred[0] =  relVelSensor.y/range;\n            losPred[1] = -relVelSensor.x/range;\n\n            // Calculate common expressions for observation jacobians\n            SH_LOS[0] = sq(q0) - sq(q1) - sq(q2) + sq(q3);\n            SH_LOS[1] = vn*(sq(q0) + sq(q1) - sq(q2) - sq(q3)) - vd*(2*q0*q2 - 2*q1*q3) + ve*(2*q0*q3 + 2*q1*q2);\n            SH_LOS[2] = ve*(sq(q0) - sq(q1) + sq(q2) - sq(q3)) + vd*(2*q0*q1 + 2*q2*q3) - vn*(2*q0*q3 - 2*q1*q2);\n            SH_LOS[3] = 1/(pd - ptd);\n            SH_LOS[4] = 1/sq(pd - ptd);\n\n            // Calculate common expressions for Kalman gains\n            SK_LOS[0] = 1.0f/((R_LOS + sq(omegaAcrossFlowTime[0] * moCompR_LOS)) + (SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3])*(P[0][0]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][0]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][0]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][0]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][0]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][0]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][0]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][0]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))) + (SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3])*(P[0][1]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][1]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][1]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][1]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][1]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][1]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][1]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][1]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))) - (SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3])*(P[0][2]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][2]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][2]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][2]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][2]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][2]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][2]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][2]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))) + (SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3])*(P[0][3]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][3]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][3]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][3]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][3]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][3]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][3]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][3]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))) - SH_LOS[0]*SH_LOS[1]*SH_LOS[4]*(P[0][9]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][9]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][9]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][9]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][9]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][9]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][9]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][9]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))) + SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))*(P[0][4]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][4]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][4]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][4]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][4]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][4]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][4]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][4]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))) + SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2)*(P[0][5]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][5]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][5]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][5]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][5]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][5]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][5]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][5]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))) - SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3)*(P[0][6]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3]) + P[1][6]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3]) - P[2][6]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) + 2*q2*SH_LOS[1]*SH_LOS[3]) + P[3][6]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3]) + P[5][6]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2) - P[6][6]*SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3) - P[9][6]*SH_LOS[0]*SH_LOS[1]*SH_LOS[4] + P[4][6]*SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3))));\n            SK_LOS[1] = 1.0f/((R_LOS + sq(omegaAcrossFlowTime[1] * moCompR_LOS))+ (SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3])*(P[0][0]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][0]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][0]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][0]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][0]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][0]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][0]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][0]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))) + (SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3])*(P[0][1]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][1]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][1]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][1]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][1]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][1]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][1]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][1]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))) + (SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3])*(P[0][2]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][2]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][2]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][2]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][2]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][2]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][2]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][2]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))) - (SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3])*(P[0][3]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][3]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][3]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][3]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][3]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][3]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][3]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][3]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))) - SH_LOS[0]*SH_LOS[2]*SH_LOS[4]*(P[0][9]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][9]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][9]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][9]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][9]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][9]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][9]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][9]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))) + SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))*(P[0][5]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][5]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][5]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][5]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][5]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][5]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][5]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][5]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))) - SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2)*(P[0][4]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][4]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][4]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][4]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][4]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][4]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][4]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][4]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))) + SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3)*(P[0][6]*(SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q0*SH_LOS[2]*SH_LOS[3]) + P[1][6]*(SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q1*SH_LOS[2]*SH_LOS[3]) + P[2][6]*(SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q2*SH_LOS[2]*SH_LOS[3]) - P[3][6]*(SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3]) - P[4][6]*SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2) + P[6][6]*SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3) - P[9][6]*SH_LOS[0]*SH_LOS[2]*SH_LOS[4] + P[5][6]*SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3))));\n            SK_LOS[2] = SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn);\n            SK_LOS[3] = SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn);\n            SK_LOS[4] = SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn);\n            SK_LOS[5] = SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn);\n            SK_LOS[6] = sq(q0) - sq(q1) + sq(q2) - sq(q3);\n            SK_LOS[7] = sq(q0) + sq(q1) - sq(q2) - sq(q3);\n            SK_LOS[8] = SH_LOS[3];\n\n            // Calculate common intermediate terms\n            float tempVar[9];\n            tempVar[0] = SH_LOS[0]*SK_LOS[6]*SK_LOS[8];\n            tempVar[1] = SH_LOS[0]*SH_LOS[2]*SH_LOS[4];\n            tempVar[2] = 2.0f*SH_LOS[2]*SK_LOS[8];\n            tempVar[3] = SH_LOS[0]*SK_LOS[8]*(2.0f*q0*q1 + 2.0f*q2*q3);\n            tempVar[4] = SH_LOS[0]*SK_LOS[8]*(2.0f*q0*q3 - 2.0f*q1*q2);\n            tempVar[5] = (SK_LOS[5] - q2*tempVar[2]);\n            tempVar[6] = (SK_LOS[2] - q3*tempVar[2]);\n            tempVar[7] = (SK_LOS[3] - q1*tempVar[2]);\n            tempVar[8] = (SK_LOS[4] + q0*tempVar[2]);\n\n            // calculate observation jacobians for X LOS rate\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++) H_LOS[0][i] = 0;\n            H_LOS[0][0] = - SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) - 2*q0*SH_LOS[2]*SH_LOS[3];\n            H_LOS[0][1] = 2*q1*SH_LOS[2]*SH_LOS[3] - SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn);\n            H_LOS[0][2] = 2*q2*SH_LOS[2]*SH_LOS[3] - SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn);\n            H_LOS[0][3] = SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) - 2*q3*SH_LOS[2]*SH_LOS[3];\n            H_LOS[0][4] = SH_LOS[0]*SH_LOS[3]*(2*q0*q3 - 2*q1*q2);\n            H_LOS[0][5] = -SH_LOS[0]*SH_LOS[3]*(sq(q0) - sq(q1) + sq(q2) - sq(q3));\n            H_LOS[0][6] = -SH_LOS[0]*SH_LOS[3]*(2*q0*q1 + 2*q2*q3);\n            H_LOS[0][9] = tempVar[1];\n\n            // calculate Kalman gains for X LOS rate\n            K_LOS[0][0] = -(P[0][0]*tempVar[8] + P[0][1]*tempVar[7] - P[0][3]*tempVar[6] + P[0][2]*tempVar[5] - P[0][4]*tempVar[4] + P[0][6]*tempVar[3] - P[0][9]*tempVar[1] + P[0][5]*tempVar[0])/(R_LOS + tempVar[8]*(P[0][0]*tempVar[8] + P[1][0]*tempVar[7] + P[2][0]*tempVar[5] - P[3][0]*tempVar[6] - P[4][0]*tempVar[4] + P[6][0]*tempVar[3] - P[9][0]*tempVar[1] + P[5][0]*tempVar[0]) + tempVar[7]*(P[0][1]*tempVar[8] + P[1][1]*tempVar[7] + P[2][1]*tempVar[5] - P[3][1]*tempVar[6] - P[4][1]*tempVar[4] + P[6][1]*tempVar[3] - P[9][1]*tempVar[1] + P[5][1]*tempVar[0]) + tempVar[5]*(P[0][2]*tempVar[8] + P[1][2]*tempVar[7] + P[2][2]*tempVar[5] - P[3][2]*tempVar[6] - P[4][2]*tempVar[4] + P[6][2]*tempVar[3] - P[9][2]*tempVar[1] + P[5][2]*tempVar[0]) - tempVar[6]*(P[0][3]*tempVar[8] + P[1][3]*tempVar[7] + P[2][3]*tempVar[5] - P[3][3]*tempVar[6] - P[4][3]*tempVar[4] + P[6][3]*tempVar[3] - P[9][3]*tempVar[1] + P[5][3]*tempVar[0]) - tempVar[4]*(P[0][4]*tempVar[8] + P[1][4]*tempVar[7] + P[2][4]*tempVar[5] - P[3][4]*tempVar[6] - P[4][4]*tempVar[4] + P[6][4]*tempVar[3] - P[9][4]*tempVar[1] + P[5][4]*tempVar[0]) + tempVar[3]*(P[0][6]*tempVar[8] + P[1][6]*tempVar[7] + P[2][6]*tempVar[5] - P[3][6]*tempVar[6] - P[4][6]*tempVar[4] + P[6][6]*tempVar[3] - P[9][6]*tempVar[1] + P[5][6]*tempVar[0]) - tempVar[1]*(P[0][9]*tempVar[8] + P[1][9]*tempVar[7] + P[2][9]*tempVar[5] - P[3][9]*tempVar[6] - P[4][9]*tempVar[4] + P[6][9]*tempVar[3] - P[9][9]*tempVar[1] + P[5][9]*tempVar[0]) + tempVar[0]*(P[0][5]*tempVar[8] + P[1][5]*tempVar[7] + P[2][5]*tempVar[5] - P[3][5]*tempVar[6] - P[4][5]*tempVar[4] + P[6][5]*tempVar[3] - P[9][5]*tempVar[1] + P[5][5]*tempVar[0]));\n            K_LOS[0][1] = -SK_LOS[1]*(P[1][0]*tempVar[8] + P[1][1]*tempVar[7] - P[1][3]*tempVar[6] + P[1][2]*tempVar[5] - P[1][4]*tempVar[4] + P[1][6]*tempVar[3] - P[1][9]*tempVar[1] + P[1][5]*tempVar[0]);\n            K_LOS[0][2] = -SK_LOS[1]*(P[2][0]*tempVar[8] + P[2][1]*tempVar[7] - P[2][3]*tempVar[6] + P[2][2]*tempVar[5] - P[2][4]*tempVar[4] + P[2][6]*tempVar[3] - P[2][9]*tempVar[1] + P[2][5]*tempVar[0]);\n            K_LOS[0][3] = -SK_LOS[1]*(P[3][0]*tempVar[8] + P[3][1]*tempVar[7] - P[3][3]*tempVar[6] + P[3][2]*tempVar[5] - P[3][4]*tempVar[4] + P[3][6]*tempVar[3] - P[3][9]*tempVar[1] + P[3][5]*tempVar[0]);\n            K_LOS[0][4] = -SK_LOS[1]*(P[4][0]*tempVar[8] + P[4][1]*tempVar[7] - P[4][3]*tempVar[6] + P[4][2]*tempVar[5] - P[4][4]*tempVar[4] + P[4][6]*tempVar[3] - P[4][9]*tempVar[1] + P[4][5]*tempVar[0]);\n            K_LOS[0][5] = -SK_LOS[1]*(P[5][0]*tempVar[8] + P[5][1]*tempVar[7] - P[5][3]*tempVar[6] + P[5][2]*tempVar[5] - P[5][4]*tempVar[4] + P[5][6]*tempVar[3] - P[5][9]*tempVar[1] + P[5][5]*tempVar[0]);\n            K_LOS[0][6] = -SK_LOS[1]*(P[6][0]*tempVar[8] + P[6][1]*tempVar[7] - P[6][3]*tempVar[6] + P[6][2]*tempVar[5] - P[6][4]*tempVar[4] + P[6][6]*tempVar[3] - P[6][9]*tempVar[1] + P[6][5]*tempVar[0]);\n            K_LOS[0][7] = -SK_LOS[1]*(P[7][0]*tempVar[8] + P[7][1]*tempVar[7] - P[7][3]*tempVar[6] + P[7][2]*tempVar[5] - P[7][4]*tempVar[4] + P[7][6]*tempVar[3] - P[7][9]*tempVar[1] + P[7][5]*tempVar[0]);\n            K_LOS[0][8] = -SK_LOS[1]*(P[8][0]*tempVar[8] + P[8][1]*tempVar[7] - P[8][3]*tempVar[6] + P[8][2]*tempVar[5] - P[8][4]*tempVar[4] + P[8][6]*tempVar[3] - P[8][9]*tempVar[1] + P[8][5]*tempVar[0]);\n            K_LOS[0][9] = -SK_LOS[1]*(P[9][0]*tempVar[8] + P[9][1]*tempVar[7] - P[9][3]*tempVar[6] + P[9][2]*tempVar[5] - P[9][4]*tempVar[4] + P[9][6]*tempVar[3] - P[9][9]*tempVar[1] + P[9][5]*tempVar[0]);\n            K_LOS[0][10] = -SK_LOS[1]*(P[10][0]*tempVar[8] + P[10][1]*tempVar[7] - P[10][3]*tempVar[6] + P[10][2]*tempVar[5] - P[10][4]*tempVar[4] + P[10][6]*tempVar[3] - P[10][9]*tempVar[1] + P[10][5]*tempVar[0]);\n            K_LOS[0][11] = -SK_LOS[1]*(P[11][0]*tempVar[8] + P[11][1]*tempVar[7] - P[11][3]*tempVar[6] + P[11][2]*tempVar[5] - P[11][4]*tempVar[4] + P[11][6]*tempVar[3] - P[11][9]*tempVar[1] + P[11][5]*tempVar[0]);\n            K_LOS[0][12] = -SK_LOS[1]*(P[12][0]*tempVar[8] + P[12][1]*tempVar[7] - P[12][3]*tempVar[6] + P[12][2]*tempVar[5] - P[12][4]*tempVar[4] + P[12][6]*tempVar[3] - P[12][9]*tempVar[1] + P[12][5]*tempVar[0]);\n            // only height measurements are allowed to modify the Z bias state to improve the stability of the estimate\n            K_LOS[0][13] = 0.0f;//-SK_LOS[1]*(P[13][0]*tempVar[8] + P[13][1]*tempVar[7] - P[13][3]*tempVar[6] + P[13][2]*tempVar[5] - P[13][4]*tempVar[4] + P[13][6]*tempVar[3] - P[13][9]*tempVar[1] + P[13][5]*tempVar[0]);\n            if (inhibitWindStates) {\n                K_LOS[0][14] = -SK_LOS[1]*(P[14][0]*tempVar[8] + P[14][1]*tempVar[7] - P[14][3]*tempVar[6] + P[14][2]*tempVar[5] - P[14][4]*tempVar[4] + P[14][6]*tempVar[3] - P[14][9]*tempVar[1] + P[14][5]*tempVar[0]);\n                K_LOS[0][15] = -SK_LOS[1]*(P[15][0]*tempVar[8] + P[15][1]*tempVar[7] - P[15][3]*tempVar[6] + P[15][2]*tempVar[5] - P[15][4]*tempVar[4] + P[15][6]*tempVar[3] - P[15][9]*tempVar[1] + P[15][5]*tempVar[0]);\n            } else {\n                K_LOS[0][14] = 0.0f;\n                K_LOS[0][15] = 0.0f;\n            }\n            if (inhibitMagStates) {\n                K_LOS[0][16] = -SK_LOS[1]*(P[16][0]*tempVar[8] + P[16][1]*tempVar[7] - P[16][3]*tempVar[6] + P[16][2]*tempVar[5] - P[16][4]*tempVar[4] + P[16][6]*tempVar[3] - P[16][9]*tempVar[1] + P[16][5]*tempVar[0]);\n                K_LOS[0][17] = -SK_LOS[1]*(P[17][0]*tempVar[8] + P[17][1]*tempVar[7] - P[17][3]*tempVar[6] + P[17][2]*tempVar[5] - P[17][4]*tempVar[4] + P[17][6]*tempVar[3] - P[17][9]*tempVar[1] + P[17][5]*tempVar[0]);\n                K_LOS[0][18] = -SK_LOS[1]*(P[18][0]*tempVar[8] + P[18][1]*tempVar[7] - P[18][3]*tempVar[6] + P[18][2]*tempVar[5] - P[18][4]*tempVar[4] + P[18][6]*tempVar[3] - P[18][9]*tempVar[1] + P[18][5]*tempVar[0]);\n                K_LOS[0][19] = -SK_LOS[1]*(P[19][0]*tempVar[8] + P[19][1]*tempVar[7] - P[19][3]*tempVar[6] + P[19][2]*tempVar[5] - P[19][4]*tempVar[4] + P[19][6]*tempVar[3] - P[19][9]*tempVar[1] + P[19][5]*tempVar[0]);\n                K_LOS[0][20] = -SK_LOS[1]*(P[20][0]*tempVar[8] + P[20][1]*tempVar[7] - P[20][3]*tempVar[6] + P[20][2]*tempVar[5] - P[20][4]*tempVar[4] + P[20][6]*tempVar[3] - P[20][9]*tempVar[1] + P[20][5]*tempVar[0]);\n                K_LOS[0][21] = -SK_LOS[1]*(P[21][0]*tempVar[8] + P[21][1]*tempVar[7] - P[21][3]*tempVar[6] + P[21][2]*tempVar[5] - P[21][4]*tempVar[4] + P[21][6]*tempVar[3] - P[21][9]*tempVar[1] + P[21][5]*tempVar[0]);\n            } else {\n                for (uint8_t i = 16; i < EKF_STATE_ESTIMATES; i++) {\n                    K_LOS[0][i] = 0.0f;\n                }\n            }\n\n            // calculate innovation variance and innovation for X axis observation\n            varInnovOptFlow[0] = 1.0f/SK_LOS[0];\n            innovOptFlow[0] = losPred[0] - flowRadXYcomp[0];\n\n            // calculate intermediate common variables\n            tempVar[0] = 2.0f*SH_LOS[1]*SK_LOS[8];\n            tempVar[1] = (SK_LOS[2] + q0*tempVar[0]);\n            tempVar[2] = (SK_LOS[5] - q1*tempVar[0]);\n            tempVar[3] = (SK_LOS[3] + q2*tempVar[0]);\n            tempVar[4] = (SK_LOS[4] + q3*tempVar[0]);\n            tempVar[5] = SH_LOS[0]*SK_LOS[8]*(2*q0*q3 + 2*q1*q2);\n            tempVar[6] = SH_LOS[0]*SK_LOS[8]*(2*q0*q2 - 2*q1*q3);\n            tempVar[7] = SH_LOS[0]*SH_LOS[1]*SH_LOS[4];\n            tempVar[8] = SH_LOS[0]*SK_LOS[7]*SK_LOS[8];\n\n            // Calculate observation jacobians for Y LOS rate\n            for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++) H_LOS[1][i] = 0;\n            H_LOS[1][0] = SH_LOS[0]*SH_LOS[3]*(2*q3*ve - 2*q2*vd + 2*q0*vn) + 2*q0*SH_LOS[1]*SH_LOS[3];\n            H_LOS[1][1] = SH_LOS[0]*SH_LOS[3]*(2*q3*vd + 2*q2*ve + 2*q1*vn) - 2*q1*SH_LOS[1]*SH_LOS[3];\n            H_LOS[1][2] = - SH_LOS[0]*SH_LOS[3]*(2*q0*vd - 2*q1*ve + 2*q2*vn) - 2*q2*SH_LOS[1]*SH_LOS[3];\n            H_LOS[1][3] = SH_LOS[0]*SH_LOS[3]*(2*q1*vd + 2*q0*ve - 2*q3*vn) + 2*q3*SH_LOS[1]*SH_LOS[3];\n            H_LOS[1][4] = SH_LOS[0]*SH_LOS[3]*(sq(q0) + sq(q1) - sq(q2) - sq(q3));\n            H_LOS[1][5] = SH_LOS[0]*SH_LOS[3]*(2*q0*q3 + 2*q1*q2);\n            H_LOS[1][6] = -SH_LOS[0]*SH_LOS[3]*(2*q0*q2 - 2*q1*q3);\n            H_LOS[1][9] = -tempVar[7];\n\n            // Calculate Kalman gains for Y LOS rate\n            K_LOS[1][0] = SK_LOS[0]*(P[0][0]*tempVar[1] + P[0][1]*tempVar[2] - P[0][2]*tempVar[3] + P[0][3]*tempVar[4] + P[0][5]*tempVar[5] - P[0][6]*tempVar[6] - P[0][9]*tempVar[7] + P[0][4]*tempVar[8]);\n            K_LOS[1][1] = SK_LOS[0]*(P[1][0]*tempVar[1] + P[1][1]*tempVar[2] - P[1][2]*tempVar[3] + P[1][3]*tempVar[4] + P[1][5]*tempVar[5] - P[1][6]*tempVar[6] - P[1][9]*tempVar[7] + P[1][4]*tempVar[8]);\n            K_LOS[1][2] = SK_LOS[0]*(P[2][0]*tempVar[1] + P[2][1]*tempVar[2] - P[2][2]*tempVar[3] + P[2][3]*tempVar[4] + P[2][5]*tempVar[5] - P[2][6]*tempVar[6] - P[2][9]*tempVar[7] + P[2][4]*tempVar[8]);\n            K_LOS[1][3] = SK_LOS[0]*(P[3][0]*tempVar[1] + P[3][1]*tempVar[2] - P[3][2]*tempVar[3] + P[3][3]*tempVar[4] + P[3][5]*tempVar[5] - P[3][6]*tempVar[6] - P[3][9]*tempVar[7] + P[3][4]*tempVar[8]);\n            K_LOS[1][4] = SK_LOS[0]*(P[4][0]*tempVar[1] + P[4][1]*tempVar[2] - P[4][2]*tempVar[3] + P[4][3]*tempVar[4] + P[4][5]*tempVar[5] - P[4][6]*tempVar[6] - P[4][9]*tempVar[7] + P[4][4]*tempVar[8]);\n            K_LOS[1][5] = SK_LOS[0]*(P[5][0]*tempVar[1] + P[5][1]*tempVar[2] - P[5][2]*tempVar[3] + P[5][3]*tempVar[4] + P[5][5]*tempVar[5] - P[5][6]*tempVar[6] - P[5][9]*tempVar[7] + P[5][4]*tempVar[8]);\n            K_LOS[1][6] = SK_LOS[0]*(P[6][0]*tempVar[1] + P[6][1]*tempVar[2] - P[6][2]*tempVar[3] + P[6][3]*tempVar[4] + P[6][5]*tempVar[5] - P[6][6]*tempVar[6] - P[6][9]*tempVar[7] + P[6][4]*tempVar[8]);\n            K_LOS[1][7] = SK_LOS[0]*(P[7][0]*tempVar[1] + P[7][1]*tempVar[2] - P[7][2]*tempVar[3] + P[7][3]*tempVar[4] + P[7][5]*tempVar[5] - P[7][6]*tempVar[6] - P[7][9]*tempVar[7] + P[7][4]*tempVar[8]);\n            K_LOS[1][8] = SK_LOS[0]*(P[8][0]*tempVar[1] + P[8][1]*tempVar[2] - P[8][2]*tempVar[3] + P[8][3]*tempVar[4] + P[8][5]*tempVar[5] - P[8][6]*tempVar[6] - P[8][9]*tempVar[7] + P[8][4]*tempVar[8]);\n            K_LOS[1][9] = SK_LOS[0]*(P[9][0]*tempVar[1] + P[9][1]*tempVar[2] - P[9][2]*tempVar[3] + P[9][3]*tempVar[4] + P[9][5]*tempVar[5] - P[9][6]*tempVar[6] - P[9][9]*tempVar[7] + P[9][4]*tempVar[8]);\n            K_LOS[1][10] = SK_LOS[0]*(P[10][0]*tempVar[1] + P[10][1]*tempVar[2] - P[10][2]*tempVar[3] + P[10][3]*tempVar[4] + P[10][5]*tempVar[5] - P[10][6]*tempVar[6] - P[10][9]*tempVar[7] + P[10][4]*tempVar[8]);\n            K_LOS[1][11] = SK_LOS[0]*(P[11][0]*tempVar[1] + P[11][1]*tempVar[2] - P[11][2]*tempVar[3] + P[11][3]*tempVar[4] + P[11][5]*tempVar[5] - P[11][6]*tempVar[6] - P[11][9]*tempVar[7] + P[11][4]*tempVar[8]);\n            K_LOS[1][12] = SK_LOS[0]*(P[12][0]*tempVar[1] + P[12][1]*tempVar[2] - P[12][2]*tempVar[3] + P[12][3]*tempVar[4] + P[12][5]*tempVar[5] - P[12][6]*tempVar[6] - P[12][9]*tempVar[7] + P[12][4]*tempVar[8]);\n            // only height measurements are allowed to modify the Z bias state to improve the stability of the estimate\n            K_LOS[1][13] = 0.0f;//SK_LOS[0]*(P[13][0]*tempVar[1] + P[13][1]*tempVar[2] - P[13][2]*tempVar[3] + P[13][3]*tempVar[4] + P[13][5]*tempVar[5] - P[13][6]*tempVar[6] - P[13][9]*tempVar[7] + P[13][4]*tempVar[8]);\n            if (inhibitWindStates) {\n                K_LOS[1][14] = SK_LOS[0]*(P[14][0]*tempVar[1] + P[14][1]*tempVar[2] - P[14][2]*tempVar[3] + P[14][3]*tempVar[4] + P[14][5]*tempVar[5] - P[14][6]*tempVar[6] - P[14][9]*tempVar[7] + P[14][4]*tempVar[8]);\n                K_LOS[1][15] = SK_LOS[0]*(P[15][0]*tempVar[1] + P[15][1]*tempVar[2] - P[15][2]*tempVar[3] + P[15][3]*tempVar[4] + P[15][5]*tempVar[5] - P[15][6]*tempVar[6] - P[15][9]*tempVar[7] + P[15][4]*tempVar[8]);\n            } else {\n                K_LOS[1][14] = 0.0f;\n                K_LOS[1][15] = 0.0f;\n            }\n            if (inhibitMagStates) {\n                K_LOS[1][16] = SK_LOS[0]*(P[16][0]*tempVar[1] + P[16][1]*tempVar[2] - P[16][2]*tempVar[3] + P[16][3]*tempVar[4] + P[16][5]*tempVar[5] - P[16][6]*tempVar[6] - P[16][9]*tempVar[7] + P[16][4]*tempVar[8]);\n                K_LOS[1][17] = SK_LOS[0]*(P[17][0]*tempVar[1] + P[17][1]*tempVar[2] - P[17][2]*tempVar[3] + P[17][3]*tempVar[4] + P[17][5]*tempVar[5] - P[17][6]*tempVar[6] - P[17][9]*tempVar[7] + P[17][4]*tempVar[8]);\n                K_LOS[1][18] = SK_LOS[0]*(P[18][0]*tempVar[1] + P[18][1]*tempVar[2] - P[18][2]*tempVar[3] + P[18][3]*tempVar[4] + P[18][5]*tempVar[5] - P[18][6]*tempVar[6] - P[18][9]*tempVar[7] + P[18][4]*tempVar[8]);\n                K_LOS[1][19] = SK_LOS[0]*(P[19][0]*tempVar[1] + P[19][1]*tempVar[2] - P[19][2]*tempVar[3] + P[19][3]*tempVar[4] + P[19][5]*tempVar[5] - P[19][6]*tempVar[6] - P[19][9]*tempVar[7] + P[19][4]*tempVar[8]);\n                K_LOS[1][20] = SK_LOS[0]*(P[20][0]*tempVar[1] + P[20][1]*tempVar[2] - P[20][2]*tempVar[3] + P[20][3]*tempVar[4] + P[20][5]*tempVar[5] - P[20][6]*tempVar[6] - P[20][9]*tempVar[7] + P[20][4]*tempVar[8]);\n                K_LOS[1][21] = SK_LOS[0]*(P[21][0]*tempVar[1] + P[21][1]*tempVar[2] - P[21][2]*tempVar[3] + P[21][3]*tempVar[4] + P[21][5]*tempVar[5] - P[21][6]*tempVar[6] - P[21][9]*tempVar[7] + P[21][4]*tempVar[8]);\n            } else {\n                for (uint8_t i = 16; i < EKF_STATE_ESTIMATES; i++) {\n                    K_LOS[1][i] = 0.0f;\n                }\n            }\n\n            // calculate variance and innovation for Y observation\n            varInnovOptFlow[1] = 1.0f/SK_LOS[1];\n            innovOptFlow[1] = losPred[1] - flowRadXYcomp[1];\n\n        }\n\n        // loop through the X and Y observations and fuse them sequentially\n        for (uint8_t obsIndex = 0; obsIndex < 2; obsIndex++) {\n            // Check the innovation for consistency and don't fuse if > 5Sigma\n            if ((innovOptFlow[obsIndex]*innovOptFlow[obsIndex]/varInnovOptFlow[obsIndex]) < 25.0f) {\n                // correct the state vector\n                for (uint8_t j = 0; j < EKF_STATE_ESTIMATES; j++)\n                {\n                    states[j] = states[j] - K_LOS[obsIndex][j] * innovOptFlow[obsIndex];\n                }\n                // normalise the quaternion states\n                float quatMag = sqrtf(states[0]*states[0] + states[1]*states[1] + states[2]*states[2] + states[3]*states[3]);\n                if (quatMag > 1e-12f)\n                {\n                    for (uint8_t j= 0; j<=3; j++)\n                    {\n                        float quatMagInv = 1.0f/quatMag;\n                        states[j] = states[j] * quatMagInv;\n                    }\n                }\n                // correct the covariance P = (I - K*H)*P\n                // take advantage of the empty columns in KH to reduce the\n                // number of operations\n                for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n                {\n                    for (uint8_t j = 0; j <= 6; j++)\n                    {\n                        KH[i][j] = K_LOS[obsIndex][i] * H_LOS[obsIndex][j];\n                    }\n                    for (uint8_t j = 7; j <= 8; j++)\n                    {\n                        KH[i][j] = 0.0f;\n                    }\n                    KH[i][9] = K_LOS[obsIndex][i] * H_LOS[obsIndex][9];\n                    for (uint8_t j = 10; j < EKF_STATE_ESTIMATES; j++)\n                    {\n                        KH[i][j] = 0.0f;\n                    }\n                }\n                for (uint8_t i = 0; i < EKF_STATE_ESTIMATES; i++)\n                {\n                    for (uint8_t j = 0; j < EKF_STATE_ESTIMATES; j++)\n                    {\n                        KHP[i][j] = 0.0f;\n                        for (uint8_t k = 0; k <= 6; k++)\n                        {\n                            KHP[i][j] = KHP[i][j] + KH[i][k] * P[k][j];\n                        }\n                        KHP[i][j] = KHP[i][j] + KH[i][9] * P[9][j];\n                    }\n                }\n                for (uint8_t i = 0; i <  EKF_STATE_ESTIMATES; i++)\n                {\n                    for (uint8_t j = 0; j <  EKF_STATE_ESTIMATES; j++)\n                    {\n                        P[i][j] = P[i][j] - KHP[i][j];\n                    }\n                }\n            }\n        }\n        ForceSymmetry();\n        ConstrainVariances();\n    }\n}\n\nvoid AttPosEKF::OpticalFlowEKF()\n{\n    // propagate ground position state noise each time this is called using the difference in position since the last observations and an RMS gradient assumption\n    // limit distance to prevent intialisation afer bad gps causing bad numerical conditioning\n    if (!inhibitGndState) {\n        float distanceTravelledSq;\n        if (fuseRngData) {\n            distanceTravelledSq = sq(statesAtRngTime[7] - prevPosN) + sq(statesAtRngTime[8] - prevPosE);\n            prevPosN = statesAtRngTime[7];\n            prevPosE = statesAtRngTime[8];\n        } else if (fuseOptFlowData) {\n            distanceTravelledSq = sq(statesAtFlowTime[7] - prevPosN) + sq(statesAtFlowTime[8] - prevPosE);\n            prevPosN = statesAtFlowTime[7];\n            prevPosE = statesAtFlowTime[8];\n        } else {\n            return;\n        }\n        distanceTravelledSq = std::min(distanceTravelledSq, 100.0f);\n        Popt[1][1] += (distanceTravelledSq * sq(gndHgtSigma));\n    }\n\n    // fuse range finder data\n    if (fuseRngData) {\n        float range; // range from camera to centre of image\n        float q0; // quaternion at optical flow measurement time\n        float q1; // quaternion at optical flow measurement time\n        float q2; // quaternion at optical flow measurement time\n        float q3; // quaternion at optical flow measurement time\n        float R_RNG = 0.5; // range measurement variance (m^2) TODO make this a function of range and tilt to allow for sensor, alignment and AHRS errors\n\n        // Copy required states to local variable names\n        q0             = statesAtRngTime[0];\n        q1             = statesAtRngTime[1];\n        q2             = statesAtRngTime[2];\n        q3             = statesAtRngTime[3];\n\n        // calculate Kalman gains\n        float SK_RNG[3];\n        SK_RNG[0] = sq(q0) - sq(q1) - sq(q2) + sq(q3);\n        SK_RNG[1] = 1/(R_RNG + Popt[1][1]/sq(SK_RNG[0]));\n        SK_RNG[2] = 1/SK_RNG[0];\n        float K_RNG[2];\n        if (!inhibitScaleState) {\n            K_RNG[0] = Popt[0][1]*SK_RNG[1]*SK_RNG[2];\n        } else {\n            K_RNG[0] = 0.0f;\n        }\n        if (!inhibitGndState) {\n            K_RNG[1] = Popt[1][1]*SK_RNG[1]*SK_RNG[2];\n        } else {\n            K_RNG[1] = 0.0f;\n        }\n\n        // Calculate the innovation variance for data logging\n        varInnovRng = 1.0f/SK_RNG[1];\n\n        // constrain terrain height to be below the vehicle\n        flowStates[1] = std::max(flowStates[1], statesAtRngTime[9] + minFlowRng);\n\n        // estimate range to centre of image\n        range = (flowStates[1] - statesAtRngTime[9]) * SK_RNG[2];\n\n        // Calculate the measurement innovation\n        innovRng = range - rngMea;\n\n        // calculate the innovation consistency test ratio\n        auxRngTestRatio = sq(innovRng) / (sq(rngInnovGate) * varInnovRng);\n\n        // Check the innovation for consistency and don't fuse if out of bounds\n        if (auxRngTestRatio < 1.0f)\n        {\n            // correct the state\n            for (uint8_t i = 0; i < 2 ; i++) {\n                flowStates[i] -= K_RNG[i] * innovRng;\n            }\n            // constrain the states\n            flowStates[0] = ConstrainFloat(flowStates[0], 0.1f, 10.0f);\n            flowStates[1] = std::max(flowStates[1], statesAtRngTime[9] + minFlowRng);\n\n            // correct the covariance matrix\n            float nextPopt[2][2];\n            nextPopt[0][0] = Popt[0][0] - (Popt[0][1]*Popt[1][0]*SK_RNG[1]*SK_RNG[2]) * SK_RNG[2];\n            nextPopt[0][1] = Popt[0][1] - (Popt[0][1]*Popt[1][1]*SK_RNG[1]*SK_RNG[2]) * SK_RNG[2];\n            nextPopt[1][0] = -Popt[1][0]*((Popt[1][1]*SK_RNG[1]*SK_RNG[2]) * SK_RNG[2] - 1.0f);\n            nextPopt[1][1] = -Popt[1][1]*((Popt[1][1]*SK_RNG[1]*SK_RNG[2]) * SK_RNG[2] - 1.0f);\n            // prevent the state variances from becoming negative and maintain symmetry\n            Popt[0][0] = std::max(nextPopt[0][0],0.0f);\n            Popt[1][1] = std::max(nextPopt[1][1],0.0f);\n            Popt[0][1] = 0.5f * (nextPopt[0][1] + nextPopt[1][0]);\n            Popt[1][0] = Popt[0][1];\n        }\n    }\n\n    if (fuseOptFlowData) {\n        Vector3f vel; // velocity of sensor relative to ground in NED axes\n        Vector3f relVelSensor; // velocity of sensor relative to ground in sensor axes\n        float losPred[2]; // predicted optical flow angular rate measurements\n        float range; // range from camera to centre of image\n        float q0; // quaternion at optical flow measurement time\n        float q1; // quaternion at optical flow measurement time\n        float q2; // quaternion at optical flow measurement time\n        float q3; // quaternion at optical flow measurement time\n        float HP[2];\n        float SH_OPT[6];\n        float SK_OPT[3];\n        float K_OPT[2][2];\n        float H_OPT[2][2];\n        float nextPopt[2][2];\n\n        // propagate scale factor state noise\n        if (!inhibitScaleState) {\n            Popt[0][0] += 1e-8f;\n        } else {\n            Popt[0][0] = 0.0f;\n        }\n\n        // Copy required states to local variable names\n        q0             = statesAtFlowTime[0];\n        q1             = statesAtFlowTime[1];\n        q2             = statesAtFlowTime[2];\n        q3             = statesAtFlowTime[3];\n        vel.x          = statesAtFlowTime[4];\n        vel.y          = statesAtFlowTime[5];\n        vel.z          = statesAtFlowTime[6];\n\n        // constrain terrain height to be below the vehicle\n        flowStates[1] = std::max(flowStates[1], statesAtFlowTime[9] + minFlowRng);\n\n        // estimate range to centre of image\n        range = (flowStates[1] - statesAtFlowTime[9]) / Tnb_flow.z.z;\n\n        // calculate relative velocity in sensor frame\n        relVelSensor = Tnb_flow * vel;\n\n        // divide velocity by range, subtract body rates and apply scale factor to\n        // get predicted sensed angular optical rates relative to X and Y sensor axes\n        losPred[0] =  flowStates[0]*( relVelSensor.y / range) - omegaAcrossFlowTime[0];\n        losPred[1] =  flowStates[0]*(-relVelSensor.x / range) - omegaAcrossFlowTime[1];\n\n        // calculate innovations\n        auxFlowObsInnov[0] = losPred[0] - flowRadXY[0];\n        auxFlowObsInnov[1] = losPred[1] - flowRadXY[1];\n\n        // calculate Kalman gains\n        SH_OPT[0] = sq(q0) - sq(q1) - sq(q2) + sq(q3);\n        SH_OPT[1] = vel.x*(sq(q0) + sq(q1) - sq(q2) - sq(q3)) + vel.y*(2*q0*q3 + 2*q1*q2) - vel.z*(2*q0*q2 - 2*q1*q3);\n        SH_OPT[2] = vel.y*(sq(q0) - sq(q1) + sq(q2) - sq(q3)) - vel.x*(2*q0*q3 - 2*q1*q2) + vel.z*(2*q0*q1 + 2*q2*q3);\n        SH_OPT[3] = statesAtFlowTime[9] - flowStates[1];\n        SH_OPT[4] = 1.0f/sq(SH_OPT[3]);\n        SH_OPT[5] = 1.0f/SH_OPT[3];\n        float SH015 = SH_OPT[0]*SH_OPT[1]*SH_OPT[5];\n        float SH025 = SH_OPT[0]*SH_OPT[2]*SH_OPT[5];\n        float SH014 = SH_OPT[0]*SH_OPT[1]*SH_OPT[4];\n        float SH024 = SH_OPT[0]*SH_OPT[2]*SH_OPT[4];\n        SK_OPT[0] = 1.0f/(R_LOS + SH015*(Popt[0][0]*SH015 + Popt[1][0]*flowStates[0]*SH014) + flowStates[0]*SH014*(Popt[0][1]*SH015 + Popt[1][1]*flowStates[0]*SH014));\n        SK_OPT[1] = 1.0f/(R_LOS + SH025*(Popt[0][0]*SH025 + Popt[1][0]*flowStates[0]*SH024) + flowStates[0]*SH024*(Popt[0][1]*SH025 + Popt[1][1]*flowStates[0]*SH024));\n        SK_OPT[2] = SH_OPT[0];\n        if (!inhibitScaleState) {\n            K_OPT[0][0] = -SK_OPT[1]*(Popt[0][0]*SH_OPT[2]*SH_OPT[5]*SK_OPT[2] + Popt[0][1]*flowStates[0]*SH_OPT[2]*SH_OPT[4]*SK_OPT[2]);\n            K_OPT[0][1] =  SK_OPT[0]*(Popt[0][0]*SH_OPT[1]*SH_OPT[5]*SK_OPT[2] + Popt[0][1]*flowStates[0]*SH_OPT[1]*SH_OPT[4]*SK_OPT[2]);\n        } else {\n            K_OPT[0][0] = 0.0f;\n            K_OPT[0][1] = 0.0f;\n        }\n        if (!inhibitGndState) {\n            K_OPT[1][0] = -SK_OPT[1]*(Popt[1][0]*SH_OPT[2]*SH_OPT[5]*SK_OPT[2] + Popt[1][1]*flowStates[0]*SH_OPT[2]*SH_OPT[4]*SK_OPT[2]);\n            K_OPT[1][1] =  SK_OPT[0]*(Popt[1][0]*SH_OPT[1]*SH_OPT[5]*SK_OPT[2] + Popt[1][1]*flowStates[0]*SH_OPT[1]*SH_OPT[4]*SK_OPT[2]);\n        } else {\n            K_OPT[1][0] = 0.0f;\n            K_OPT[1][1] = 0.0f;\n        }\n\n        // calculate innovation variances\n        auxFlowObsInnovVar[0] = 1.0f/SK_OPT[1];\n        auxFlowObsInnovVar[1] = 1.0f/SK_OPT[0];\n\n        // calculate observations jacobians\n        H_OPT[0][0] = -SH025;\n        H_OPT[0][1] = -flowStates[0]*SH024;\n        H_OPT[1][0] = SH015;\n        H_OPT[1][1] = flowStates[0]*SH014;\n\n        // Check the innovation for consistency and don't fuse if > threshold\n        for (uint8_t obsIndex = 0; obsIndex < 2; obsIndex++) {\n\n            // calculate the innovation consistency test ratio\n            auxFlowTestRatio[obsIndex] = sq(auxFlowObsInnov[obsIndex]) / (sq(auxFlowInnovGate) * auxFlowObsInnovVar[obsIndex]);\n            if (auxFlowTestRatio[obsIndex] < 1.0f) {\n                // correct the state\n                for (uint8_t i = 0; i < 2 ; i++) {\n                    flowStates[i] -= K_OPT[i][obsIndex] * auxFlowObsInnov[obsIndex];\n                }\n                // constrain the states\n                flowStates[0] = ConstrainFloat(flowStates[0], 0.1f, 10.0f);\n                flowStates[1] = std::max(flowStates[1], statesAtFlowTime[9] + minFlowRng);\n\n                // correct the covariance matrix\n                for (uint8_t i = 0; i < 2 ; i++) {\n                    HP[i] = 0.0f;\n                    for (uint8_t j = 0; j < 2 ; j++) {\n                        HP[i] += H_OPT[obsIndex][j] * P[j][i];\n                    }\n                }\n                for (uint8_t i = 0; i < 2 ; i++) {\n                    for (uint8_t j = 0; j < 2 ; j++) {\n                        nextPopt[i][j] = P[i][j] - K_OPT[i][obsIndex] * HP[j];\n                    }\n                }\n\n                // prevent the state variances from becoming negative and maintain symmetry\n                Popt[0][0] = std::max(nextPopt[0][0],0.0f);\n                Popt[1][1] = std::max(nextPopt[1][1],0.0f);\n                Popt[0][1] = 0.5f * (nextPopt[0][1] + nextPopt[1][0]);\n                Popt[1][0] = Popt[0][1];\n            }\n        }\n    }\n\n}\n\nvoid AttPosEKF::zeroCols(float (&covMat)[EKF_STATE_ESTIMATES][EKF_STATE_ESTIMATES], uint8_t first, uint8_t last)\n{\n    uint8_t row;\n    uint8_t col;\n    for (col=first; col<=last; col++)\n    {\n        for (row=0; row < EKF_STATE_ESTIMATES; row++)\n        {\n            covMat[row][col] = 0.0;\n        }\n    }\n}\n\n// Store states in a history array along with time stamp\nvoid AttPosEKF::StoreStates(uint64_t timestamp_ms)\n{\n    for (size_t i=0; i<EKF_STATE_ESTIMATES; i++)\n        storedStates[i][storeIndex] = states[i];\n    storedOmega[0][storeIndex] = angRate.x;\n    storedOmega[1][storeIndex] = angRate.y;\n    storedOmega[2][storeIndex] = angRate.z;\n    statetimeStamp[storeIndex] = timestamp_ms;\n    storeIndex++;\n    if (storeIndex == EKF_DATA_BUFFER_SIZE)\n        storeIndex = 0;\n}\n\nvoid AttPosEKF::ResetStoredStates()\n{\n    // reset all stored states\n    memset(&storedStates[0][0], 0, sizeof(storedStates));\n    memset(&storedOmega[0][0], 0, sizeof(storedOmega));\n    memset(&statetimeStamp[0], 0, sizeof(statetimeStamp));\n\n    // reset store index to first\n    storeIndex = 0;\n\n    statetimeStamp[storeIndex] = millis();\n\n    // increment to next storage index\n    storeIndex++;\n}\n\n// Output the state vector stored at the time that best matches that specified by msec\nint AttPosEKF::RecallStates(float* statesForFusion, uint64_t msec)\n{\n    int ret = 0;\n\n    int64_t bestTimeDelta = 200;\n    size_t bestStoreIndex = 0;\n    for (size_t storeIndexLocal = 0; storeIndexLocal < EKF_DATA_BUFFER_SIZE; storeIndexLocal++)\n    {\n        // Work around a GCC compiler bug - we know 64bit support on ARM is\n        // sketchy in GCC.\n        uint64_t timeDelta;\n\n        if (msec > statetimeStamp[storeIndexLocal]) {\n            timeDelta = msec - statetimeStamp[storeIndexLocal];\n        } else {\n            timeDelta = statetimeStamp[storeIndexLocal] - msec;\n        }\n\n        if (timeDelta < (uint64_t)bestTimeDelta)\n        {\n            bestStoreIndex = storeIndexLocal;\n            bestTimeDelta = timeDelta;\n        }\n    }\n    if (bestTimeDelta < 200) // only output stored state if < 200 msec retrieval error\n    {\n        for (size_t i=0; i < EKF_STATE_ESTIMATES; i++) {\n            if (isfinite(storedStates[i][bestStoreIndex])) {\n                statesForFusion[i] = storedStates[i][bestStoreIndex];\n            } else if (isfinite(states[i])) {\n                statesForFusion[i] = states[i];\n            } else {\n                // There is not much we can do here, except reporting the error we just\n                // found.\n                ret++;\n            }\n        }\n    }\n    else // otherwise output current state\n    {\n        for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++) {\n            if (isfinite(states[i])) {\n                statesForFusion[i] = states[i];\n            } else {\n                ret++;\n            }\n        }\n    }\n\n    return ret;\n}\n\nvoid AttPosEKF::RecallOmega(float* omegaForFusion, uint64_t msec)\n{\n    // work back in time and calculate average angular rate over the time interval\n    for (size_t i=0; i < 3; i++) {\n        omegaForFusion[i] = 0.0f;\n    }\n    uint8_t sumIndex = 0;\n    int64_t timeDelta;\n    for (size_t storeIndexLocal = 0; storeIndexLocal < EKF_DATA_BUFFER_SIZE; storeIndexLocal++)\n    {\n        // calculate the average of all samples younger than msec\n        timeDelta = statetimeStamp[storeIndexLocal] - msec;\n        if (timeDelta > 0)\n        {\n            for (size_t i=0; i < 3; i++) {\n                omegaForFusion[i] += storedOmega[i][storeIndexLocal];\n            }\n            sumIndex += 1;\n        }\n    }\n    if (sumIndex >= 1) {\n        for (size_t i=0; i < 3; i++) {\n            omegaForFusion[i] = omegaForFusion[i] / float(sumIndex);\n        }\n    } else {\n        omegaForFusion[0] = angRate.x;\n        omegaForFusion[1] = angRate.y;\n        omegaForFusion[2] = angRate.z;\n    }\n}\n\n#if 0\nvoid AttPosEKF::quat2Tnb(Mat3f &Tnb, const float (&quat)[4])\n{\n    // Calculate the nav to body cosine matrix\n    float q00 = sq(quat[0]);\n    float q11 = sq(quat[1]);\n    float q22 = sq(quat[2]);\n    float q33 = sq(quat[3]);\n    float q01 =  quat[0]*quat[1];\n    float q02 =  quat[0]*quat[2];\n    float q03 =  quat[0]*quat[3];\n    float q12 =  quat[1]*quat[2];\n    float q13 =  quat[1]*quat[3];\n    float q23 =  quat[2]*quat[3];\n\n    Tnb.x.x = q00 + q11 - q22 - q33;\n    Tnb.y.y = q00 - q11 + q22 - q33;\n    Tnb.z.z = q00 - q11 - q22 + q33;\n    Tnb.y.x = 2*(q12 - q03);\n    Tnb.z.x = 2*(q13 + q02);\n    Tnb.x.y = 2*(q12 + q03);\n    Tnb.z.y = 2*(q23 - q01);\n    Tnb.x.z = 2*(q13 - q02);\n    Tnb.y.z = 2*(q23 + q01);\n}\n#endif\n\nvoid AttPosEKF::quat2Tbn(Mat3f &Tbn_ret, const float (&quat)[4])\n{\n    // Calculate the body to nav cosine matrix\n    float q00 = sq(quat[0]);\n    float q11 = sq(quat[1]);\n    float q22 = sq(quat[2]);\n    float q33 = sq(quat[3]);\n    float q01 =  quat[0]*quat[1];\n    float q02 =  quat[0]*quat[2];\n    float q03 =  quat[0]*quat[3];\n    float q12 =  quat[1]*quat[2];\n    float q13 =  quat[1]*quat[3];\n    float q23 =  quat[2]*quat[3];\n\n    Tbn_ret.x.x = q00 + q11 - q22 - q33;\n    Tbn_ret.y.y = q00 - q11 + q22 - q33;\n    Tbn_ret.z.z = q00 - q11 - q22 + q33;\n    Tbn_ret.x.y = 2*(q12 - q03);\n    Tbn_ret.x.z = 2*(q13 + q02);\n    Tbn_ret.y.x = 2*(q12 + q03);\n    Tbn_ret.y.z = 2*(q23 - q01);\n    Tbn_ret.z.x = 2*(q13 - q02);\n    Tbn_ret.z.y = 2*(q23 + q01);\n}\n\nvoid AttPosEKF::eul2quat(float (&quat)[4], const float (&eul)[3])\n{\n    float u1 = cos(0.5f*eul[0]);\n    float u2 = cos(0.5f*eul[1]);\n    float u3 = cos(0.5f*eul[2]);\n    float u4 = sin(0.5f*eul[0]);\n    float u5 = sin(0.5f*eul[1]);\n    float u6 = sin(0.5f*eul[2]);\n    quat[0] = u1*u2*u3+u4*u5*u6;\n    quat[1] = u4*u2*u3-u1*u5*u6;\n    quat[2] = u1*u5*u3+u4*u2*u6;\n    quat[3] = u1*u2*u6-u4*u5*u3;\n}\n\nvoid AttPosEKF::quat2eul(float (&y)[3], const float (&u)[4])\n{\n    y[0] = atan2f((2.0f*(u[2]*u[3]+u[0]*u[1])) , (u[0]*u[0]-u[1]*u[1]-u[2]*u[2]+u[3]*u[3]));\n    y[1] = -asinf(2.0f*(u[1]*u[3]-u[0]*u[2]));\n    y[2] = atan2f((2.0f*(u[1]*u[2]+u[0]*u[3])) , (u[0]*u[0]+u[1]*u[1]-u[2]*u[2]-u[3]*u[3]));\n}\n\nvoid AttPosEKF::calcvelNED(float (&velNED)[3], float gpsCourse, float gpsGndSpd, float gpsVelD)\n{\n    velNED[0] = gpsGndSpd*cosf(gpsCourse);\n    velNED[1] = gpsGndSpd*sinf(gpsCourse);\n    velNED[2] = gpsVelD;\n}\n\nvoid AttPosEKF::calcposNED(float (&posNED)[3], double lat, double lon, float hgt, double latReference, double lonReference, float hgtReference)\n{\n    posNED[0] = earthRadius * (lat - latReference);\n    posNED[1] = earthRadius * cos(latReference) * (lon - lonReference);\n    posNED[2] = -(hgt - hgtReference);\n}\n\nvoid AttPosEKF::calcLLH(float posNED[3], double &lat, double &lon, float &hgt, double latRef, double lonRef, float hgtRef)\n{\n    lat = latRef + (double)posNED[0] * earthRadiusInv;\n    lon = lonRef + (double)posNED[1] * earthRadiusInv / cos(latRef);\n    hgt = hgtRef - posNED[2];\n}\n\nvoid AttPosEKF::setOnGround(const bool isLanded)\n{\n    _onGround = isLanded;\n\n    if (staticMode) {\n        staticMode = (!refSet || (GPSstatus < GPS_FIX_3D));\n    }\n    // don't update wind states if there is no airspeed measurement\n    if (_onGround || !useAirspeed) {\n        inhibitWindStates = true;\n    } else {\n        inhibitWindStates = false;\n    }\n\n    //Check if we are accelerating forward, only then is the mag offset is observable\n    bool isMovingForward = _accNavMagHorizontal > 0.5f;\n\n    // don't update magnetic field states if on ground or not using compass\n    inhibitMagStates = (!useCompass || _onGround) || (!_isFixedWing && !isMovingForward);\n\n    // don't update terrain offset state if there is no range finder and flying at low velocity or without GPS\n    if ((_onGround || !useGPS) && !useRangeFinder) {\n        inhibitGndState = true;\n    } else {\n        inhibitGndState = false;\n    }\n\n    // don't update terrain offset state if there is no range finder and flying at low velocity, or without GPS, as it is poorly observable\n    if ((_onGround || (globalTimeStamp_ms - lastFixTime_ms) > 1000) && !useRangeFinder) {\n        inhibitGndState = true;\n    } else {\n        inhibitGndState = false;\n    }\n\n    // Don't update focal length offset state if there is no range finder or optical flow sensor\n    // we need both sensors to do this estimation\n    if (!useRangeFinder || !useOpticalFlow) {\n        inhibitScaleState = true;\n    } else {\n        inhibitScaleState = false;\n    }\n}\n\nvoid AttPosEKF::calcEarthRateNED(Vector3f &omega, float latitude)\n{\n    //Define Earth rotation vector in the NED navigation frame\n    omega.x  = earthRate*cosf(latitude);\n    omega.y  = 0.0f;\n    omega.z  = -earthRate*sinf(latitude);\n}\n\nvoid AttPosEKF::CovarianceInit()\n{\n    // Calculate the initial covariance matrix P\n    P[0][0]   = 0.25f * sq(1.0f*deg2rad);\n    P[1][1]   = 0.25f * sq(1.0f*deg2rad);\n    P[2][2]   = 0.25f * sq(1.0f*deg2rad);\n    P[3][3]   = 0.25f * sq(10.0f*deg2rad);\n    P[4][4]   = sq(0.7f);\n    P[5][5]   = P[4][4];\n    P[6][6]   = sq(0.7f);\n    P[7][7]   = sq(15.0f);\n    P[8][8]   = P[7][7];\n    P[9][9]   = sq(5.0f);\n    P[10][10] = sq(0.1f*deg2rad*dtIMU);\n    P[11][11] = P[10][10];\n    P[12][12] = P[10][10];\n    P[13][13] = sq(0.2f*dtIMU);\n    P[14][14] = sq(0.0f);\n    P[15][15]  = P[14][14];\n    P[16][16] = sq(0.02f);\n    P[17][17] = P[16][16];\n    P[18][18] = P[16][16];\n    P[19][19] = sq(0.02f);\n    P[20][20] = P[19][19];\n    P[21][21] = P[19][19];\n\n    fScaleFactorVar = 0.001f; // focal length scale factor variance\n    Popt[0][0] = 0.001f;\n}\n\nfloat AttPosEKF::ConstrainFloat(float val, float min_val, float max_val)\n{\n    float ret;\n    if (val > max_val) {\n        ret = max_val;\n        ekf_debug(\"> max: %8.4f, val: %8.4f\", (double)max_val, (double)val);\n    } else if (val < min_val) {\n        ret = min_val;\n        ekf_debug(\"< min: %8.4f, val: %8.4f\", (double)min_val, (double)val);\n    } else {\n        ret = val;\n    }\n\n    if (!isfinite(val)) {\n        //ekf_debug(\"constrain: non-finite!\");\n    }\n\n    return ret;\n}\n\nvoid AttPosEKF::ConstrainVariances()\n{\n    if (!numericalProtection) {\n        return;\n    }\n\n    // State vector:\n    // 0-3: quaternions (q0, q1, q2, q3)\n    // 4-6: Velocity - m/sec (North, East, Down)\n    // 7-9: Position - m (North, East, Down)\n    // 10-12: Delta Angle bias - rad (X,Y,Z)\n    // 13: Delta Velocity bias - m/s (Z)\n    // 14-15: Wind Vector  - m/sec (North,East)\n    // 16-18: Earth Magnetic Field Vector - gauss (North, East, Down)\n    // 19-21: Body Magnetic Field Vector - gauss (X,Y,Z)\n\n    // Constrain quaternion variances\n    for (size_t i = 0; i <= 3; i++) {\n        P[i][i] = ConstrainFloat(P[i][i], 0.0f, 1.0f);\n    }\n\n    // Constrain velocity variances\n    for (size_t i = 4; i <= 6; i++) {\n        P[i][i] = ConstrainFloat(P[i][i], 0.0f, 1.0e3f);\n    }\n\n    // Constrain position variances\n    for (size_t i = 7; i <= 9; i++) {\n        P[i][i] = ConstrainFloat(P[i][i], 0.0f, 1.0e6f);\n    }\n\n    // Constrain delta angle bias variances\n    for (size_t i = 10; i <= 12; i++) {\n        P[i][i] = ConstrainFloat(P[i][i], 0.0f, sq(0.12f * dtIMU));\n    }\n\n    // Constrain delta velocity bias variance\n    P[13][13] = ConstrainFloat(P[13][13], 0.0f, sq(1.0f * dtIMU));\n\n    // Wind velocity variances\n    for (size_t i = 14; i <= 15; i++) {\n        P[i][i] = ConstrainFloat(P[i][i], 0.0f, 1.0e3f);\n    }\n\n    // Earth magnetic field variances\n    for (size_t i = 16; i <= 18; i++) {\n        P[i][i] = ConstrainFloat(P[i][i], 0.0f, 1.0f);\n    }\n\n    // Body magnetic field variances\n    for (size_t i = 19; i <= 21; i++) {\n        P[i][i] = ConstrainFloat(P[i][i], 0.0f, 1.0f);\n    }\n\n}\n\nvoid AttPosEKF::ConstrainStates()\n{\n    if (!numericalProtection) {\n        return;\n    }\n\n    // State vector:\n    // 0-3: quaternions (q0, q1, q2, q3)\n    // 4-6: Velocity - m/sec (North, East, Down)\n    // 7-9: Position - m (North, East, Down)\n    // 10-12: Delta Angle bias - rad (X,Y,Z)\n    // 13: Delta Velocity bias - m/s (Z)\n    // 14-15: Wind Vector  - m/sec (North,East)\n    // 16-18: Earth Magnetic Field Vector - gauss (North, East, Down)\n    // 19-21: Body Magnetic Field Vector - gauss (X,Y,Z)\n\n    // Constrain quaternion\n    for (size_t i = 0; i <= 3; i++) {\n        states[i] = ConstrainFloat(states[i], -1.0f, 1.0f);\n    }\n\n    // Constrain velocities to what GPS can do for us\n    for (size_t i = 4; i <= 6; i++) {\n        states[i] = ConstrainFloat(states[i], -5.0e2f, 5.0e2f);\n    }\n\n    // Constrain position to a reasonable vehicle range (in meters)\n    for (size_t i = 7; i <= 8; i++) {\n        states[i] = ConstrainFloat(states[i], -1.0e6f, 1.0e6f);\n    }\n\n    // Constrain altitude\n    // NOT FOR FLIGHT : Upper value of 0.0 is a temporary fix to get around lack of range finder data during development testing\n    states[9] = ConstrainFloat(states[9], -4.0e4f, 4.0e4f);\n\n    // Angle bias limit - set to 8 degrees / sec\n    for (size_t i = 10; i <= 12; i++) {\n        states[i] = ConstrainFloat(states[i], -0.12f * dtIMU, 0.12f * dtIMU);\n    }\n\n    // Constrain delta velocity bias\n    states[13] = ConstrainFloat(states[13], -1.0f * dtIMU, 1.0f * dtIMU);\n\n    // Wind velocity limits - assume 120 m/s max velocity\n    for (size_t i = 14; i <= 15; i++) {\n        states[i] = ConstrainFloat(states[i], -120.0f, 120.0f);\n    }\n\n    // Earth magnetic field limits (in Gauss)\n    for (size_t i = 16; i <= 18; i++) {\n        states[i] = ConstrainFloat(states[i], -1.0f, 1.0f);\n    }\n\n    // Body magnetic field variances (in Gauss).\n    // the max offset should be in this range.\n    for (size_t i = 19; i <= 21; i++) {\n        states[i] = ConstrainFloat(states[i], -0.5f, 0.5f);\n    }\n\n}\n\nvoid AttPosEKF::ForceSymmetry()\n{\n    if (!numericalProtection) {\n        return;\n    }\n\n    // Force symmetry on the covariance matrix to prevent ill-conditioning\n    // of the matrix which would cause the filter to blow-up\n    for (size_t i = 1; i < EKF_STATE_ESTIMATES; i++)\n    {\n        for (uint8_t j = 0; j < i; j++)\n        {\n            P[i][j] = 0.5f * (P[i][j] + P[j][i]);\n            P[j][i] = P[i][j];\n\n            if ((fabsf(P[i][j]) > EKF_COVARIANCE_DIVERGED) ||\n                (fabsf(P[j][i]) > EKF_COVARIANCE_DIVERGED)) {\n                current_ekf_state.covariancesExcessive = true;\n                current_ekf_state.error |= true;\n                InitializeDynamic(velNED, magDeclination);\n                return;\n            }\n\n            float symmetric = 0.5f * (P[i][j] + P[j][i]);\n            P[i][j] = symmetric;\n            P[j][i] = symmetric;\n        }\n    }\n}\n\nbool AttPosEKF::GyroOffsetsDiverged()\n{\n    // Detect divergence by looking for rapid changes of the gyro offset\n    Vector3f current_bias;\n    current_bias.x = states[10];\n    current_bias.y = states[11];\n    current_bias.z = states[12];\n\n    Vector3f delta = current_bias - lastGyroOffset;\n    float delta_len = delta.length();\n    float delta_len_scaled = 0.0f;\n\n    // Protect against division by zero\n    if (delta_len > 0.0f) {\n        float cov_mag = ConstrainFloat((P[10][10] + P[11][11] + P[12][12]), 1e-12f, 1e-8f);\n        delta_len_scaled = (5e-7 / (double)cov_mag) * (double)delta_len / (double)dtIMU;\n    }\n\n    bool diverged = (delta_len_scaled > 1.0f);\n    lastGyroOffset = current_bias;\n    current_ekf_state.error |= diverged;\n    current_ekf_state.gyroOffsetsExcessive = diverged;\n\n    return diverged;\n}\n\nbool AttPosEKF::VelNEDDiverged()\n{\n    Vector3f current_vel;\n    current_vel.x = states[4];\n    current_vel.y = states[5];\n    current_vel.z = states[6];\n\n    Vector3f gps_vel;\n    gps_vel.x = velNED[0];\n    gps_vel.y = velNED[1];\n    gps_vel.z = velNED[2];\n\n    Vector3f delta = current_vel - gps_vel;\n    float delta_len = delta.length();\n\n    bool excessive = (delta_len > 20.0f);\n\n    current_ekf_state.error |= excessive;\n    current_ekf_state.velOffsetExcessive = excessive;\n\n    return excessive;\n}\n\nbool AttPosEKF::FilterHealthy()\n{\n    if (!statesInitialised) {\n        return false;\n    }\n\n    // XXX Check state vector for NaNs and ill-conditioning\n\n    // Check if any of the major inputs timed out\n    if (current_ekf_state.posTimeout || current_ekf_state.velTimeout || current_ekf_state.hgtTimeout) {\n        return false;\n    }\n\n    // Nothing fired, return ok.\n    return true;\n}\n\nvoid AttPosEKF::ResetPosition(void)\n{\n    if (staticMode) {\n        states[7] = 0;\n        states[8] = 0;\n    } else if (GPSstatus >= GPS_FIX_3D) {\n\n        // reset the states from the GPS measurements\n        states[7] = posNE[0];\n        states[8] = posNE[1];\n\n        // stored horizontal position states to prevent subsequent GPS measurements from being rejected\n        for (size_t i = 0; i < EKF_DATA_BUFFER_SIZE; ++i){\n            storedStates[7][i] = states[7];\n            storedStates[8][i] = states[8];\n        }        \n    }\n}\n\nvoid AttPosEKF::ResetHeight(void)\n{\n    // write to the state vector\n    states[9]   = -hgtMea;\n\n    // stored horizontal position states to prevent subsequent Barometer measurements from being rejected\n    for (size_t i = 0; i < EKF_DATA_BUFFER_SIZE; ++i){\n        storedStates[9][i] = states[9];\n    }    \n}\n\nvoid AttPosEKF::ResetVelocity(void)\n{\n    if (staticMode) {\n        states[4] = 0.0f;\n        states[5] = 0.0f;\n        states[6] = 0.0f;\n    } else if (GPSstatus >= GPS_FIX_3D) {\n        //Do not use Z velocity, we trust the Barometer history more\n\n        states[4]  = velNED[0]; // north velocity from last reading\n        states[5]  = velNED[1]; // east velocity from last reading\n\n        // stored horizontal position states to prevent subsequent GPS measurements from being rejected\n        for (size_t i = 0; i < EKF_DATA_BUFFER_SIZE; ++i){\n            storedStates[4][i] = states[4];\n            storedStates[5][i] = states[5];\n        }                \n    }\n}\n\nbool AttPosEKF::StatesNaN() {\n    bool err = false;\n\n    // check all integrators\n    if (!isfinite(summedDelAng.x) || !isfinite(summedDelAng.y) || !isfinite(summedDelAng.z)) {\n        current_ekf_state.angNaN = true;\n        ekf_debug(\"summedDelAng NaN: x: %f y: %f z: %f\", (double)summedDelAng.x, (double)summedDelAng.y, (double)summedDelAng.z);\n        err = true;\n        goto out;\n    } // delta angles\n\n    if (!isfinite(correctedDelAng.x) || !isfinite(correctedDelAng.y) || !isfinite(correctedDelAng.z)) {\n        current_ekf_state.angNaN = true;\n        ekf_debug(\"correctedDelAng NaN: x: %f y: %f z: %f\", (double)correctedDelAng.x, (double)correctedDelAng.y, (double)correctedDelAng.z);\n        err = true;\n        goto out;\n    } // delta angles\n\n    if (!isfinite(summedDelVel.x) || !isfinite(summedDelVel.y) || !isfinite(summedDelVel.z)) {\n        current_ekf_state.summedDelVelNaN = true;\n        ekf_debug(\"summedDelVel NaN: x: %f y: %f z: %f\", (double)summedDelVel.x, (double)summedDelVel.y, (double)summedDelVel.z);\n        err = true;\n        goto out;\n    } // delta velocities\n\n    // check all states and covariance matrices\n    for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++) {\n        for (size_t j = 0; j < EKF_STATE_ESTIMATES; j++) {\n            if (!isfinite(KH[i][j])) {\n\n                current_ekf_state.KHNaN = true;\n                err = true;\n                ekf_debug(\"KH NaN\");\n                goto out;\n            } //  intermediate result used for covariance updates\n\n            if (!isfinite(KHP[i][j])) {\n\n                current_ekf_state.KHPNaN = true;\n                err = true;\n                ekf_debug(\"KHP NaN\");\n                goto out;\n            } // intermediate result used for covariance updates\n\n            if (!isfinite(P[i][j])) {\n\n                current_ekf_state.covarianceNaN = true;\n                err = true;\n                ekf_debug(\"P NaN\");\n            } // covariance matrix\n        }\n\n        if (!isfinite(Kfusion[i])) {\n\n            current_ekf_state.kalmanGainsNaN = true;\n            ekf_debug(\"Kfusion NaN\");\n            err = true;\n            goto out;\n        } // Kalman gains\n\n        if (!isfinite(states[i])) {\n\n            current_ekf_state.statesNaN = true;\n            ekf_debug(\"states NaN: i: %u val: %f\", i, (double)states[i]);\n            err = true;\n            goto out;\n        } // state matrix\n    }\n\nout:\n    if (err) {\n        current_ekf_state.error |= true;\n    }\n\n    return err;\n\n}\n\nint AttPosEKF::CheckAndBound(struct ekf_status_report *last_error)\n{\n\n    // Store the old filter state\n    bool currStaticMode = staticMode;\n\n    // Limit reset rate to 5 Hz to allow the filter\n    // to settle\n    if (millis() - lastReset < 200) {\n        return 0;\n    }\n\n    if (ekfDiverged) {\n        ekfDiverged = false;\n    }\n\n    int ret = 0;\n\n    // Reset the filter if the states went NaN\n    if (StatesNaN()) {\n        ekf_debug(\"re-initializing dynamic\");\n\n        // Reset and fill error report\n	    InitializeDynamic(velNED, magDeclination);\n\n        ret = 1;\n    }\n\n    // Reset the filter if the IMU data is too old\n    if (dtIMU > 0.3f) {\n\n        current_ekf_state.imuTimeout = true;\n\n        // Fill error report\n        GetFilterState(&last_ekf_error);\n\n        ResetStoredStates();\n        ResetVelocity();\n        ResetPosition();\n        ResetHeight();\n\n        // Timeout cleared with this reset\n        current_ekf_state.imuTimeout = false;\n\n        // that's all we can do here, return\n        ret = 2;\n    }\n\n    // Check if we switched between states\n    if (currStaticMode != staticMode) {\n        // Fill error report, but not setting error flag\n        GetFilterState(&last_ekf_error);\n\n        ResetStoredStates();\n        ResetVelocity();\n        ResetPosition();\n        ResetHeight();\n\n        ret = 0;\n    }\n\n    // Reset the filter if gyro offsets are excessive\n    if (GyroOffsetsDiverged()) {\n\n        // Reset and fill error report\n        InitializeDynamic(velNED, magDeclination);\n\n        // that's all we can do here, return\n        ret = 4;\n    }\n\n    // Reset the filter if it diverges too far from GPS\n    if (VelNEDDiverged()) {\n\n        // Reset and fill error report\n        InitializeDynamic(velNED, magDeclination);\n\n        // that's all we can do here, return\n        ret = 5;\n    }\n\n    // The excessive covariance detection already\n    // reset the filter. Just need to report here.\n    if (last_ekf_error.covariancesExcessive) {\n        ret = 6;\n    }\n\n    if (ret) {\n        ekfDiverged = true;\n        lastReset = millis();\n\n        // This reads the last error and clears it\n        GetLastErrorState(last_error);\n    }\n\n    return ret;\n}\n\nvoid AttPosEKF::AttitudeInit(float ax, float ay, float az, float mx, float my, float mz, float declination, float *initQuat)\n{\n    float initialRoll, initialPitch;\n    float cosRoll, sinRoll, cosPitch, sinPitch;\n    float magX, magY;\n    float initialHdg, cosHeading, sinHeading;\n\n    initialRoll = atan2f(-ay, -az);\n    initialPitch = atan2f(ax, -az);\n\n    cosRoll = cosf(initialRoll);\n    sinRoll = sinf(initialRoll);\n    cosPitch = cosf(initialPitch);\n    sinPitch = sinf(initialPitch);\n\n    magX = mx * cosPitch + my * sinRoll * sinPitch + mz * cosRoll * sinPitch;\n\n    magY = my * cosRoll - mz * sinRoll;\n\n    initialHdg = atan2f(-magY, magX);\n    /* true heading is the mag heading minus declination */\n    initialHdg += declination;\n\n    cosRoll = cosf(initialRoll * 0.5f);\n    sinRoll = sinf(initialRoll * 0.5f);\n\n    cosPitch = cosf(initialPitch * 0.5f);\n    sinPitch = sinf(initialPitch * 0.5f);\n\n    cosHeading = cosf(initialHdg * 0.5f);\n    sinHeading = sinf(initialHdg * 0.5f);\n\n    initQuat[0] = cosRoll * cosPitch * cosHeading + sinRoll * sinPitch * sinHeading;\n    initQuat[1] = sinRoll * cosPitch * cosHeading - cosRoll * sinPitch * sinHeading;\n    initQuat[2] = cosRoll * sinPitch * cosHeading + sinRoll * cosPitch * sinHeading;\n    initQuat[3] = cosRoll * cosPitch * sinHeading - sinRoll * sinPitch * cosHeading;\n\n    /* normalize */\n    float norm = sqrtf(initQuat[0]*initQuat[0] + initQuat[1]*initQuat[1] + initQuat[2]*initQuat[2] + initQuat[3]*initQuat[3]);\n\n    initQuat[0] /= norm;\n    initQuat[1] /= norm;\n    initQuat[2] /= norm;\n    initQuat[3] /= norm;\n}\n\nvoid AttPosEKF::InitializeDynamic(float (&initvelNED)[3], float declination)\n{\n    if (current_ekf_state.error) {\n        GetFilterState(&last_ekf_error);\n    }\n\n    ZeroVariables();\n\n    // Reset error states\n    current_ekf_state.error = false;\n    current_ekf_state.angNaN = false;\n    current_ekf_state.summedDelVelNaN = false;\n    current_ekf_state.KHNaN = false;\n    current_ekf_state.KHPNaN = false;\n    current_ekf_state.PNaN = false;\n    current_ekf_state.covarianceNaN = false;\n    current_ekf_state.kalmanGainsNaN = false;\n    current_ekf_state.statesNaN = false;\n\n    current_ekf_state.velHealth = true;\n    current_ekf_state.posHealth = true;\n    current_ekf_state.hgtHealth = true;\n    current_ekf_state.hgtHealth2 = true;\n\n    current_ekf_state.velTimeout = false;\n    current_ekf_state.posTimeout = false;\n    current_ekf_state.hgtTimeout = false;\n\n    fuseVelData = false;\n    fusePosData = false;\n    fuseHgtData = false;\n    fuseCamData = false;\n    fuseMagData = false;\n    fuseVtasData = false;\n\n    // Fill variables with valid data\n    velNED[0] = initvelNED[0];\n    velNED[1] = initvelNED[1];\n    velNED[2] = initvelNED[2];\n    magDeclination = declination;\n\n    // Calculate initial filter quaternion states from raw measurements\n    float initQuat[4];\n    Vector3f initMagXYZ;\n    initMagXYZ   = magData - magBias;\n    AttitudeInit(accel.x, accel.y, accel.z, initMagXYZ.x, initMagXYZ.y, initMagXYZ.z, declination, initQuat);\n\n    // Calculate initial Tbn matrix and rotate Mag measurements into NED\n    // to set initial NED magnetic field states\n    quat2Tbn(Tbn, initQuat);\n    Tnb = Tbn.transpose();\n    Vector3f initMagNED;\n    initMagNED.x = Tbn.x.x*initMagXYZ.x + Tbn.x.y*initMagXYZ.y + Tbn.x.z*initMagXYZ.z;\n    initMagNED.y = Tbn.y.x*initMagXYZ.x + Tbn.y.y*initMagXYZ.y + Tbn.y.z*initMagXYZ.z;\n    initMagNED.z = Tbn.z.x*initMagXYZ.x + Tbn.z.y*initMagXYZ.y + Tbn.z.z*initMagXYZ.z;\n\n    magstate.q0 = initQuat[0];\n    magstate.q1 = initQuat[1];\n    magstate.q2 = initQuat[2];\n    magstate.q3 = initQuat[3];\n    magstate.magN = initMagNED.x;\n    magstate.magE = initMagNED.y;\n    magstate.magD = initMagNED.z;\n    magstate.magXbias = magBias.x;\n    magstate.magYbias = magBias.y;\n    magstate.magZbias = magBias.z;\n    magstate.R_MAG = sq(magMeasurementSigma);\n    magstate.DCM = Tbn;\n\n    // write to state vector\n    for (uint8_t j=0; j<=3; j++) states[j] = initQuat[j]; // quaternions\n    for (uint8_t j=4; j<=6; j++) states[j] = initvelNED[j-4]; // velocities\n    // positions:\n    states[7] = posNE[0];\n    states[8] = posNE[1];\n    states[9] = -hgtMea;\n    for (uint8_t j=10; j<=15; j++) states[j] = 0.0f; // dAngBias, dVelBias, windVel\n    states[16] = initMagNED.x; // Magnetic Field North\n    states[17] = initMagNED.y; // Magnetic Field East\n    states[18] = initMagNED.z; // Magnetic Field Down\n    states[19] = magBias.x; // Magnetic Field Bias X\n    states[20] = magBias.y; // Magnetic Field Bias Y\n    states[21] = magBias.z; // Magnetic Field Bias Z\n\n    ResetStoredStates();\n    ResetVelocity();\n    ResetPosition();\n    ResetHeight();\n\n    // initialise focal length scale factor estimator states\n    flowStates[0] = 1.0f;\n\n    statesInitialised = true;\n\n    // initialise the covariance matrix\n    CovarianceInit();\n\n    //Define Earth rotation vector in the NED navigation frame\n    calcEarthRateNED(earthRateNED, latRef);\n\n}\n\nvoid AttPosEKF::InitialiseFilter(float (&initvelNED)[3], double referenceLat, double referenceLon, float referenceHgt, float declination)\n{\n    // store initial lat,long and height\n    latRef = referenceLat;\n    lonRef = referenceLon;\n    hgtRef = referenceHgt;\n    refSet = true;\n\n    // we are at reference position, so measurement must be zero\n    posNE[0] = 0.0f;\n    posNE[1] = 0.0f;\n\n    // we are at an unknown, possibly non-zero altitude - so altitude\n    // is not reset (hgtMea)\n\n    // the baro offset must be this difference now\n    baroHgtOffset = baroHgt - referenceHgt;\n\n    InitializeDynamic(initvelNED, declination);\n}\n\nvoid AttPosEKF::ZeroVariables()\n{\n\n    // Initialize on-init initialized variables\n    dtIMUfilt = ConstrainFloat(dtIMU, 0.001f, 0.02f);\n    dtVelPosFilt = ConstrainFloat(dtVelPos, 0.04f, 0.5f);\n    dtGpsFilt = 1.0f / 5.0f;\n    dtHgtFilt = 1.0f / 100.0f;\n    storeIndex = 0;\n\n    lastVelPosFusion = millis();\n\n    // Do the data structure init\n    for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++) {\n        for (size_t j = 0; j < EKF_STATE_ESTIMATES; j++) {\n            KH[i][j] = 0.0f; //  intermediate result used for covariance updates\n            KHP[i][j] = 0.0f; // intermediate result used for covariance updates\n            P[i][j] = 0.0f; // covariance matrix\n        }\n\n        Kfusion[i] = 0.0f; // Kalman gains\n        states[i] = 0.0f; // state matrix\n    }\n\n    // initialise the variables for the focal length scale factor to unity\n    flowStates[0] = 1.0f;\n\n    correctedDelAng.zero();\n    summedDelAng.zero();\n    summedDelVel.zero();\n    dAngIMU.zero();\n    dVelIMU.zero();\n    lastGyroOffset.zero();\n\n    // initialise states used by OpticalFlowEKF\n    flowStates[0] = 1.0f;\n    flowStates[1] = 0.0f;\n\n    for (size_t i = 0; i < EKF_DATA_BUFFER_SIZE; i++) {\n\n        for (size_t j = 0; j < EKF_STATE_ESTIMATES; j++) {\n            storedStates[j][i] = 0.0f;\n        }\n\n        statetimeStamp[i] = 0;\n    }\n\n    memset(&magstate, 0, sizeof(magstate));\n    magstate.q0 = 1.0f;\n    magstate.DCM.identity();\n\n    memset(&current_ekf_state, 0, sizeof(current_ekf_state));\n\n}\n\nvoid AttPosEKF::GetFilterState(struct ekf_status_report *err)\n{\n\n    // Copy states\n    for (size_t i = 0; i < EKF_STATE_ESTIMATES; i++) {\n        current_ekf_state.states[i] = states[i];\n    }\n    current_ekf_state.n_states = EKF_STATE_ESTIMATES;\n    current_ekf_state.onGround = _onGround;\n    current_ekf_state.staticMode = staticMode;\n    current_ekf_state.useCompass = useCompass;\n    current_ekf_state.useAirspeed = useAirspeed;\n\n    memcpy(err, &current_ekf_state, sizeof(*err));\n\n    // err->velHealth = current_ekf_state.velHealth;\n    // err->posHealth = current_ekf_state.posHealth;\n    // err->hgtHealth = current_ekf_state.hgtHealth;\n    // err->velTimeout = current_ekf_state.velTimeout;\n    // err->posTimeout = current_ekf_state.posTimeout;\n    // err->hgtTimeout = current_ekf_state.hgtTimeout;\n}\n\nvoid AttPosEKF::GetLastErrorState(struct ekf_status_report *last_error)\n{\n    memcpy(last_error, &last_ekf_error, sizeof(*last_error));\n    memset(&last_ekf_error, 0, sizeof(last_ekf_error));\n}\n\nvoid AttPosEKF::setIsFixedWing(const bool fixedWing)\n{\n    _isFixedWing = fixedWing;\n}\n",
			"file": "src/modules/ekf_att_pos_estimator/estimator_22states.cpp",
			"file_size": 222270,
			"file_write_time": 1433858988000000,
			"settings":
			{
				"buffer_size": 222269,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/ekf_att_pos_estimator/estimator_22states.h",
			"settings":
			{
				"buffer_size": 17228,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/ekf_att_pos_estimator/AttitudePositionEstimatorEKF.h",
			"settings":
			{
				"buffer_size": 11929,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_params.c",
			"settings":
			{
				"buffer_size": 7330,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/uORB/topics/vision_position_estimate.h",
			"settings":
			{
				"buffer_size": 3079,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/ekf_att_pos_estimator/estimator_utilities.h",
			"settings":
			{
				"buffer_size": 3775,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/ekf_att_pos_estimator/estimator_utilities.cpp",
			"settings":
			{
				"buffer_size": 6071,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/uORB/topics/vehicle_attitude.h",
			"settings":
			{
				"buffer_size": 2460,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/uORB/topics/vehicle_local_position.h",
			"settings":
			{
				"buffer_size": 2624,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/modules/uORB/topics/sensor_combined.h",
			"settings":
			{
				"buffer_size": 7555,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/home/aghilas/firmwarepx4/Firmware/mavlink/include/mavlink/v1.0/pixhawk/mavlink_msg_raw_aux.h",
		"/home/aghilas/firmwarepx4/Firmware/ROMFS/px4fmu_common/init.d/rc.mc_apps",
		"/home/aghilas/firmwarepx4/Firmware/src/modules/uORB/topics/vision_position_estimate.h",
		"/home/aghilas/firmwarepx4/Firmware/src/drivers/drv_baro.h",
		"/home/aghilas/firmwarepx4/Firmware/src/modules/estimator modified/EKF_main.cpp",
		"/home/aghilas/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_main.cpp",
		"/home/aghilas/firmwarepx4/Firmware/src/modules/estimator modified/module.mk",
		"/home/aghilas/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/AttitudePositionEstimatorEKF.h",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/estimator_utilities.cpp",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/AttitudePositionEstimatorEKF.h",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/estimator_22states.h",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/drivers/drv_sensor.h",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/drivers/drv_range_finder.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_NavEKF/AP_NavEKF.cpp",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/uORB/objects_common.cpp",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/uORB/topics/optical_flow.h",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/position_estimator_inav/position_estimator_inav_main.c",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/drivers/mb12xx/mb12xx.cpp",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/estimator_22states.cpp",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_main.cpp",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/estimator modified/EKF_main",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/drivers/mb12xx/module.mk",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/examples/flow_position_estimator/flow_position_estimator_main.c",
		"/C/Users/Aghilas/School/Master Thesis/firmwarepx4/Firmware/src/modules/ekf_att_pos_estimator/module.mk",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_RangeFinder/AP_RangeFinder_MaxsonarI2CXL.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/Log.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/ArduCopter.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_AHRS/AP_AHRS.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_AHRS/AP_AHRS.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_NavEKF/AP_NavEKF.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Baro/AP_Baro.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Baro/AP_Baro_PX4.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/ArduCopter.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_AHRS/AP_AHRS_DCM.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_AHRS/AP_AHRS_DCM.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_AHRS/AP_AHRS_NavEKF.cpp",
		"/C/Users/Aghilas/School/Master Thesis/InertialNav-master modified/code/main_closed_loop_test_harness-21state.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_AHRS/AP_AHRS_NavEKF.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/Filter/FilterWithBuffer.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/Filter/DerivativeFilter.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Math/quaternion.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_InertialNav/AP_InertialNav.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/inertia.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/DataFlash/LogFile.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_RangeFinder/RangeFinder.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Param/AP_Param.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Param/AP_Param.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Baro/AP_Baro.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/Parameters.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_RangeFinder/AP_RangeFinder.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/APM_OBC/APM_OBC.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_InertialNav/AP_InertialNav.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_InertialNav/AP_InertialNav_NavEKF.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Mount/AP_Mount.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_GPS/AP_GPS.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Limits/AP_Limit_Altitude.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/Tools/Replay/LogReader.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/Tools/Replay/LogReader.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/Tools/Replay/Parameters.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Mission/AP_Mission.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/DataFlash/DataFlash.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/GCS_MAVLink/include/mavlink/v1.0/common/common.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Common/AP_Common.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/Filter/keywords.txt",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/Filter/DerivativeFilter.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_InertialNav/AP_InertialNav_NavEKF.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Vehicle/AP_Vehicle.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/DataFlash/examples/DataFlash_test/DataFlash_test.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_GPS/AP_GPS.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/DataFlash/DataFlash_File.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Baro/AP_Baro_PX4.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Math/AP_Math.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/mk/PX4/ROMFS/init.d/rc.error",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/mk/PX4/ROMFS/init.d/rcS",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_HAL_FLYMAPLE/RCOutput.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/mk/PX4/px4_common.mk",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/mk/PX4/ROMFS/init.d/rc.APM",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_Airspeed/AP_Airspeed_PX4.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/test.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AC_WPNav/AC_WPNav.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AC_WPNav/AC_WPNav.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/control_stabilize.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/flight_mode.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/Filter/FilterClass.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/switches.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/AP_State.pde",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/AP_InertialSensor/AP_InertialSensor.cpp",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/config.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/compat.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/APM_Config_mavlink_hil.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/defines.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/ArduCopter/APM_Config.h",
		"/C/Users/Aghilas/School/Master Thesis/ardupilot-ArduCopter-3.2.1-apm-px4/libraries/DataFlash/DataFlash_APM1.cpp",
		"/C/Users/Aghilas/Downloads/DataFlash.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/modules/ekf_att_pos_estimator/estimator_22states.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_main.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/modules/ekf_att_pos_estimator/AttitudePositionEstimatorEKF.h",
		"/C/Users/Aghilas/Dropbox/Master Thesis/Pos_estimator/C_code/inertial_filter.c",
		"/C/Users/Aghilas/Dropbox/Master Thesis/Pos_estimator/C_code/position_estimator_inav_main.c",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/C-code_2015-03-11/attitude_estimator_ekf_params.h",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/C-code_2015-03-11/attitude_estimator_ekf_params.c",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/C-code_2015-03-11/codegen/AttitudeEKF.h",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/C-code_2015-03-11/attitude_estimator_ekf_main.cpp",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/C-code_2015-03-11/codegen/AttitudeEKF.c",
		"/C/Users/Aghilas/Dropbox/Master Thesis/Pos_estimator/C_code/position_estimator_inav_params.c",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/lib/mathlib/mathlib.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/platforms/px4_includes.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/modules/systemlib/param/param.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/lib/mathlib/math/Matrix.hpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/modules/test/exp.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/platforms/px4_defines.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/lib/mathlib/math/Limits.hpp",
		"/C/Users/Aghilas/Dropbox/Master Thesis/Pos_estimator/C_code/position_estimator_inav_params.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/lib/mathlib/math/eigen_math.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/modules/attitude_estimator_ekf/exp.cpp",
		"/C/Users/Aghilas/School/Master program/3 semester/programming in c++ 2/Source codes/mod02/exp.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/FUCKIG TEST/px4_defines.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/platforms/ros/eigen_math.h",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/lib/mathlib/math/test/test.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/FUCKIG TEST/main.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/test/maintest.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/test/main.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/maintest.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/lib/mathlib/math/test/main.cpp",
		"/C/Users/Aghilas/School/Master Thesis/px4 firmware/Firmware-master/src/lib/mathlib/math/eigen_math.h.h",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/C-code_2015-03-11/codegen/rtwtypes.h",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/C-code_2015-03-11/codegen/AttitudeEKF_types.h",
		"/C/Users/Aghilas/Dropbox/Master Thesis/EKF/attitude_estimator_ekf_params.c"
	],
	"find":
	{
		"height": 49.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"gpsHgt",
			"initializeGPS",
			"_baro_ref_offset",
			"_baro_ref",
			"hgtMea",
			"publish",
			"baro",
			"publish",
			"_baro",
			"HIGH",
			"publish",
			"IMU",
			"_att",
			"publishAttitude",
			"publish",
			"UpdateStrapdownEquationsNED",
			"updateSensorFusion",
			"publishAttitude",
			"publishLocalPosition",
			"_baro_ref_offset",
			"publishLocalPosition",
			"_baro_alt_filt",
			"_baro_ref",
			"baroHgt",
			"_baro_alt_filt",
			"baro_alt",
			"rc",
			"updateDtHgtFilt",
			"barohgt",
			"baroHgt",
			"fuseCamHgt",
			"updateSensorFusion",
			"_newCamData",
			"baroHgt",
			"_baro_ref",
			"baroHgt",
			"state",
			"varInnovVelPos",
			"hgtVarianceScaler",
			"R_OBS",
			"hgtinnov2",
			"ekf_status_report",
			"current_ekf_state",
			"last_ekf_error",
			"current_ekf_state",
			"ekf_status_report",
			"ekf_report",
			"check_filter",
			"ekf_report",
			"ekf_status",
			"hgtHealth",
			"hgtInnov",
			"camHgt",
			"cam",
			"obsIndex",
			"baroflag",
			"varInnovVelPos",
			"ekfDiverged",
			"CheckAndBound",
			"fuseData",
			"obsIndex",
			"n_hgtMeas",
			"obsIndex",
			"observation",
			"innovVelPos",
			"n_hgtMeas",
			"fusionFlag",
			"n_hgtMeas",
			"_mavlink_fd",
			"mavlink_log_info",
			"fusevelpos",
			"R_OBS[6]",
			"n_ctrl",
			"useairspe",
			"gpsRetryTime",
			"observation",
			"gpsRetryTime",
			"fusevelpos",
			"fuseHgtData",
			"predicstates",
			"UpdateStrapdownEquationsNED",
			"states",
			"baro",
			"gpsRetryTimeNoTAS",
			"hgtRetryTime",
			"horizRetryTime",
			"useAirspeed",
			"gpsRetryTime",
			"n_hgtMeas",
			"int",
			"gpsRetryTime",
			"hgtMea2",
			"baroHgt",
			"_baro",
			"baroHgt",
			"_baro",
			"camHgt",
			"_baro_sub",
			"_baro",
			"camHgt",
			"_baro",
			"camHgt",
			"hgtMea",
			"updateSensorFusion",
			"posDSigma",
			"z_cam_noise",
			"cam_z_delay_ms",
			"vel_delay_ms",
			"_cam_pos",
			"_visionGrnd_sub",
			"_perf_baro",
			"gpsRetryTime",
			"fuseData",
			"n_ctrl",
			"R_OBS",
			"fuseData",
			"OpticalFlowEKF",
			"updateSensorFusion",
			"_newRangeData",
			"_distance_sub",
			"vision",
			"MB12XX",
			"g_dev",
			"start",
			"sonar",
			"sonar_last",
			"sonar",
			"OpticalFlowEKF"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"hgtInnovCam",
			"brandnew"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_main.cpp",
					"settings":
					{
						"buffer_size": 51565,
						"regions":
						{
						},
						"selection":
						[
							[
								25368,
								25368
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 12271.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/modules/ekf_att_pos_estimator/estimator_22states.cpp",
					"settings":
					{
						"buffer_size": 222269,
						"regions":
						{
						},
						"selection":
						[
							[
								103339,
								103339
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 27410.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/modules/ekf_att_pos_estimator/estimator_22states.h",
					"settings":
					{
						"buffer_size": 17228,
						"regions":
						{
						},
						"selection":
						[
							[
								12517,
								12517
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3859.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "src/modules/ekf_att_pos_estimator/AttitudePositionEstimatorEKF.h",
					"settings":
					{
						"buffer_size": 11929,
						"regions":
						{
						},
						"selection":
						[
							[
								8732,
								8732
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2907.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "src/modules/ekf_att_pos_estimator/ekf_att_pos_estimator_params.c",
					"settings":
					{
						"buffer_size": 7330,
						"regions":
						{
						},
						"selection":
						[
							[
								2542,
								2542
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 1939.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "src/modules/uORB/topics/vision_position_estimate.h",
					"settings":
					{
						"buffer_size": 3079,
						"regions":
						{
						},
						"selection":
						[
							[
								2591,
								2591
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 630.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "src/modules/ekf_att_pos_estimator/estimator_utilities.h",
					"settings":
					{
						"buffer_size": 3775,
						"regions":
						{
						},
						"selection":
						[
							[
								3189,
								3189
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 954.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "src/modules/ekf_att_pos_estimator/estimator_utilities.cpp",
					"settings":
					{
						"buffer_size": 6071,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "src/modules/uORB/topics/vehicle_attitude.h",
					"settings":
					{
						"buffer_size": 2460,
						"regions":
						{
						},
						"selection":
						[
							[
								2297,
								2297
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 540.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "src/modules/uORB/topics/vehicle_local_position.h",
					"settings":
					{
						"buffer_size": 2624,
						"regions":
						{
						},
						"selection":
						[
							[
								2498,
								2498
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 765.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "src/modules/uORB/topics/sensor_combined.h",
					"settings":
					{
						"buffer_size": 7555,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1215.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 22.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 100.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"replace":
	{
		"height": 150.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 338.0,
	"status_bar_visible": false
}
